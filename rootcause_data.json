{
  "IT": {
    "type": "Business Logic Flaw",
    "date": "2024-03-13",
    "rootCause": "In the 'transfer' function, if sender is pair address (buy IT token), IT tokens are minted to pair in 'mintToPoolIfNeeded' function. Hacker exploited this. Also to make 'mintAmount' bigger, he transferred 2000 USDT into pair.\n\n**Attack Tx:**\n\n[https://phalcon.blocksec.com/explorer/tx/bsc/0xb33057f57ce451aa8cbb65508d298fe3c627509cc64a394736dace2671b6dcfa](https://phalcon.blocksec.com/explorer/tx/bsc/0xb33057f57ce451aa8cbb65508d298fe3c627509cc64a394736dace2671b6dcfa)\n\n**Analysis:**\n\n",
    "images": [],
    "Lost": "13k USDT",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/IT_exp.sol"
  },
  "ElasticSwap": {
    "type": "Incorrect logic",
    "date": "2022-12-13",
    "rootCause": " \n\nBusiness Logic Flaw.\n\nElasticSwap is an AMM focused on elastic supply tokens. \nAn elastic supply (or rebase) token works in a way that the circulating supply expands or contracts due to changes in token price. \nElasticSwap adapts to the elastic supply changes without the need for someone to call a function on the pool itself after a change (rebase) happens.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction addLiquidity(uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _liquidityTokenRecipient){//vulnerable point\n\tMathLib.TokenQtys memory tokenQtys = MathLib.calculateAddLiquidityQuantities(, , , , IERC20(baseToken).balanceOf(address(this)), totalSupply, internalBalances);\n\tinternalBalances.kLast = internalBalances.baseTokenReserveQty * internalBalances.quoteTokenReserveQty;\n}\n\nfunction removeLiquidity(uint256 _liquidityTokenQty, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _tokenRecipient){//vulnerable point\n\tuint256 baseTokenReserveQty  = IERC20(baseToken).balanceOf(address(this));\n\tuint256 quoteTokenReserveQty = IERC20(quoteToken).balanceOf(address(this));\n\t\n\tuint256 baseTokenQtyToReturn  = (_liquidityTokenQty * baseTokenReserveQty) / totalSupplyOfLiquidityTokens;\n\tuint256 quoteTokenQtyToReturn = (_liquidityTokenQty * quoteTokenReserveQty) / totalSupplyOfLiquidityTokens;\n\n\tuint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty;\n\tuint256 baseTokenQtyToRemoveFromInternalAccounting = (_liquidityTokenQty * internalBaseTokenReserveQty) / totalSupplyOfLiquidityTokens;\n\t\n\tinternalBalances.baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;\n\t\n\tinternalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn;  // @audit: doesn't sync the reserves (as in UniswapPair.burn())\n\t\n  IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n  IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n}\n```\n\n**Attack tx:** \n\n[https://explorer.phalcon.xyz/tx/eth/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f](https://explorer.phalcon.xyz/tx/eth/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f)\n\n**Analysis:**\n\n[https://quillaudits.medium.com/decoding-elastic-swaps-850k-exploit-quillaudits-9ceb7fcd8d1a](https://quillaudits.medium.com/decoding-elastic-swaps-850k-exploit-quillaudits-9ceb7fcd8d1a)",
    "images": [],
    "Lost": "$845k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ElasticSwap_exp.sol"
  },
  "Paribus": {
    "type": "Reentrancy",
    "date": "2023-04-11",
    "rootCause": "\n\nReentrancy, doTransferOut() before updating variables\n\n**Vulnerable code snippet:**\n\n```jsx\nfunction redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) { **// @audit: useless ReentrancyGuard since it was a cross-contract attack**\n  accrueInterest();\n\n  return redeemFresh(msg.sender, redeemTokens, 0);\n}\n\nfunction redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {  \n  ...\n\tvars.totalSupplyNew = sub_(totalSupply, vars.redeemTokens, 'REDEEM_TOO_MUCH');\n\tvars.accountTokensNew = sub_(accountTokens[redeemer], vars.redeemTokens, 'REDEEM_TOO_MUCH');\n\n\tdoTransferOut(redeemer, vars.redeemAmount); **//vulnerable point**\n\n  // @audit: vital variables are updated after interaction (doTransferOut)\n\ttotalSupply = vars.totalSupplyNew;\n\taccountTokens[redeemer] = vars.accountTokensNew;\n\n\tcomptroller.redeemVerify();\n}\n```\n\n**Attack tx:**\n\n[https://arbiscan.io/tx/0x0e29dcf4e9b211a811caf00fc8294024867bffe4ab2819cc1625d2e9d62390af](https://arbiscan.io/tx/0x0e29dcf4e9b211a811caf00fc8294024867bffe4ab2819cc1625d2e9d62390af)\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1645742620897955842](https://twitter.com/Phalcon_xyz/status/1645742620897955842)\n\n[https://twitter.com/BlockSecTeam/status/1645744655357575170](https://twitter.com/BlockSecTeam/status/1645744655357575170)\n\n[https://twitter.com/peckshield/status/1645742296904929280](https://twitter.com/peckshield/status/1645742296904929280)",
    "images": [],
    "Lost": "$100k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Paribus_exp.sol"
  },
  "Binemon": {
    "type": "Business Logic Flaw",
    "date": "2024-03-11",
    "rootCause": "\n\nThe Root Cause is in \"borrow\" function, it transfer MO tokens from pair to BURN address. After several \"borrow\" call, pair contains a few MO tokens.So hacker could drain pair with small amount of MO. Also in \"borrow\" function, MO token price is calculated using ratio of MO and USDT in pair. After several borrowing, MO price got much higher, he could borrow all USDT with small amount of MO tokens.\n\n\n\n\n\n**Attack Tx:**\n\n[https://phalcon.blocksec.com/explorer/tx/optimism/0x4ec3061724ca9f0b8d400866dd83b92647ad8c943a1c0ae9ae6c9bd1ef789417](https://phalcon.blocksec.com/explorer/tx/optimism/0x4ec3061724ca9f0b8d400866dd83b92647ad8c943a1c0ae9ae6c9bd1ef789417)\n\n**Analysis:**\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "413k USDT",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/MO_exp.sol"
  },
  "Visor Finance": {
    "type": "Dex/AMM, Insufficient validation, Reentrancy",
    "date": "2021-12-21",
    "rootCause": "Insufficient validation & Reentrancy\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef#code#F1#L41](https://etherscan.io/address/0xc9f27a50f82571c1c8423a42970613b8dbda14ef#code#F1#L41)\n\nDue to from is controllable, attacker can create a custom contract to return specific owner() to pass the check. Then reenter the deposit function via delegatedTransferERC20 function.\n\n```solidity\n// @param visr Amount of VISR transfered from sender to Hypervisor\n    // @param to Address to which liquidity tokens are minted\n    // @param from Address from which tokens are transferred \n    // @return shares Quantity of liquidity tokens minted as a result of deposit\n    function deposit(\n        uint256 visrDeposit,\n        address payable from,\n        address to\n    ) external returns (uint256 shares) {\n        require(visrDeposit > 0, \"deposits must be nonzero\");\n        require(to != address(0) && to != address(this), \"to\");\n        require(from != address(0) && from != address(this), \"from\");\n\n        shares = visrDeposit;\n        if (vvisr.totalSupply() != 0) {\n          uint256 visrBalance = visr.balanceOf(address(this));\n          shares = shares.mul(vvisr.totalSupply()).div(visrBalance);\n        }\n\n        if(isContract(from)) {\n          require(IVisor(from).owner() == msg.sender);  **//vulnerable point**\n          IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);\n        }\n        else {\n          visr.safeTransferFrom(from, address(this), visrDeposit);\n        }\n\n        vvisr.mint(to, shares);\n    }\n```",
    "images": [],
    "Lost": "$8.2 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20211221-visor-finance---reentrancy"
  },
  "Grim Finance": {
    "type": "Insufficient validation, Reentrancy, Yield",
    "date": "2021-12-18",
    "rootCause": "Insufficient validation & Reentrancy\n\nVulnerable code snippet:\n\n[https://ftmscan.com/address/0x660184ce8af80e0b1e5a1172a16168b15f4136bf#code#L1115](https://ftmscan.com/address/0x660184ce8af80e0b1e5a1172a16168b15f4136bf#code#L1115)\n\nDue to token is controllable, the attacker can send fake tokens to the GrimBoostVault through the fake contract created by attacker. Then successful to mint protocol token.\n\n```solidity\nfunction depositFor(address token, uint _amount,address user ) public {\n\n        uint256 _pool = balance();\n        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); **//vulnerable point**\n        earn();\n        uint256 _after = balance();\n        _amount = _after.sub(_pool); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(user, shares);\n    }\n```",
    "images": [],
    "Lost": "$30 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20211218-grim-finance---flashloan--reentrancy"
  },
  "MonoX Finance": {
    "type": "Dex/AMM",
    "date": "2021-11-30",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x66e7d7839333f502df355f5bd87aea24bac2ee63#code#F1#L471](https://etherscan.io/address/0x66e7d7839333f502df355f5bd87aea24bac2ee63#code#F1#L471)\n\n(1)Due to to is controllable, attacker can remove anyone\u2019s liquidity.\n\n```solidity\n// actually removes liquidity\n  function removeLiquidity (address _token, uint256 liquidity, address to, \n    uint256 minVcashOut, \n    uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {\n    (vcashOut, tokenOut) = _removeLiquidityHelper (_token, liquidity, to, minVcashOut, minTokenOut, false);\n  }\n\n// actually removes liquidity\n  function _removeLiquidityHelper (address _token, uint256 liquidity, address to, \n    uint256 minVcashOut, \n    uint256 minTokenOut,\n    bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut)  {\n    require (tokenPoolStatus[_token]==1, \"MonoX:NO_TOKEN\");\n    PoolInfo memory pool = pools[_token];\n    uint256 poolValue;\n    uint256 liquidityIn;\n    (poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to);**//vulnerable point**\n    _mintFee(pool.pid, pool.lastPoolValue, poolValue);\n    require (vcashOut>=minVcashOut, \"MonoX:INSUFF_vCash\");\n    require (tokenOut>=minTokenOut, \"MonoX:INSUFF_TOKEN\");\n\n    if (vcashOut>0){\n      vCash.mint(to, vcashOut);\n    }\n    if (!isETH) {\n      monoXPool.safeTransferERC20Token(_token, to, tokenOut);\n    } else {\n      monoXPool.withdrawWETH(tokenOut);\n      monoXPool.safeTransferETH(to, tokenOut);\n    }\n\n    monoXPool.burn(to, pool.pid, liquidityIn);\n\n    _syncPoolInfo(_token, 0, vcashOut);\n\n    emit RemoveLiquidity(to, \n      pool.pid,\n      _token,\n      liquidityIn, \n      vcashOut, tokenOut, pool.price);\n  }\n```\n\n(2)\n\n[https://etherscan.io/address/0x66e7d7839333f502df355f5bd87aea24bac2ee63#code#F1#L824](https://etherscan.io/address/0x66e7d7839333f502df355f5bd87aea24bac2ee63#code#F1#L824)\n\nAttack can input tokenIn and tokenOut with same token because of without any validation. so attacker can perform multiple swap to manipulate the token price.\n\n```solidity\n// swap from tokenIn to tokenOut with fixed tokenIn amount.\n  function swapIn (address tokenIn, address tokenOut, address from, address to,\n      uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {\n...\n// trading in\n    if(tokenIn==address(vCash)){\n      vCash.burn(monoXPoolLocal, amountIn);\n      // all fees go to the other side\n      oneSideFeesInVcash = oneSideFeesInVcash.mul(2);\n    }else{\n      _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);\n    }\n\n    // trading out\n    if(tokenOut==address(vCash)){\n      vCash.mint(to, amountOut);\n    }else{\n      if (to != monoXPoolLocal) {\n        IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);\n      }\n      _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, \n        to == monoXPoolLocal ? amountOut : 0);\n    }\n```",
    "images": [],
    "Lost": "$31 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20211130-monox-finance---price-manipulation"
  },
  "SushiSwap": {
    "type": "Access Control, Dex/AMM, Insufficient validation",
    "date": "2023-04-09",
    "rootCause": "\n\nSushi RouteProcessor2 does not check user input `route` carefully.\n\n The root cause is that ProcessRoute does not perform any checks on the user-provided route parameter, allowing the attacker to exploit this issue by constructing a malicious route parameter that causes the contract to read a Pool created by the attacker.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x044b75f554b886A065b9567891e45c79542d7357#code#F1#L53](https://etherscan.io/address/0x044b75f554b886A065b9567891e45c79542d7357#code#F1#L53)\n\n/// @notice Processes the route generated off-chain. Has a lock\n/// @param tokenIn Address of the input token\n/// @param amountIn Amount of the input token\n/// @param tokenOut Address of the output token\n/// @param amountOutMin Minimum amount of the output token\n/// @return amountOut Actual amount of the output token\nfunction processRoute(\naddress tokenIn,\nuint256 amountIn,\naddress tokenOut,\nuint256 amountOutMin,\naddress to,\nbytes memory route\n) external payable lock returns (uint256 amountOut) {\nreturn processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n}\n\n```solidity\n/// @notice Processes the route generated off-chain. Has a lock\n  /// @param tokenIn Address of the input token\n  /// @param amountIn Amount of the input token\n  /// @param tokenOut Address of the output token\n  /// @param amountOutMin Minimum amount of the output token\n  /// @return amountOut Actual amount of the output token\n  function processRoute(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    bytes memory route **//vulnerable point**\n  ) external payable lock returns (uint256 amountOut) {\n    return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);\n  }\n```\n\n**Attack tx:**\n\n**Attack tx:**\n\n[https://www.notion.so](https://www.notion.so)\n\n[https://library.dedaub.com/ethereum/tx/0x04b166e7b4ab5105a8e9c85f08f6346de1c66368687215b0e0b58d6e5002bc32](https://library.dedaub.com/ethereum/tx/0x04b166e7b4ab5105a8e9c85f08f6346de1c66368687215b0e0b58d6e5002bc32)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1644907207530774530](https://twitter.com/peckshield/status/1644907207530774530)\n [https://twitter.com/SlowMist_Team/status/1644936375924584449](https://twitter.com/SlowMist_Team/status/1644936375924584449)\n [https://twitter.com/AnciliaInc/status/1644925421006520320](https://twitter.com/AnciliaInc/status/1644925421006520320)",
    "images": [],
    "Lost": "$3.3M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sushi_Router_exp.sol"
  },
  "Nimbus Platform": {
    "type": "Miscalculation, Yield",
    "date": "2021-09-15",
    "rootCause": "Incorrect calculation\n\nVulnerable code snippet: same Uranium, NowSwap issue\n\n[https://etherscan.io/address/0xc0A6B8c534FaD86dF8FA1AbB17084A70F86EDDc1#code#L409](https://etherscan.io/address/0xc0A6B8c534FaD86dF8FA1AbB17084A70F86EDDc1#code#L409)\n\ninconsistent value in the code, 10000 vs 1000\n\n```solidity\n// this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\n        require(amount0Out > 0 || amount1Out > 0, 'Nimbus: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Nimbus: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'Nimbus: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) INimbusCallee(to).NimbusCall(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'Nimbus: INSUFFICIENT_INPUT_AMOUNT');\n\n        {\n        address referralProgram = INimbusFactory(factory).nimbusReferralProgram();\n        if (amount0In > 0) {\n            address _token0 = token0;\n            uint refFee = amount0In.mul(3)/ 1994;\n            _safeTransfer(_token0, referralProgram, refFee);\n            INimbusReferralProgram(referralProgram).recordFee(_token0, to, refFee);\n            balance0 = balance0.sub(refFee);\n        } \n        if (amount1In > 0) {\n            uint refFee = amount1In.mul(3) / 1994;\n            address _token1 = token1;\n            _safeTransfer(_token1, referralProgram, refFee);\n            INimbusReferralProgram(referralProgram).recordFee(_token1, to, refFee);\n            balance1 = balance1.sub(refFee);\n        }\n        }\n        \n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(15)); **//vulnerable point**\n        uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(15)); **//vulnerable point**\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Nimbus: K'); //vulnerable\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n```",
    "images": [],
    "Lost": "1.45 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210915-nimbus-platform"
  },
  "NowSwap Platform": {
    "type": "Dex/AMM, Miscalculation",
    "date": "2021-09-15",
    "rootCause": "Incorrect calculation\n\nSame Uranium, NowSwap and Nimbus issue\n\nVulnerable code snippet:\n\ninconsistent value in the code, 10000 vs 1000\n\n[https://etherscan.io/address/0xa14660a33cc608b902f5bb49c8213bd4c8a4f4ca#code](https://etherscan.io/address/0xa14660a33cc608b902f5bb49c8213bd4c8a4f4ca#code) unverified contract",
    "images": [],
    "Lost": "$1 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210915-nowswap-platform"
  },
  "ZABU Finance": {
    "type": "Deflationary token, Insufficient validation, Yield",
    "date": "2021-09-12",
    "rootCause": "Incorrect calculation\n\nVulnerable code snippet: \n\n[https://snowtrace.io/address/0x6e7f5c0b9f4432716bdd0a77a3601291b9d9e985#code#L575](https://snowtrace.io/address/0x6e7f5c0b9f4432716bdd0a77a3601291b9d9e985#code#L575)\n\n[https://github.com/zabufinance/YieldFarm/blob/main/ZABUFarm.sol#L769](https://github.com/zabufinance/YieldFarm/blob/main/ZABUFarm.sol#L769)\n\nDue to SPORE is a deflationary token\n\n1.Deposit SPORE tokens to DefilyFarm to deduct SPORE token in DefilyFarm contract.\n\n2.Until lp token balance in contract is 2. Then calculate a big reward value in updatePool function.\n\n```solidity\nfunction _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if (block.timestamp < allowTradeAt + 24 hours && amount >= 10**6 * 10**9 ) {\n             revert(\"You cannot transfer more than 1 billion now\");  }\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\nfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n```\n\n```solidity\n// Deposit LP tokens to DefilyFarm for reward allocation.\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user.amount.mul(pool.accRewardPerShare).div(1e12).sub(user.rewardDebt);\n            safeTokenTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n// Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 reward = multiplier.mul(rewardPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        safeTokenTransferReward(reward);\n        pool.accRewardPerShare = pool.accRewardPerShare.add(reward.mul(1e12).div(lpSupply)); **//vulnerable point**\n        pool.lastRewardBlock = block.number;\n    }\n```",
    "images": [],
    "Lost": "$3.2 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210912-zabu-finance---deflationary-token-uncompatible"
  },
  "DAO Maker": {
    "type": "Access Control, DAO",
    "date": "2021-09-03",
    "rootCause": "incorrect access control\n\nVulnerable code snippet: \n\nNeed to decompile:\n\n[https://etherscan.io/address/0xf17ca0e0f24a5fa27944275fa0cedec24fbf8ee2#code](https://etherscan.io/address/0xf17ca0e0f24a5fa27944275fa0cedec24fbf8ee2#code)\n\n```solidity\nfunction emergencyExit(address varg0) public payable {  **//vulnerable point**\n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require((address(_hasInitialized >> 8)).code.size);\n    v0, v1 = address(_hasInitialized >> 8).balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    MEM[MEM[64]] = 68;\n    if (this.balance >= 0) {\n        if ((address(_hasInitialized >> 8)).code.size) {\n            v2 = v3 = MEM[64];\n            v4 = v5 = MEM[MEM[64]];\n            v6 = v7 = 32 + MEM[64];\n            while (v4 >= 32) {\n                MEM[v2] = MEM[v6];\n                v4 = v4 + ~31;\n                v2 += 32;\n                v6 += 32;\n            }\n            MEM[v2] = MEM[v6] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n            v8, v9, v10, v11 = address(_hasInitialized >> 8).transfer(varg0, v1).gas(msg.gas);\n            if (RETURNDATASIZE() == 0) {\n                v12 = v13 = 96;\n            } else {\n                v12 = v14 = new bytes[](RETURNDATASIZE());\n                RETURNDATACOPY(v14.data, 0, RETURNDATASIZE());\n            }\n            if (!v8) {\n                require(!MEM[v12], v11, MEM[v12]);\n                v15 = new array[](v16.length);\n                v17 = v18 = 0;\n                while (v17 < v16.length) {\n                    MEM[v17 + v15.data] = MEM[v17 + v16.data];\n                    v17 += 32;\n                }\n                v19 = v20 = v16.length + v15.data;\n                if (0) {\n                    MEM[v20 - 0] = ~0x0 & MEM[v20 - 0];\n                }\n                revert(v15, v21, 'SafeERC20: low-level call failed');\n            } else {\n                if (MEM[v12]) {\n                    require(MEM[v12] >= 32);\n                    require(MEM[32 + v12], 'SafeERC20: ERC20 operation did not succeed');\n                }\n                exit;\n            }\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            revert('Address: call to non-contract');\n        }\n    } else {\n        MEM[4 + MEM[64]] = 32;\n        revert('Address: insufficient balance for call');\n    }\n}\n```",
    "images": [],
    "Lost": "$4 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210903-dao-maker---bad-access-controal"
  },
  "Cream Finance": {
    "type": "ERC777, Reentrancy, lending",
    "date": "2021-08-30",
    "rootCause": "Reentrancy via ERC777 hook\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x96cc0f947b6c8f4675159ea03144f8c17d5a2fc8#code#F1#L79](https://etherscan.io/address/0x96cc0f947b6c8f4675159ea03144f8c17d5a2fc8#code#F1#L79)\n\n[https://etherscan.io/address/0xfF20817765cB7f73d4bde2e66e067E58D11095C2#code#L1671](https://etherscan.io/address/0xfF20817765cB7f73d4bde2e66e067E58D11095C2#code#L1671)\n\nuse tokensReceived hook to reenter borrow()\n\n```solidity\nfunction borrow(uint256 borrowAmount) external returns (uint256) {\n        return borrowInternal(borrowAmount, false);\n    }\n```\n\n```solidity\nfunction _transferByPartition(\n        bytes32 _fromPartition,\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        bytes memory _operatorData\n    ) internal returns (bytes32) {\n        require(_to != address(0), EC_57_INVALID_RECEIVER);\n\n        // If the `_operator` is attempting to transfer from a different `_from`\n        // address, first check that they have the requisite operator or\n        // allowance permissions.\n        if (_from != _operator) {\n            require(\n                _isOperatorForPartition(_fromPartition, _operator, _from) ||\n                    (_value <= _allowedByPartition[_fromPartition][_from][_operator]),\n                EC_53_INSUFFICIENT_ALLOWANCE\n            );\n\n            // If the sender has an allowance for the partition, that should\n            // be decremented\n            if (_allowedByPartition[_fromPartition][_from][_operator] >= _value) {\n                _allowedByPartition[_fromPartition][_from][msg\n                    .sender] = _allowedByPartition[_fromPartition][_from][_operator].sub(\n                    _value\n                );\n            } else {\n                _allowedByPartition[_fromPartition][_from][_operator] = 0;\n            }\n        }\n\n        _callPreTransferHooks( **//vulnerable point,** call hook\n            _fromPartition,\n            _operator,\n            _from,\n            _to,\n            _value,\n            _data,\n            _operatorData\n        );\n\n        require(\n            _balanceOfByPartition[_from][_fromPartition] >= _value,\n            EC_52_INSUFFICIENT_BALANCE\n        );\n\n        bytes32 toPartition = PartitionUtils._getDestinationPartition(\n            _data,\n            _fromPartition\n        );\n\n        _removeTokenFromPartition(_from, _fromPartition, _value);\n        _addTokenToPartition(_to, toPartition, _value);\n        _callPostTransferHooks(\n            toPartition,\n            _operator,\n            _from,\n            _to,\n            _value,\n            _data,\n            _operatorData\n        );\n\n        emit Transfer(_from, _to, _value);\n        emit TransferByPartition(\n            _fromPartition,\n            _operator,\n            _from,\n            _to,\n            _value,\n            _data,\n            _operatorData\n        );\n\n        if (toPartition != _fromPartition) {\n            emit ChangedPartition(_fromPartition, toPartition, _value);\n        }\n\n        return toPartition;\n    }\n```",
    "images": [],
    "Lost": "$18 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210830-cream-finance---flashloan-attack--reentrancy"
  },
  "XSURGE": {
    "type": "Flashloans, Reentrancy, Stablecoin",
    "date": "2021-08-17",
    "rootCause": "Reentrancy\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xe1e1aa58983f6b8ee8e4ecd206cea6578f036c21#code#L581](https://bscscan.com/address/0xe1e1aa58983f6b8ee8e4ecd206cea6578f036c21#code#L581)\n\nDon\u2019t follow check-effect-interaction pattern.\n\n```solidity\n    /** Sells SURGE Tokens And Deposits the BNB into Seller's Address */\n    function sell(uint256 tokenAmount) public nonReentrant returns (bool) {\n        \n        address seller = msg.sender;\n        \n        // make sure seller has this balance\n        require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n        \n        // calculate the sell fee from this transaction\n        uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);\n        \n        // how much BNB are these tokens worth?\n        uint256 amountBNB = tokensToSwap.mul(calculatePrice());\n        \n        // send BNB to Seller\n        (bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(\"\");  //vulnerable point\n        if (successful) {\n            // subtract full amount from sender\n            _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');\n            // if successful, remove tokens from supply\n            _totalSupply = _totalSupply.sub(tokenAmount);  **//vulnerable point**\n        } else {\n            revert();\n        }\n        emit Transfer(seller, address(this), tokenAmount);\n        return true;\n    }\n    \n    /** Returns the Current Price of the Token */\n    function calculatePrice() public view returns (uint256) {\n        return ((address(this).balance).div(_totalSupply));\n    }\n    \n    /** Mints Tokens to the Receivers Address */\n    function mint(address receiver, uint amount) internal {\n        _balances[receiver] = _balances[receiver].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n    }\n    \n    /** Amount of BNB in Contract */\n    function getBNBQuantityInContract() public view returns(uint256){\n        return address(this).balance;\n    }\n    /** Returns the value of your holdings before the 6% sell fee */\n    function getValueOfHoldings(address holder) public view returns(uint256) {\n        return _balances[holder].mul(calculatePrice());\n    }\n    \n    receive() external payable {\n        uint256 val = msg.value;\n        address buyer = msg.sender;\n        purchase(buyer, val);\n    }\n```",
    "images": [],
    "Lost": "$5 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210817-xsurge---flashloan-attack--reentrancy"
  },
  "Poly Network": {
    "type": "Bridge, CrossChain, Insufficient validation",
    "date": "2021-08-11",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet:\n\nbrute-force a\u00a0**_method** field that hashes\u00a0to a 32-bit value\u00a0that is exactly the ID for\u00a0putCurEpochConPubKeyBytes!\n\n[https://research.kudelskisecurity.com/2021/08/12/the-poly-network-hack-explained/](https://research.kudelskisecurity.com/2021/08/12/the-poly-network-hack-explained/)",
    "images": [],
    "Lost": "$611 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210811-poly-network---bridge-getting-around-modifier-through-cross-chain-message"
  },
  "WaultFinace": {
    "type": "Dex/AMM, Flashloans",
    "date": "2021-08-04",
    "rootCause": "incorrect logic\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xa79Fe386B88FBee6e492EEb76Ec48517d1eC759a#code#L698](https://bscscan.com/address/0xa79Fe386B88FBee6e492EEb76Ec48517d1eC759a#code#L698)\n\nAttacker can stake lots of USDT to WUSDMaster to raise the price of WEX.\n\n```solidity\nfunction stake(uint256 amount) external nonReentrant {\n        require(amount <= maxStakeAmount, 'amount too high');\n        usdt.safeTransferFrom(msg.sender, address(this), amount);\n        if(feePermille > 0) {\n            uint256 feeAmount = amount * feePermille / 1000;\n            usdt.safeTransfer(treasury, feeAmount);\n            amount = amount - feeAmount;\n        }\n        uint256 wexAmount = amount * wexPermille / 1000;\n        usdt.approve(address(wswapRouter), wexAmount);\n        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( **//vulnerable point**, incorrect logic\n            wexAmount,\n            0,\n            swapPath,\n            address(this),\n            block.timestamp\n        );\n        wusd.mint(msg.sender, amount);\n        \n        emit Stake(msg.sender, amount);\n    }\n```",
    "images": [],
    "Lost": "390 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210804-waultfinace---flashloan-price-manipulation"
  },
  "Chainswap": {
    "type": "Bridge, CrossChain, Incorrect logic",
    "date": "2021-07-02",
    "rootCause": "insufficient validation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xc5185d2c68aAa7c5f0921948f8135d01510D647F#code#L2386](https://bscscan.com/address/0xc5185d2c68aAa7c5f0921948f8135d01510D647F#code#L2386)\n\nAttacker only needs to generate a random address and generate the corresponding signature to trick ChainSwap.\n\n```solidity\nfunction receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n        _chargeFee();\n        require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n        uint N = signatures.length;\n        require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n        for(uint i=0; i<N; i++) {\n            for(uint j=0; j<i; j++)\n                require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n            bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n            bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n            address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n            require(signatory != address(0), \"invalid signature\");\n            require(signatory == signatures[i].signatory, \"unauthorized\");\n            _decreaseAuthQuota(signatures[i].signatory, volume);\n            emit Authorize(fromChainId, to, nonce, volume, signatory);\n        }\n        received[fromChainId][to][nonce] = volume;\n        _receive(to, volume);\n        emit Receive(fromChainId, to, nonce, volume);\n    }\n\nfunction authQuotaOf(address signatory) virtual public view returns (uint quota) {\n        quota = _authQuotas[signatory]; //vulnerable point, no validation\n        uint ratio  = autoQuotaRatio  != 0 ? autoQuotaRatio  : Factory(factory).getConfig(_autoQuotaRatio_);\n        uint period = autoQuotaPeriod != 0 ? autoQuotaPeriod : Factory(factory).getConfig(_autoQuotaPeriod_);\n        if(ratio == 0 || period == 0 || period == uint(-1))\n            return quota;\n        uint quotaCap = cap().mul(ratio).div(1e18);\n        uint delta = quotaCap.mul(now.sub(lasttimeUpdateQuotaOf[signatory])).div(period);\n        return Math.max(quota, Math.min(quotaCap, quota.add(delta)));\n    }\n```",
    "images": [],
    "Lost": "$0.8 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210702-chainswap---bridge-logic-flaw"
  },
  "SafeDollar": {
    "type": "Deflationary token, Miscalculation, Stablecoin",
    "date": "2021-06-28",
    "rootCause": "Incorrect calculation & Deflationary token uncompatible\n\nSame ZABU finance incident\n\nVulnerable code snippet: \n\n[https://polygonscan.com/address/0xd4a7d5ca5232976ebf9c28b7231bfdbf4c4eee95#code#L1913](https://polygonscan.com/address/0xd4a7d5ca5232976ebf9c28b7231bfdbf4c4eee95#code#L1913)\n\n[https://polygonscan.com/address/0x17684f4d5385fac79e75ceafc93f22d90066ed5c#code#L730](https://polygonscan.com/address/0x17684f4d5385fac79e75ceafc93f22d90066ed5c#code#L730)\n\nDue to PLX is a deflationary token\n\n1.Deposit PLX tokens to SdoRewardPOOL to deduct PLX token in SdoRewardPOOL contract.\n\n2.Until lp token balance in contract is 2. Then calculate a big reward value in updatePool function.\n\n```solidity\nfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n        _move(from, from, recipient, amount, \"\", \"\");\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n        return true;\n    }\nfunction _move(\n        address _operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal override returns (uint256 _amountSent) {\n        _beforeTokenTransfer(_operator, from, to, amount);\n\n        uint256 _amount = amount;\n\n        if (!_isExcludedFromFee[from] && !_isExcludedToFee[to]) {\n            {\n                uint256 _jackpotRate = jackpotRate;\n                if (_jackpotRate > 0) {\n                    uint256 _jackpotAmount = amount.mul(_jackpotRate).div(10000);\n                    address _jackpotFund = jackpotFund;\n                    _balances[from] = _balances[from].sub(_jackpotAmount, \"MTokenERC777: transfer amount exceeds balance\");\n                    _balances[_jackpotFund] = _balances[_jackpotFund].add(_jackpotAmount);\n                    _amount = _amount.sub(_jackpotAmount);\n                    _totalJackpotAdded = _totalJackpotAdded.add(_jackpotAmount);\n                    emit Transfer(from, _jackpotFund, _jackpotAmount);\n                }\n            }\n            {\n                uint256 _burnAmount = 0;\n                uint256 _burnRate = burnRate;\n                if (_burnRate > 0) {\n                    _burnAmount = amount.mul(_burnRate).div(10000);\n                    _amount = _amount.sub(_burnAmount);\n                }\n                uint256 _addLiquidityRate = addLiquidityRate;\n                if (_addLiquidityRate > 0) {\n                    uint256 _addLiquidityAmount = amount.mul(_addLiquidityRate).div(10000);\n                    _burnAmount = _burnAmount.add(_addLiquidityAmount);\n                    _amount = _amount.sub(_addLiquidityAmount);\n                    addLiquidityAccumulated = addLiquidityAccumulated.add(_addLiquidityAmount);\n                    uint256 _addLiquidityAccumulated = addLiquidityAccumulated;\n                    if (_addLiquidityAccumulated >= minAmountToAddLiquidity) {\n                        _mint(liquidityFund, _addLiquidityAccumulated, \"\", \"\");\n                        _totalLiquidityAdded = _totalLiquidityAdded.add(_addLiquidityAccumulated);\n                        ILiquidityFund(liquidityFund).addLiquidity(_addLiquidityAccumulated);\n                        emit AddLiquidity(_addLiquidityAccumulated);\n                        addLiquidityAccumulated = 0;\n                    }\n                }\n                if (_burnAmount > 0) {\n                    **_burn(from, _burnAmount, \"\", \"\");** **//vulnerable point,** burn token\n                }\n            }\n        }\n```\n\n```solidity\n// Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (now <= pool.lastRewardTime) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardTime = now;\n            return;\n        }\n        if (!pool.isStarted) {\n            pool.isStarted = true;\n            totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\n        }\n        if (totalAllocPoint > 0) {\n            uint256 _time = now.sub(pool.lastRewardTime);\n            uint256 _sdoReward = _time.mul(rewardPerSecond).mul(pool.allocPoint).div(totalAllocPoint);\n            **pool.accSdoPerShare** = pool.accSdoPerShare.add(_sdoReward.mul(1e18).div(lpSupply)); // manipulate lpSupply to 2\n        }\n        pool.lastRewardTime = now;\n    }\n\nfunction _harvestReward(uint256 _pid, address _account) internal {\n        UserInfo storage user = userInfo[_pid][_account];\n        if (user.amount > 0) {\n            PoolInfo storage pool = poolInfo[_pid];\n            uint256 _claimableAmount = user.amount.mul(**pool.accSdoPerShare**).div(1e18).sub(user.rewardDebt);//miscalculation\n            if (_claimableAmount > 0) {\n                IBasisAsset(sdo).mint(_account, _claimableAmount);\n                emit RewardPaid(_account, _pid, _claimableAmount);\n            }\n        }\n    }\n```",
    "images": [],
    "Lost": "$0.2 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210628-safedollar---deflationary-token-uncompatible"
  },
  "Eleven Finance": {
    "type": "Incorrect logic, Yield",
    "date": "2021-06-22",
    "rootCause": "Incorrect logic flow\n\nVulnerable code snippet: \n\n[https://bscscan.com/address/0x27dd6e51bf715cfc0e2fe96af26fc9ded89e4be8?a=0xa5c29d44817551aa499260ab9640584bf124d4b7#code#L1131](https://bscscan.com/address/0x27dd6e51bf715cfc0e2fe96af26fc9ded89e4be8?a=0xa5c29d44817551aa499260ab9640584bf124d4b7#code#L1131)\n\nIn emergencyBurn function, we can see incorrect logic, withdraw token but without burning token. So attacker can withdraw again after calling emergencyBurn.\n\n```solidity\nfunction emergencyBurn() public {  **//vulnerable point**\n        uint balan = balanceOf(msg.sender);\n        uint avai = available();\n        if(avai<balan) IMasterMind(mastermind).withdraw(nrvPid, (balan.sub(avai)));\n        token.safeTransfer(msg.sender, balan);\n        emit Withdrawn(msg.sender, balan, block.number);\n    }\n```",
    "images": [],
    "Lost": "$4.5 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210622-eleven-finance---doesnt-burn-shares"
  },
  "88mph NFT": {
    "type": "Access Control, ERC721",
    "date": "2021-06-07",
    "rootCause": "incorrect access control\n\nVulnerable code snippet: \n\n[https://etherscan.io/address/0xF0b7DE03134857391d8D43Ed48e20EDF21461097#code#F14#L39](https://etherscan.io/address/0xF0b7DE03134857391d8D43Ed48e20EDF21461097#code#F14#L39)\n\nContract init function without modifier check and there was also no initializer modifier to prevent a re-initialization. Anyone could have taken ownership of the NFT contract.\n\n```solidity\nfunction init(  **//vulnerable point,** without modifier check\n        address newOwner,\n        string calldata tokenName,\n        string calldata tokenSymbol\n    ) external {\n        _transferOwnership(newOwner);\n        _tokenName = tokenName;\n        _tokenSymbol = tokenSymbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210607-88mph-nft---access-control"
  },
  "PancakeHunny": {
    "type": "Miscalculation, Yield",
    "date": "2021-06-03",
    "rootCause": "Incorrect profit calculation via balanceOf\n\nVery similar PancakeBunny.\n\nVulnerable code snippet: \n\n[https://bscscan.com/address/0x109Ea28dbDea5E6ec126FbC8c33845DFe812a300#code#L4638](https://bscscan.com/address/0x109Ea28dbDea5E6ec126FbC8c33845DFe812a300#code#L4638)\n\n```solidity\nfunction getReward() override public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.withdraw(reward);\n            uint cakeBalance = IBEP20(CAKE).balanceOf(address(this));\n\n            if (address(minter) != address(0) && minter.isMinter(address(this))) {\n                uint performanceFee = minter.performanceFee(cakeBalance);\n                minter.mintFor(CAKE, 0, performanceFee, msg.sender, depositedAt[msg.sender]); //check mintFor\n                cakeBalance = cakeBalance.sub(performanceFee);\n            }\n\n            IBEP20(CAKE).safeTransfer(msg.sender, cakeBalance);\n            emit RewardPaid(msg.sender, cakeBalance);\n        }\n    }\nfunction mintFor(address flip, uint _withdrawalFee, uint _performanceFee, address to, uint) override external onlyMinter {\n        uint feeSum = _performanceFee.add(_withdrawalFee);\n        IBEP20(flip).safeTransferFrom(msg.sender, address(this), feeSum);\n\n        uint hunnyBNBAmount = tokenToHunnyBNB(flip, IBEP20(flip).balanceOf(address(this))); **//vulnerable point**\n        address flipToken = hunnyBNBFlipToken();\n....\nfunction tokenToHunnyBNB(address token, uint amount) internal returns(uint flipAmount) {\n        if (token == cake) {\n            flipAmount = _cakeToHunnyBNBFlip(amount);\n        } else {\n            // flip\n            flipAmount = _flipToHunnyBNBFlip(token, amount);\n        }\n    }\nfunction _cakeToHunnyBNBFlip(uint amount) private returns(uint flipAmount) {\n        swapToken(cake, amount.div(2), _hunny);\n        swapToken(cake, amount.sub(amount.div(2)), _wbnb);\n\n        **flipAmount = generateFlipToken();**  \n    }\nfunction generateFlipToken() private returns(uint liquidity) {\n        uint amountADesired = IBEP20(_hunny).balanceOf(address(this));\n        uint amountBDesired = IBEP20(_wbnb).balanceOf(address(this));\n\n        IBEP20(_hunny).safeApprove(address(ROUTER), 0);\n        IBEP20(_hunny).safeApprove(address(ROUTER), amountADesired);\n        IBEP20(_wbnb).safeApprove(address(ROUTER), 0);\n        IBEP20(_wbnb).safeApprove(address(ROUTER), amountBDesired);\n\n        (,,liquidity) = ROUTER.addLiquidity(_hunny, _wbnb, amountADesired, amountBDesired, 0, 0, address(this), block.timestamp);\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210603-pancakehunny---incorrect-calculation"
  },
  "PancakeBunny": {
    "type": "Flashloans, Miscalculation, Yield",
    "date": "2021-05-19",
    "rootCause": "Incorrect profit calculation via balanceOf\n\nVery similar PancakeHunny.\n\nVulnerable code snippet: \n\n[https://www.bscscan.com/address/0xed1443def66e4e8901377467d449499eaba1559a#code#F1#L235](https://www.bscscan.com/address/0xed1443def66e4e8901377467d449499eaba1559a#code#F1#L235)\n\n[https://bscscan.com/address/0x819eea71d3f93bb604816f1797d4828c90219b5d#code#F1#L204](https://bscscan.com/address/0x819eea71d3f93bb604816f1797d4828c90219b5d#code#F1#L204)\n\n```solidity\n// @dev profits only (underlying + bunny) + no withdraw fee + perf fee\n    function getReward() external override {\n        uint amount = earned(msg.sender);\n        uint shares = Math.min(amount.mul(totalShares).div(balance()), _shares[msg.sender]);\n        totalShares = totalShares.sub(shares);\n        _shares[msg.sender] = _shares[msg.sender].sub(shares);\n        _cleanupIfDustShares();\n\n        amount = _withdrawTokenWithCorrection(amount);\n        uint depositTimestamp = _depositedAt[msg.sender];\n        uint performanceFee = canMint() ? _minter.performanceFee(amount) : 0;\n        if (performanceFee > DUST) {\n            _minter.mintForV2(address(_stakingToken), 0, performanceFee, msg.sender, depositTimestamp);//check mintForV2\n            amount = amount.sub(performanceFee);\n        }\n\n        _stakingToken.safeTransfer(msg.sender, amount);\n        emit ProfitPaid(msg.sender, amount, performanceFee);\n    }\n```\n\n```solidity\nfunction mintForV2(address asset, uint _withdrawalFee, uint _performanceFee, address to, uint) external payable override onlyMinter {\n        uint feeSum = _performanceFee.add(_withdrawalFee);\n        _transferAsset(asset, feeSum);\n\n        if (asset == BUNNY) {\n            IBEP20(BUNNY).safeTransfer(DEAD, feeSum);\n            return;\n        }\n\n        uint bunnyBNBAmount = _zapAssetsToBunnyBNB(asset, feeSum, true);\n        if (bunnyBNBAmount == 0) return;\n\n        IBEP20(BUNNY_BNB).safeTransfer(BUNNY_POOL, bunnyBNBAmount);\n        IStakingRewards(BUNNY_POOL).notifyRewardAmount(bunnyBNBAmount);\n\n        (uint valueInBNB,) = priceCalculator.valueOfAsset(BUNNY_BNB, bunnyBNBAmount);// check valueOfAsset\n        uint contribution = valueInBNB.mul(_performanceFee).div(feeSum);\n...\nfunction valueOfAsset(address asset, uint amount) public view override returns (uint valueInBNB, uint valueInUSD) {\n        if (asset == address(0) || asset == WBNB) {\n            valueInBNB = amount;\n            valueInUSD = amount.mul(priceOfBNB()).div(1e18);\n        }\n        else if (keccak256(abi.encodePacked(IPancakePair(asset).symbol())) == keccak256(\"Cake-LP\")) {\n            if (IPancakePair(asset).totalSupply() == 0) return (0, 0);\n\n            if (IPancakePair(asset).token0() == WBNB || IPancakePair(asset).token1() == WBNB) {\n                valueInBNB = amount.mul(IBEP20(WBNB).balanceOf(address(asset))).mul(2).div(IPancakePair(asset).totalSupply()); **//vulnerable point,** incorrect calculation\n                valueInUSD = valueInBNB.mul(priceOfBNB()).div(1e18);\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210519-pancakebunny---price-oracle-manipulation"
  },
  "BEARNDAO": {
    "type": "Business Logic Flaw",
    "date": "2023-12-05",
    "rootCause": "The attack exploited a bug in ConvertDustToEarned() and used a sandwich attack.\n\nRelied on the current balance of the `wantToken` token. But the strategy contract is not supposed to hold a huge amount of dust tokens.\n\nThe attacker\u00a0[**first manipulated**](https://explorer.phalcon.xyz/tx/bsc/0x51913be3f31d5ddbfc77da789e5f9653ed6b219a52772309802226445a1edd5f)\u00a0the ALPACA/WBNB pool through large-valued swaps and invoked a call to the convertDustToEarned function, thereby artificially inflating the swap ratio of the tokens.\n\nThe reverse swap allowed the attacker to perform a sandwich attack, letting them take away approximately $768,358 worth of assets as profits.\n\nVulnerable code snippet:\n\n```jsx\n    function convertDustToEarned() public whenNotPaused {\n        require(isAutoComp, \"!isAutoComp\");\n        // Converts dust tokens into earned tokens, which will be reinvested on the next earn().\n\n        // Converts token0 dust (if any) to earned tokens\n        uint256 wantAmt = IERC20(wantAddress).balanceOf(address(this));// **<--vulnerable point** \n        if (wantAddress != earnedAddress && wantAmt > 0) {\n            IERC20(wantAddress).safeIncreaseAllowance(uniRouterAddress, wantAmt);\n\n            // Swap all dust tokens to earned tokens\n            IPancakeRouter02(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(wantAmt, 0, paths[wantAddress][earnedAddress], address(this), now + 60);\n            emit ConvertDustToEarned(wantAddress, earnedAddress, wantAmt);\n        }\n    }\n```\n\nAttack tx:\n\n[https://www.oklink.com/es-la/bsc/tx/0x51913be3f31d5ddbfc77da789e5f9653ed6b219a52772309802226445a1edd5f](https://www.oklink.com/es-la/bsc/tx/0x51913be3f31d5ddbfc77da789e5f9653ed6b219a52772309802226445a1edd5f)\n\n[https://explorer.phalcon.xyz/tx/bsc/0x51913be3f31d5ddbfc77da789e5f9653ed6b219a52772309802226445a1edd5f](https://explorer.phalcon.xyz/tx/bsc/0x51913be3f31d5ddbfc77da789e5f9653ed6b219a52772309802226445a1edd5f)\n\nAnalysis:\n\n[https://twitter.com/AnciliaInc/status/1732159377749180646](https://twitter.com/AnciliaInc/status/1732159377749180646)\n\n\n\nThe stolen funds have been transferred to the following addresses.\n\n- 0x42df55549558b6119fe9c628b856dec6b86ed4c5\n- 0x4d1f328e0dc4d3e8b7a81184cb89edc4cb7cd63a\n\n\n\nREF Link:\n\n[https://neptunemutual.com/blog/how-was-bearn-dao-exploited/](https://neptunemutual.com/blog/how-was-bearn-dao-exploited/)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Business_Screenshot_2024-06-21_at_10.34.59_AM.png"
    ],
    "Lost": "$769k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/BEARNDAO_exp.sol"
  },
  "Uranium": {
    "type": "Dex/AMM, ERC20, Miscalculation",
    "date": "2021-04-28",
    "rootCause": "Incorrect calculation\n\nVulnerable code snippet: same Nimbus\u2019s issue\n\n[https://bscscan.com/address/0xA943eA143cd7E79806d670f4a7cf08F8922a454F#code#F3#L180](https://bscscan.com/address/0xA943eA143cd7E79806d670f4a7cf08F8922a454F#code#F3#L180)\n\ninconsistent value in the code, 10000 vs 1000\n\n```solidity\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UraniumSwap: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UraniumSwap: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UraniumSwap: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUraniumCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UraniumSwap: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(16)); **//vulnerable point**\n        uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(16)); **//vulnerable point**\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UraniumSwap: K'); //vulnerable\n        }\n```",
    "images": [],
    "Lost": "$50 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210428-uranium---miscalculation"
  },
  "bZxProtocol": {
    "type": "Inflation",
    "date": "2023-12-02",
    "rootCause": "Empty pool forked bug.\n\nBy depositing a small amount of tokens to obtain pool tokens,we can front-run other depositors' transactions and inflate the price of pool tokens through a substantial \"donation.\"\nConsequently, the attacker can withdraw a greater quantity of tokens than they initially possessed.\n\nVulnerable code snippet:\n\n [https://etherscan.io/address/0x7f3fe9d492a9a60aebb06d82cba23c6f32cad10b#code](https://etherscan.io/address/0x7f3fe9d492a9a60aebb06d82cba23c6f32cad10b#code)\n\nAttack tx:\n\n[https://etherscan.io/tx/0x0fc5c0d41e5506fdb9434fab4815a4ff671afc834e47a533b3bed7182ece73b0](https://etherscan.io/tx/0x0fc5c0d41e5506fdb9434fab4815a4ff671afc834e47a533b3bed7182ece73b0)\n\n[https://etherscan.io/tx/0xb072f2e88058c147d8ff643694b43a42e36525b7173ce1daf76e6c06170b0e77](https://etherscan.io/tx/0xb072f2e88058c147d8ff643694b43a42e36525b7173ce1daf76e6c06170b0e77)\n\nAnalysis:\n\n\n\nREF Link:\n\n[https://x.com/kankodu/status/1771229163942474096](https://x.com/kankodu/status/1771229163942474096)\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$208k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/bZx_exp.sol"
  },
  "DODO": {
    "type": "Access Control, Dex/AMM",
    "date": "2021-03-08",
    "rootCause": "Incorrect access control\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x051ebd717311350f1684f89335bed4abd083a2b6#code#L1419](https://etherscan.io/address/0x051ebd717311350f1684f89335bed4abd083a2b6#code#L1419)\n\nThe init() function in the pool creation contract could be called multiple times, leading to repeated initializations. The attackers took advantage of this and borrowed out the tokens in the liquidity pools using flash loans. The pool contract was then initialized again and counterfeit tokens created by the attackers were returned in lieu of the original tokens, bypassing the flash loan return check logic.\n\n```solidity\nfunction init(   \n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external { **//vulnerable point**\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        require(i > 0 && i <= 10**36);\n        _I_ = i;\n\n        require(k <= 10**18);\n        _K_ = k;\n\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _MAINTAINER_ = maintainer;\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n\n        string memory connect = \"_\";\n        string memory suffix = \"DLP\";\n\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\n        symbol = \"DLP\";\n        decimals = _BASE_TOKEN_.decimals();\n\n        // ============================== Permit ====================================\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        // ==========================================================================\n    }\n```",
    "images": [],
    "Lost": "$700,000",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20210308-dodo---flashloan-attack"
  },
  "Cover Protocol": {
    "type": "Miscalculation",
    "date": "2020-12-29",
    "rootCause": "Incorrect calculation via cached data.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xe0b94a7bb45dd905c79bb1992c9879f40f1caed5#code#F1#L115](https://etherscan.io/address/0xe0b94a7bb45dd905c79bb1992c9879f40f1caed5#code#F1#L115)\n\npool data in storage but forgets to update the cached data. The outdated cached data is later used in calculations and that enables the hack.\n\n```solidity\nfunction deposit(address _lpToken, uint256 _amount) external override {\n    require(block.timestamp >= START_TIME , \"Blacksmith: not started\");\n    require(_amount > 0, \"Blacksmith: amount is 0\");\n    Pool memory pool = pools[_lpToken];  //vulnerable point, data cached.\n    require(pool.lastUpdatedAt > 0, \"Blacksmith: pool does not exists\");\n    require(IERC20(_lpToken).balanceOf(msg.sender) >= _amount, \"Blacksmith: insufficient balance\");\n    updatePool(_lpToken);\n\n    Miner storage miner = miners[_lpToken][msg.sender];\n    BonusToken memory bonusToken = bonusTokens[_lpToken];\n    _claimCoverRewards(pool, miner); //old cached data used\n    _claimBonus(bonusToken, miner);\n\n    miner.amount = miner.amount.add(_amount);\n    // update writeoff to match current acc rewards/bonus per token\n    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER);  **//vulnerable point,** old cached data used\n    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER);  **//vulnerable point,** old cached data used\n\n    IERC20(_lpToken).safeTransferFrom(msg.sender, address(this), _amount);\n    emit Deposit(msg.sender, _lpToken, _amount);\n  }\n\n/// @notice update pool's rewards & bonus per staked token till current block timestamp\n  function updatePool(address _lpToken) public override {\n    Pool storage pool = pools[_lpToken]; // storage\n    if (block.timestamp <= pool.lastUpdatedAt) return;\n    uint256 lpTotal = IERC20(_lpToken).balanceOf(address(this));\n    if (lpTotal == 0) {\n      pool.lastUpdatedAt = block.timestamp;\n      return;\n    }\n    // update COVER rewards for pool\n    uint256 coverRewards = _calculateCoverRewardsForPeriod(pool);\n    pool.accRewardsPerToken = pool.accRewardsPerToken.add(coverRewards.div(lpTotal));\n    pool.lastUpdatedAt = block.timestamp;\n    // update bonus token rewards if exist for pool\n    BonusToken storage bonusToken = bonusTokens[_lpToken]; // storage\n    if (bonusToken.lastUpdatedAt < bonusToken.endTime && bonusToken.startTime < block.timestamp) {\n      uint256 bonus = _calculateBonusForPeriod(bonusToken);\n      bonusToken.accBonusPerToken = bonusToken.accBonusPerToken.add(bonus.div(lpTotal));\n      bonusToken.lastUpdatedAt = block.timestamp <= bonusToken.endTime ? block.timestamp : bonusToken.endTime;\n    }\n  }\nfunction claimRewards(address _lpToken) public override {\n    updatePool(_lpToken);\n\n    Pool memory pool = pools[_lpToken]; //vulnerable point, data cached.\n    Miner storage miner = miners[_lpToken][msg.sender];\n    BonusToken memory bonusToken = bonusTokens[_lpToken];\n\n    _claimCoverRewards(pool, miner);\n    _claimBonus(bonusToken, miner);\n    // update writeoff to match current acc rewards & bonus per token\n    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER);   **//vulnerable point,** old cached data used\n    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER);   **//vulnerable point,** old cached data used\n  }\n\nfunction _claimCoverRewards(Pool memory pool, Miner memory miner) private nonReentrant {\n    if (miner.amount > 0) {\n      uint256 minedSinceLastUpdate = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER).sub(miner.rewardWriteoff);\n      if (minedSinceLastUpdate > 0) {\n        cover.mint(msg.sender, minedSinceLastUpdate); // mint COVER tokens to miner\n      }\n    }\n  }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20201229-cover-protocol"
  },
  "Pickle Finance": {
    "type": "Insufficient validation, Yield",
    "date": "2020-11-21",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x6847259b2b3a4c17e7c43c54409810af48ba5210#code#F26#L249](https://etherscan.io/address/0x6847259b2b3a4c17e7c43c54409810af48ba5210#code#F26#L249)\n\nit doesn\u2019t check the validity of the Jars. Attacker can create fake token to withdraw all DAIs from StrategyCmpdDaiV2 to Jar.\n\n```solidity\n// Function to swap between jars\n    function swapExactJarForJar(\n        address _fromJar, // From which Jar\n        address _toJar, // To which Jar\n        uint256 _fromJarAmount, // How much jar tokens to swap\n        uint256 _toJarMinAmount, // How much jar tokens you'd like at a minimum\n        address payable[] calldata _targets,\n        bytes[] calldata _data\n    ) external returns (uint256) {\n        require(_targets.length == _data.length, \"!length\");\n\n        // Only return last response\n        for (uint256 i = 0; i < _targets.length; i++) {\n            require(_targets[i] != address(0), \"!converter\");\n            require(approvedJarConverters[_targets[i]], \"!converter\");\n        }\n\n        address _fromJarToken = IJar(_fromJar).token();\n        address _toJarToken = IJar(_toJar).token();\n\n        // Get pTokens from msg.sender\n        IERC20(_fromJar).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _fromJarAmount\n        );\n\n        // Calculate how much underlying\n        // is the amount of pTokens worth\n        uint256 _fromJarUnderlyingAmount = _fromJarAmount\n            .mul(IJar(_fromJar).getRatio())\n            .div(10**uint256(IJar(_fromJar).decimals()));\n\n        // Call 'withdrawForSwap' on Jar's current strategy if Jar\n        // doesn't have enough initial capital.\n        // This has moves the funds from the strategy to the Jar's\n        // 'earnable' amount. Enabling 'free' withdrawals\n        uint256 _fromJarAvailUnderlying = IERC20(_fromJarToken).balanceOf(\n            _fromJar\n        );\n        if (_fromJarAvailUnderlying < _fromJarUnderlyingAmount) {\n            IStrategy(strategies[_fromJarToken]).withdrawForSwap(\n                _fromJarUnderlyingAmount.sub(_fromJarAvailUnderlying)\n            );\n        }\n\n        // Withdraw from Jar\n        // Note: this is free since its still within the \"earnable\" amount\n        //       as we transferred the access\n        IERC20(_fromJar).safeApprove(_fromJar, 0);\n        IERC20(_fromJar).safeApprove(_fromJar, _fromJarAmount);\n        **IJar(_fromJar).withdraw(_fromJarAmount);** //vulnerable point\n\n        // Calculate fee\n        uint256 _fromUnderlyingBalance = IERC20(_fromJarToken).balanceOf(\n            address(this)\n        );\n        uint256 _convenienceFee = _fromUnderlyingBalance.mul(convenienceFee).div(\n            convenienceFeeMax\n        );\n\n        if (_convenienceFee > 1) {\n            IERC20(_fromJarToken).safeTransfer(devfund, _convenienceFee.div(2));\n            IERC20(_fromJarToken).safeTransfer(treasury, _convenienceFee.div(2));\n        }\n\n        // Executes sequence of logic\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _execute(_targets[i], _data[i]);\n        }\n\n        // Deposit into new Jar\n        uint256 _toBal = IERC20(_toJarToken).balanceOf(address(this));\n        IERC20(_toJarToken).safeApprove(_toJar, 0);\n        IERC20(_toJarToken).safeApprove(_toJar, _toBal);\n        IJar(_toJar).deposit(_toBal);\n\n        // Send Jar Tokens to user\n        uint256 _toJarBal = IJar(_toJar).balanceOf(address(this));\n        if (_toJarBal < _toJarMinAmount) {\n            revert(\"!min-jar-amount\");\n        }\n\n        IJar(_toJar).transfer(msg.sender, _toJarBal);\n\n        return _toJarBal;\n    }\n```",
    "images": [],
    "Lost": "$20 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20201121-pickle-finance"
  },
  "Harvest Finance": {
    "type": "Economic, Flashloans, Yield",
    "date": "2020-10-26",
    "rootCause": "Economic issue\n\ncheck [https://rekt.news/harvest-finance-rekt/](https://rekt.news/harvest-finance-rekt/)\n\nVulnerable code snippet:\n\n```solidity\nfunction _deposit(uint256 amount, address sender, address beneficiary) internal {\n    require(amount > 0, \"Cannot deposit 0\");\n    require(beneficiary != address(0), \"holder must be defined\");\n\n    if (address(strategy()) != address(0)) {\n      require(IStrategy(strategy()).depositArbCheck(), \"Too much arb\");\n    }\n\n    uint256 toMint = totalSupply() == 0\n        ? amount\n        : amount.mul(totalSupply()).div(underlyingBalanceWithInvestment());\n    _mint(beneficiary, toMint);\n\n    IERC20(underlying()).safeTransferFrom(sender, address(this), amount);\n\n    // update the contribution amount for the beneficiary\n    emit Deposit(beneficiary, amount);\n  }\n/* Returns the current underlying (e.g., DAI's) balance together with\n   * the invested amount (if DAI is invested elsewhere by the strategy).\n  */\n  function underlyingBalanceWithInvestment() view public returns (uint256) {\n    if (address(strategy()) == address(0)) {\n      // initial state, when not set\n      return underlyingBalanceInVault();\n    }\n    return underlyingBalanceInVault().add(IStrategy(strategy()).investedUnderlyingBalance());\n  }\n```",
    "images": [],
    "Lost": "$33.8 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20201026-harvest-finance---flashloan-attack"
  },
  "Balancer": {
    "type": "",
    "date": "2023-08-27",
    "rootCause": "The attack exploited a rounding down issue in the linear pools, letting the attacker manipulate the token exchange rate in the composable pool. By reducing BPT supply to zero and then performing a reverse swap, they achieved a nearly 1:1 exchange rate, which was lower than the linear pool\u2019s rate\n\nVulnerable Code Snippet:\n\n```solidity\nfunction onSwap(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) public view override onlyVault(request.poolId) whenNotPaused returns (uint256) {\n        // In most Pools, swaps involve exchanging one token held by the Pool for another. In this case however, since\n        // one of the three tokens is the BPT itself, a swap might also be a join (main/wrapped for BPT) or an exit\n        // (BPT for main/wrapped).\n        // All three swap types (swaps, joins and exits) are fully disabled if the emergency pause is enabled. Under\n        // these circumstances, the Pool should be exited using the regular Vault.exitPool function.\n\n        // Sanity check: this is not entirely necessary as the Vault's interface enforces the indices to be valid, but\n        // the check is cheap to perform.\n        _require(indexIn < _TOTAL_TOKENS && indexOut < _TOTAL_TOKENS, Errors.OUT_OF_BOUNDS);\n\n        // Note that we already know the indices of the main token, wrapped token and BPT, so there is no need to pass\n        // these indices to the inner functions.\n\n        // Upscale balances by the scaling factors (taking into account the wrapped token rate)\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 lowerTarget, uint256 upperTarget) = getTargets();\n        LinearMath.Params memory params = LinearMath.Params({\n            fee: getSwapFeePercentage(),\n            lowerTarget: lowerTarget,\n            upperTarget: upperTarget\n        });\n\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\n            // The amount given is for token in, the amount calculated is for token out\n            request.amount = _upscale(request.amount, scalingFactors[indexIn]);\n            uint256 amountOut = _onSwapGivenIn(request, balances, params);\n\n            // amountOut tokens are exiting the Pool, so we round down.\n            return _downscaleDown(amountOut, scalingFactors[indexOut]);\n        } else {\n            // The amount given is for token out, the amount calculated is for token in\n            request.amount = _upscale(request.amount, scalingFactors[indexOut]);\n            uint256 amountIn = _onSwapGivenOut(request, balances, params);\n\n            // amountIn tokens are entering the Pool, so we round up.\n            return _downscaleUp(amountIn, scalingFactors[indexIn]);\n        }\n    }\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0x2a027c8b915c3737942f512fc5d26fd15752d0332353b3059de771a35a606c2d](https://etherscan.io/tx/0x2a027c8b915c3737942f512fc5d26fd15752d0332353b3059de771a35a606c2d)\n\nAnalysis:\n\n[https://slowmist.medium.com/review-and-recommendations-of-balancer-incident-d2b31b5bd863](https://slowmist.medium.com/review-and-recommendations-of-balancer-incident-d2b31b5bd863)\n\n[https://medium.com/balancer-protocol/rate-manipulation-in-balancer-boosted-pools-technical-postmortem-53db4b642492](https://medium.com/balancer-protocol/rate-manipulation-in-balancer-boosted-pools-technical-postmortem-53db4b642492)\n\n[https://blocksecteam.medium.com/yet-another-risk-posed-by-precision-loss-an-in-depth-analysis-of-the-recent-balancer-incident-fad93a3c75d4](https://blocksecteam.medium.com/yet-another-risk-posed-by-precision-loss-an-in-depth-analysis-of-the-recent-balancer-incident-fad93a3c75d4)",
    "images": [],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Balancer_exp.sol"
  },
  "Bancor Protocol": {
    "type": "Access Control, Dex/AMM",
    "date": "2020-06-18",
    "rootCause": "incorrect access control\n\nVulnerable code snippet: \n\n[https://etherscan.io/address/0x5f58058c0ec971492166763c8c22632b583f667f#code#L551](https://etherscan.io/address/0x5f58058c0ec971492166763c8c22632b583f667f#code#L551)\n\n```solidity\nfunction safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) public { **//vulnerable point**\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }\n```\n\nfixed\n\n```solidity\nfunction safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n    }\n```",
    "images": [],
    "Lost": "$545,000",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20200618-bancor-protocol---access-control"
  },
  "UN": {
    "type": "Flashloans",
    "date": "2023-06-06",
    "rootCause": "The vulnerable provided a gateway for the attacker to manipulate the token's value\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\n[https://bscscan.com/tx/0xff5515268d53df41d407036f547b206e288b226989da496fda367bfeb31c5b8b](https://bscscan.com/tx/0xff5515268d53df41d407036f547b206e288b226989da496fda367bfeb31c5b8b)\n\nAnalysis:\n\nhttps://metatrust.io/blogs/post/unraveling-the-un-attack-a-flash-loan-exploits-flaw-in-token-contract",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$26k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/UN_exp.sol"
  },
  "Beauty Chain": {
    "type": "ERC20, Under/Overflow",
    "date": "2018-04-22",
    "rootCause": "Arithmetic Overflow\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code#L259](https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code#L259)\n\n```solidity\nfunction batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    **uint256 amount = uint256(cnt) * _value;** **//vulnerable point**\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n```",
    "images": [],
    "Lost": "$900 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20180422-beauty-chain---integer-overflow"
  },
  "Parity": {
    "type": "Access Control, wallet",
    "date": "2017-11-06",
    "rootCause": "Incorrect access control\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code#L223](https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code#L223)\n\n```solidity\n// constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized { **//vulnerable point**\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n```",
    "images": [],
    "Lost": "514k ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20171106-parity---accidentally-killed-it"
  },
  "DFS": {
    "type": "Flashloans, Insufficient validation, skim",
    "date": "2022-12-30",
    "rootCause": " \n\nPrice Manipulation.\n\nWhen the receiving address of the dFS token transfer is the pair, a certain percentage of the tokens at this address will be additionally destroyed, and the attacker manipulates the price by invoking the transfer() and skim() function to burn the dfs tokens in the pair.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if (from == address(this) || to == address(this)) {\n            return;\n        }\n        uint256 rate = 5;\n        uint256 fee = 0;\n        if (to == address(pair) || from == address(pair) ) { \n            if (takeFee && !exclusiveFromFee[from]) {\n                fee = amount.mul(rate).div(1000);\n                _balance[from] = _balance[from].sub(amount).sub(fee);\n                _balance[destroyAddress] = _balance[destroyAddress].add(fee);\n                emit Transfer(from, destroyAddress, fee);\n            }\n        } else {\n            _balance[from] = _balance[from].sub(amount);\n        }\n        if (_balance[from] == 0 && holders.length != 0) {\n            holders[holdersIndex[from]] = holders[holders.length-1];\n            holdersIndex[holders[holders.length-1]] = holdersIndex[from];\n            holders.pop();\n            includeHolders[from] = false;\n        }\n        _balance[to] = _balance[to].add(amount);\n        if (!includeHolders[to]) {\n            holdersIndex[to] = holders.length;\n            holders.push(to);\n            includeHolders[to] = true;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n```\n\n**Attack tx:** \n\n[https://bscscan.com/tx/0xcddcb447d64c2ce4b3ac5ebaa6d42e26d3ed0ff3831c08923c53ea998f598a7c](https://bscscan.com/tx/0xcddcb447d64c2ce4b3ac5ebaa6d42e26d3ed0ff3831c08923c53ea998f598a7c)\n\n**Analysis:**\n\n[https://twitter.com/CertiKAlert/status/1608788290785665024](https://twitter.com/CertiKAlert/status/1608788290785665024)",
    "images": [],
    "Lost": "$1450",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DFS_exp.sol"
  },
  "JAY": {
    "type": "Insufficient validation, Reentrancy",
    "date": "2022-12-29",
    "rootCause": " \n\nReentrancy.\n\nThe attacker exploits this vulnerability to reenter the JAY contract. Specifically, the attacker first borrows 72.5 ETH for flash loan and uses 22 ETH to buy JAY token. Then he uses another 50.5 ETH to call the buyJay function, passing the fake ERC-721 token.\n\nIn the transferFrom function of the fake ERC-721 token, the attacker reenters the JAY contract by calling the sell function, selling all the JAY token. As the Ether balance has been increased at the start of the buyJay function, the JAY token price is manipulated.\n\nThe attacker repeated the procedure twice in a single transaction, with a total profit of 15.32 Ether.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction buyJay(\n        address[] calldata erc721TokenAddress,\n        uint256[] calldata erc721Ids,\n        address[] calldata erc1155TokenAddress,\n        uint256[] calldata erc1155Ids,\n        uint256[] calldata erc1155Amounts\n    ) public payable {\n        require(start, \"Not started!\");\n        uint256 total = erc721TokenAddress.length;\n        if (total != 0) buyJayWithERC721(erc721TokenAddress, erc721Ids);\n\n        if (erc1155TokenAddress.length != 0)\n            total = total.add(\n                buyJayWithERC1155(\n                    erc1155TokenAddress,\n                    erc1155Ids,\n                    erc1155Amounts\n                )\n            );\n\n        if (total >= 100)\n            require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n        else\n            require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n\n        _mint(msg.sender, ETHtoJAY(msg.value).mul(97).div(100));\n\n        (bool success, ) = dev.call{value: msg.value.div(34)}(\"\");\n        require(success, \"ETH Transfer failed.\");\n\n        nftsSold += total;\n\n        emit Price(block.timestamp, JAYtoETH(1 * 10**18));\n    }\n\nfunction JAYtoETH(uint256 value) public view returns (uint256) {\n        return (value * address(this).balance).div(totalSupply());\n    }\n\n```\n\n**Attack tx:** \n\n[https://etherscan.io/tx/0xd4fafa1261f6e4f9c8543228a67caf9d02811e4ad3058a2714323964a8db61f6](https://etherscan.io/tx/0xd4fafa1261f6e4f9c8543228a67caf9d02811e4ad3058a2714323964a8db61f6)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1608372475225866240](https://twitter.com/BlockSecTeam/status/1608372475225866240)",
    "images": [],
    "Lost": "15.32 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/JAY_exp.sol"
  },
  "Rubic": {
    "type": "Arbitrary call, Dex/AMM",
    "date": "2022-12-25",
    "rootCause": "  \n\nArbitrary External Call\n\nThe attacker abused that USDC had been added as a router (by the admin), leading to an arbitrary function call with USDC contract. Then the attacker invoked transferFrom to steal the victim's USDC.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction routerCallNative(BaseCrossChainParams calldata _params, bytes calldata _data)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        eventEmitter(_params)\n    {\n        if (!availableRouters.contains(_params.router)) {\n            revert RouterNotAvailable();\n        }\n\n        IntegratorFeeInfo memory _info = integratorToFeeInfo[_params.integrator];\n\n        uint256 _amountIn = accrueTokenFees(\n            _params.integrator,\n            _info,\n            accrueFixedCryptoFee(_params.integrator, _info),\n            0,\n            address(0)\n        );\n\n        AddressUpgradeable.functionCallWithValue(_params.router, _data, _amountIn);\n    }\n\n```\n\n**Attack tx:** \n\n[https://explorer.phalcon.xyz/tx/eth/0x9a97d85642f956ad7a6b852cf7bed6f9669e2c2815f3279855acf7f1328e7d46](https://explorer.phalcon.xyz/tx/eth/0x9a97d85642f956ad7a6b852cf7bed6f9669e2c2815f3279855acf7f1328e7d46)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1606993118901198849](https://twitter.com/BlockSecTeam/status/1606993118901198849)\n\n[https://twitter.com/peckshield/status/1606937055761952770](https://twitter.com/peckshield/status/1606937055761952770)",
    "images": [],
    "Lost": "$1.5M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Rubic_exp.sol"
  },
  "Defrost": {
    "type": "Dex/AMM, Reentrancy",
    "date": "2022-12-23",
    "rootCause": " \n\nReentrancy.\n\nLack of reentrancy lock for the flashloan()/deposit() functions, which was used by the hacker to manipulate the share price of LSWUSDC\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual returns (bool) {\n        require(token == address(asset),\"flash borrow token Error!\");\n        uint256 fee = flashFee(token, amount);\n        onWithdraw(address(receiver),amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"invalid return value\"\n        );\n        onDeposit(address(receiver),amount + fee,0);\n        emit FlashLoan(msg.sender,address(receiver),token,amount);\n        return true;\n    }\nfunction deposit(uint256 _amount, address receiver) external returns (uint256){\n        uint256 amount = _deposit(msg.sender,_amount,receiver);\n        emit Deposit(msg.sender,receiver,_amount,amount);\n        return amount;\n    }\n```\n\n**Attack tx:** \n\n[https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d](https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d)\n\n**Analysis:**\n\n[https://twitter.com/PeckShieldAlert/status/1606276020276891650](https://twitter.com/PeckShieldAlert/status/1606276020276891650)",
    "images": [],
    "Lost": "$170k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Defrost_exp.sol"
  },
  "Nmbplatform": {
    "type": "Flashloans, Price Manipulation, claimTokens",
    "date": "2022-12-14",
    "rootCause": " \n\nStaking reward is based on spot price.\n\nThe price feed of NIMB and GNIMB (the reward token) will be needed when calculating the staking reward. However, the price of NIMB is calculated based on the manipulated NIMB - NBU_WBNB pair.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction getReward() public override nonReentrant whenNotPaused {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            for (uint256 i = 0; i < stakeNonces[msg.sender]; i++) {\n                stakeNonceInfos[msg.sender][i].stakeTime = block.timestamp;\n            }\n        rewardsPaymentToken.safeTransfer(msg.sender, reward);\n        emit RewardPaid(msg.sender, address(rewardsPaymentToken), reward);\n\n        }\n    }\nfunction earnedByNonce(address account, uint256 nonce) public view returns (uint256) {\n        uint256 amount = stakeNonceInfos[account][nonce].rewardsTokenAmount * \n            (block.timestamp - stakeNonceInfos[account][nonce].stakeTime) *\n             stakeNonceInfos[account][nonce].rewardRate / (100 * rewardDuration);\n        return getTokenAmountForToken(address(rewardsToken), address(rewardsPaymentToken), amount);\n    }\nfunction getTokenAmountForToken(address tokenSrc, address tokenDest, uint tokenAmount) public view returns (uint) { \n        if (tokenSrc == tokenDest) return tokenAmount;\n        if (usePriceFeeds && address(priceFeed) != address(0)) {\n            (uint256 rate, uint256 precision) = priceFeed.queryRate(tokenSrc, tokenDest);\n            return tokenAmount * rate / precision;\n        } \n        address[] memory path = new address[](2);\n        path[0] = tokenSrc;\n        path[1] = tokenDest;\n        return swapRouter.getAmountsOut(tokenAmount, path)[1];\n    }\n```\n\n**Attack tx:** \n\n[https://bscscan.com/tx/0x7d2d8d2cda2d81529e0e0af90c4bfb39b6e74fa363c60b031d719dd9d153b012](https://bscscan.com/tx/0x7d2d8d2cda2d81529e0e0af90c4bfb39b6e74fa363c60b031d719dd9d153b012)\n[https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1](https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1602881707958407168](https://twitter.com/BlockSecTeam/status/1602881707958407168)\n\n[https://twitter.com/BlockSecTeam/status/1602881707958407168](https://twitter.com/BlockSecTeam/status/1602881707958407168)",
    "images": [],
    "Lost": "$76k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Nmbplatform_exp.sol"
  },
  "ElasticSwap": {
    "type": "Incorrect logic",
    "date": "2022-12-13",
    "rootCause": " \n\nBusiness Logic Flaw.\n\nElasticSwap is an AMM focused on elastic supply tokens. \nAn elastic supply (or rebase) token works in a way that the circulating supply expands or contracts due to changes in token price. \nElasticSwap adapts to the elastic supply changes without the need for someone to call a function on the pool itself after a change (rebase) happens.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction addLiquidity(uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _liquidityTokenRecipient){//vulnerable point\n\tMathLib.TokenQtys memory tokenQtys = MathLib.calculateAddLiquidityQuantities(, , , , IERC20(baseToken).balanceOf(address(this)), totalSupply, internalBalances);\n\tinternalBalances.kLast = internalBalances.baseTokenReserveQty * internalBalances.quoteTokenReserveQty;\n}\n\nfunction removeLiquidity(uint256 _liquidityTokenQty, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _tokenRecipient){//vulnerable point\n\tuint256 baseTokenReserveQty  = IERC20(baseToken).balanceOf(address(this));\n\tuint256 quoteTokenReserveQty = IERC20(quoteToken).balanceOf(address(this));\n\t\n\tuint256 baseTokenQtyToReturn  = (_liquidityTokenQty * baseTokenReserveQty) / totalSupplyOfLiquidityTokens;\n\tuint256 quoteTokenQtyToReturn = (_liquidityTokenQty * quoteTokenReserveQty) / totalSupplyOfLiquidityTokens;\n\n\tuint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty;\n\tuint256 baseTokenQtyToRemoveFromInternalAccounting = (_liquidityTokenQty * internalBaseTokenReserveQty) / totalSupplyOfLiquidityTokens;\n\t\n\tinternalBalances.baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;\n\t\n\tinternalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn;  // @audit: doesn't sync the reserves (as in UniswapPair.burn())\n\t\n  IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n  IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n}\n```\n\n**Attack tx:** \n\n[https://explorer.phalcon.xyz/tx/eth/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f](https://explorer.phalcon.xyz/tx/eth/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f)\n\n**Analysis:**\n\n[https://quillaudits.medium.com/decoding-elastic-swaps-850k-exploit-quillaudits-9ceb7fcd8d1a](https://quillaudits.medium.com/decoding-elastic-swaps-850k-exploit-quillaudits-9ceb7fcd8d1a)",
    "images": [],
    "Lost": "$845k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ElasticSwap_exp.sol"
  },
  "BGLD (Deflationary token)": {
    "type": "Deflationary token, Flashloans, Price Manipulation",
    "date": "2022-12-12",
    "rootCause": " \n\nDeflationary token abuse via skim.\n\nThe exploiter reduces the $BGLD reserve in the pair to a deficient level and then swaps out another token (WBNB).\n\n**Vulnerable code snippet:**\n\n[https://www.bscscan.com/address/0xc2319e87280c64e2557a51cb324713dd8d1410a3#code#L636](https://www.bscscan.com/address/0xc2319e87280c64e2557a51cb324713dd8d1410a3#code#L636)\n\n```jsx\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        uint256 onePercent = _findOnePercent(amount);\n        uint256 burnFee = onePercent.mul(2);\n        uint256 miningFee = onePercent.mul(4);\n        uint256 liquidityFee = onePercent.mul(4);\n\n        if (!_isExcludedFromFee[sender]) {\n            require(\n                _balances[sender] >\n                    amount.add(miningFee).add(liquidityFee).add(burnFee), //vulnerable point\n                \"BEP20: transfer amount + fees exceeds balance\"\n            );\n        }\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0xea108fe94bfc9a71bb3e4dee4a1b0fd47572e6ad6aba8b2155ac44861be628ae](https://explorer.phalcon.xyz/tx/bsc/0xea108fe94bfc9a71bb3e4dee4a1b0fd47572e6ad6aba8b2155ac44861be628ae)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1602335214356660225](https://twitter.com/BlockSecTeam/status/1602335214356660225)",
    "images": [],
    "Lost": "$18k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BGLD_exp.sol"
  },
  "Lodestar": {
    "type": "Flashloans, Incorrect logic, Price Manipulation",
    "date": "2022-12-11",
    "rootCause": " \n\nFlashLoan price manipulation - Incorrect logic in GLPOracle.\n\nThe root cause is attributed to the construction of the Lodestar GLPOracle and how it obtained the price of plvGLP tokens. The GLPOracle failed to consider the impact of a user calling the donate() function on the GlpDepositor contract. This action inflated the assets of the GlpDepositor contract, consequently affecting the oracle-delivered price of the plvGLP token. As a result, the price reported by the GLPOracle became inaccurate due to the improper handling of the donation mechanism, leading to the vulnerability exploited by malicious users.\n\n**Vulnerable code snippet:**\n\n[https://arbiscan.io/address/0xba46f854a5b099fcea178c6e7ed047baffece5ac#code#F1#L65](https://arbiscan.io/address/0xba46f854a5b099fcea178c6e7ed047baffece5ac#code#F1#L65)\n\n```jsx\nfunction getPlvGLPPrice() public view returns (uint256) {\n        uint256 exchangeRate = getPlutusExchangeRate();\n\n        uint256 glpPrice = getGLPPrice();\n\n        uint256 price = (exchangeRate * glpPrice) / BASE;\n\n        return price;\n    }\nfunction getPlutusExchangeRate() public view returns (uint256) {\n        //retrieve total assets from plvGLP contract\n        uint256 totalAssets = plvGLPInterface(plvGLP).totalAssets();\n\n        //retrieve total supply from plvGLP contract\n        uint256 totalSupply = EIP20Interface(plvGLP).totalSupply();\n\n        //plvGLP/GLP Exchange Rate = Total Assets / Total Supply\n        uint256 exchangeRate = (totalAssets * BASE) / totalSupply;\n\n        return exchangeRate;\n    }\n```\n\n[https://arbiscan.io/address/0x13F0D29b5B83654A200E4540066713d50547606E#code#F1#L106](https://arbiscan.io/address/0x13F0D29b5B83654A200E4540066713d50547606E#code#F1#L106)\n\n```jsx\nfunction donate(uint256 _assets) external {\n    sGLP.safeTransferFrom(msg.sender, staker, _assets);\n    ITokenMinter(minter).mint(vault, _assets);\n  }\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/arbitrum/0xc523c6307b025ebd9aef155ba792d1ba18d5d83f97c7a846f267d3d9a3004e8c](https://explorer.phalcon.xyz/tx/arbitrum/0xc523c6307b025ebd9aef155ba792d1ba18d5d83f97c7a846f267d3d9a3004e8c)\n\n**Analysis:**\n\n[https://twitter.com/SolidityFinance/status/1601684150456438784](https://twitter.com/SolidityFinance/status/1601684150456438784)\n\n[https://blog.lodestarfinance.io/post-mortem-summary-13f5fe0bb336](https://blog.lodestarfinance.io/post-mortem-summary-13f5fe0bb336)",
    "images": [],
    "Lost": "$4M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Lodestar_exp.sol"
  },
  "MEVbot": {
    "type": "Access Control",
    "date": "2023-11-07",
    "rootCause": "- The function `0xf6ebebbb` has no access control, and it could be called by anyone to perform swap in `Curve` pool.\n- The attacker could use the funds in the MEV to pump the price of tokens like `WBTC`  to gain profits for his own token.\n\nAttack Path:\n\n(from blocksec)\n\n\n\nAttack tx:\n\nhttps://explorer.phalcon.xyz/tx/eth/0xbc08860cd0a08289c41033bdc84b2bb2b0c54a51ceae59620ed9904384287a38\n\nAnalysis:\n\n[https://twitter.com/BlockSecTeam/status/1722101942061601052](https://twitter.com/BlockSecTeam/status/1722101942061601052)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/bot_exp.sol"
  },
  "MU&MUG": {
    "type": "Flashloans, Price Manipulation",
    "date": "2022-12-10",
    "rootCause": "\n\nFlashLoan price manipulation.\n\n**Vulnerable code snippet:**\n\n[https://snowtrace.io/address/0x4aa679402c6afce1e0f7eb99ca4f09a30ce228ab#code#F9#L167](https://snowtrace.io/address/0x4aa679402c6afce1e0f7eb99ca4f09a30ce228ab#code#F9#L167)\n\n```jsx\nfunction mu_bond(address stable, uint256 amount) public nonReentrant { **//vulnerable point**\n        require(is_approved_stable_coin(stable) ,\"Only accepting approved stable coins for bonding\");\n        IERC20 _stable = IERC20(stable);\n        Token token = Token(stable);\n        uint8 _decimals = token.decimals();\n        uint256 _adjusted_amount;\n        if(18 - _decimals == 0)\n            _adjusted_amount = amount;\n        else {\n            _adjusted_amount = (amount/(10**(18-_decimals)));\n        }\n        require(_stable.balanceOf(msg.sender) >= _adjusted_amount, \"You don't have enough of that token to bond that amount\");\n        (uint256 mu_coin_swap_amount, uint256 mu_coin_amount) = _mu_bond_quote(amount);\n        require(IERC20(_MuCoin).balanceOf(address(this)) >= mu_coin_amount, \"This contract does not have enough Mu Coin\");\n        _stable.transferFrom(msg.sender, address(this), _adjusted_amount);\n        IERC20(_MuCoin).transfer(msg.sender, mu_coin_amount);\n        MuMoneyMinter(_MuMoney).mint(address(this), amount);    \n    }\n\nfunction mu_gold_bond(address stable, uint256 amount) public nonReentrant{ **//vulnerable point**\n        require(is_approved_stable_coin(stable) ,\"Only accepting approved stable coins for bonding\");\n        \n        IERC20 _stable = IERC20(stable);\n        Token token = Token(stable);\n        uint8 _decimals = token.decimals();\n        uint256 _adjusted_amount;\n        if(18 - _decimals == 0)\n            _adjusted_amount = amount;\n        else {\n            _adjusted_amount = (amount/(10**(18-_decimals)));\n        }\n        require(_stable.balanceOf(msg.sender) >= _adjusted_amount, \"You don't have enough of that token to bond that amount\");\n            (uint256 mu_gold_swap_amount, uint256 mu_gold_bond_amount)  = _get_mug_bond_quote(amount);\n            require(IERC20(_MuGold).balanceOf(address(this)) >= mu_gold_bond_amount, \"This contract does not have enough Mu Coin\");\n            _stable.transferFrom(msg.sender, address(this), _adjusted_amount);\n            IERC20(_MuGold).transfer(msg.sender, mu_gold_bond_amount);\n            MuMoneyMinter(_MuMoney).mint(address(this), amount);\n\n    }\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/avax/0xab39a17cdc200c812ecbb05aead6e6f574712170eafbd73736b053b168555680](https://explorer.phalcon.xyz/tx/avax/0xab39a17cdc200c812ecbb05aead6e6f574712170eafbd73736b053b168555680)\n\n**Analysis:**\n\n[https://docs.mu.money/more-mu-info/mu-hack](https://docs.mu.money/more-mu-info/mu-hack)\n\n[https://www.certik.com/resources/blog/3pdPXDWLvf0wKZ9yy3HeHz-mu-coin-incident-analysis](https://www.certik.com/resources/blog/3pdPXDWLvf0wKZ9yy3HeHz-mu-coin-incident-analysis)",
    "images": [],
    "Lost": "$57k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MUMUG_exp.sol"
  },
  "TIFIToken": {
    "type": "Flashloans, Price Manipulation",
    "date": "2022-12-10",
    "rootCause": " \n\nFlashLoan price manipulation.\n\n**Vulnerable code snippet:**\n\nNot open sourced.\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0x1c5272ce35338c57c6b9ea710a09766a17bbf14b61438940c3072ed49bfec402](https://explorer.phalcon.xyz/tx/bsc/0x1c5272ce35338c57c6b9ea710a09766a17bbf14b61438940c3072ed49bfec402)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1601492605535399936](https://twitter.com/peckshield/status/1601492605535399936)",
    "images": [],
    "Lost": "87 WBNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TIFI_exp.sol"
  },
  "NOVAToken": {
    "type": "Rug-Pull(Protocol Side)",
    "date": "2022-12-09",
    "rootCause": " Malicious Unlimted Minting (Rugged)\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0xb5b27564d05db32cf4f25813d35b6e6de9210941#code#L418](https://bscscan.com/address/0xb5b27564d05db32cf4f25813d35b6e6de9210941#code#L418)\n\n```jsx\nfunction rewardHolders(uint256 amount) external onlyOwner { //backdoor\n        _balances[owner()] += amount;\n        _totalSupply += amount;\n    }\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0xf743dba906255cf6f75f8243ef8192f2a211aacf03df99322584686b5c445c23](https://explorer.phalcon.xyz/tx/bsc/0xf743dba906255cf6f75f8243ef8192f2a211aacf03df99322584686b5c445c23)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1601168659585454081](https://twitter.com/BeosinAlert/status/1601168659585454081)",
    "images": [],
    "Lost": "330 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NovaExchange_exp.sol"
  },
  "AES (Deflationary token)": {
    "type": "Deflationary token, Flashloans, Incorrect logic",
    "date": "2022-12-07",
    "rootCause": " \n\nManipulate the price via the skim of the BNB-AES pool because AES is a deflationary token.\n\nThe attacker sends the AES to the BNB-AES pool and invokes the skim function repeatedly. In this process, the pool's balance is burned, and the swap fee in the AES contract is increased. After that, the attacker invokes the 'distributeFee' function in the AES contract to transfer the swap fee out of the pair directly, thereby increasing the price of the AES token.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0xddc0cff76bcc0ee14c3e73af630c029fe020f907#code#L1325](https://bscscan.com/address/0xddc0cff76bcc0ee14c3e73af630c029fe020f907#code#L1325)\n\n```jsx\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        if(from == address(this) && to == uniswapV2Pair){\n            super._transfer(from, to, amount);\n        } else {\n            if(automatedMarketMakerPairs[from]) {\n                buyTokenAndFees(from, to, amount);\n            }else if (automatedMarketMakerPairs[to]){\n                sellTokenAndFees(from, to, amount);  //vulnerable point\n            }else {\n                super._transfer(from, to, amount);\n            }\n        }\n\n    }\n\nfunction sellTokenAndFees(\n        address from, \n        address to, \n        uint256 amount\n    ) internal {\n        uint256 burnAmount = amount.mul(3).div(100); \n        uint256 otherAmount = amount.mul(1).div(100); \n\n        amount = amount.sub(burnAmount);\n        swapFeeTotal = swapFeeTotal.add(otherAmount);\n        super._burn(from, burnAmount);\n        super._transfer(from, to, amount);\n    }\nfunction distributeFee() public {\n        uint256 mokeyFeeTotal = swapFeeTotal.mul(2);\n        super._transfer(uniswapV2Pair, monkeyWallet, mokeyFeeTotal);\n        super._transfer(uniswapV2Pair, birdWallet, swapFeeTotal);\n        super._transfer(uniswapV2Pair, foundationWallet, swapFeeTotal);\n        super._transfer(uniswapV2Pair, technologyWallet, swapFeeTotal);\n        super._transfer(uniswapV2Pair, marketingWallet, swapFeeTotal);\n        swapFeeTotal = 0;\n    }\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0xca4d0d24aa448329b7d4eb81be653224a59e7b081fc7a1c9aad59c5a38d0ae19](https://explorer.phalcon.xyz/tx/bsc/0xca4d0d24aa448329b7d4eb81be653224a59e7b081fc7a1c9aad59c5a38d0ae19)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1600442137811689473](https://twitter.com/BlockSecTeam/status/1600442137811689473)\n\n[https://twitter.com/peckshield/status/1600418002163625984](https://twitter.com/peckshield/status/1600418002163625984)",
    "images": [],
    "Lost": "$60k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/AES_exp.sol"
  },
  "RFB": {
    "type": "Bad randomness",
    "date": "2022-12-05",
    "rootCause": " \n\nBad randomness\n\nThe attacker exploits this vulnerability by purchasing RFB tokens only when they are confident of winning. If their attempt fails, the function reverts, resulting in the attacker losing only the gas cost for the transaction. This strategy allows the attacker to optimize their attempts and minimize potential losses, making the system susceptible to manipulation.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x26f1457f067bF26881F311833391b52cA871a4b5#code#L419](https://bscscan.com/address/0x26f1457f067bF26881F311833391b52cA871a4b5#code#L419)\n\n```jsx\nfunction randMod(address buyer,uint256 buyamount) internal  returns(uint){\n\n        uint randnum = uint(keccak256(abi.encodePacked(block.number,block.timestamp,buyer,_balances[pair]))); //vulnerable point\n        uint256 buyBNBamount = buyamount.div(10**_decimals).mul(getPrice());\n        // increase nonce\n        if(randnum%(10000*luckyMultiplier) == 8888 && buyBNBamount > (0.1 ether)){\n            distributor.withdrawDistributor(buyer, 79);\n            distributor.withdrawDistributor(marketingFeeReceiver,9);\n        }else if(randnum%(1000*luckyMultiplier) == 888){\n            if(buyBNBamount.mul(100) > 10 ether){\n                buyBNBamount = 0.1 ether;\n            }\n            try distributor.withdrawPlazz(buyer, buyBNBamount.mul(100).mul(90).div(100)){}catch {}\n            try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(100).mul(10).div(100)){}catch {}\n        }else if(randnum%(100*luckyMultiplier) == 88){\n            if(buyBNBamount.mul(10) > 10 ether){\n                buyBNBamount = 1 ether;\n            }\n            try distributor.withdrawPlazz(buyer, buyBNBamount.mul(10).mul(90).div(100)){}catch {}\n            try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(10).mul(10).div(100)){}catch {}\n        }else if(randnum%(10*luckyMultiplier) == 8){\n            if(buyBNBamount > 10 ether){\n                buyBNBamount = 10 ether;\n            }\n            try distributor.withdrawPlazz(buyer, buyBNBamount.mul(90).div(100)){}catch {}\n            try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(10).div(100)){}catch {}\n        }\n        return randnum;\n    }\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a](https://explorer.phalcon.xyz/tx/bsc/0xcc8fdb3c6af8bb9dfd87e913b743a13bbf138a143c27e0f387037887d28e3c7a)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1599991294947778560](https://twitter.com/BlockSecTeam/status/1599991294947778560)\n\n[https://blog.solidityscan.com/roast-football-hack-analysis-e9316170c443](https://blog.solidityscan.com/roast-football-hack-analysis-e9316170c443)\n\n[https://neptunemutual.com/blog/roast-football-lost-funds-through-exploited-reward-system/](https://neptunemutual.com/blog/roast-football-lost-funds-through-exploited-reward-system/)",
    "images": [],
    "Lost": "12 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RFB_exp.sol"
  },
  "BBOX": {
    "type": "Flashloans, Price Manipulation",
    "date": "2022-12-05",
    "rootCause": " \n\nFlashLoan price manipulation - _transfer() will burn the BBOX token incorrectly.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x5dfc7f3ebbb9cbfe89bc3fb70f750ee229a59f8c#code#L728](https://bscscan.com/address/0x5dfc7f3ebbb9cbfe89bc3fb70f750ee229a59f8c#code#L728)\n\n```jsx\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if( \n            !_isContract(to) \n            && _recommerMapping[to] == address(0) \n            && amount >= recommeCondition){\n            \n            if( ammPairs[from]  ){\n                addRelationEx(holder,to);\n            }else{\n                addRelationEx(from,to);\n            }\n        }\n\n        bool isAddLiquidity;\n        bool isDelLiquidity;\n        ( isAddLiquidity, isDelLiquidity) = _isLiquidity(from,to);\n\n        if( \n            pairAmountChange \n            && !isAddLiquidity\n            && pairAmount > 0 \n            && !ammPairs[from] \n            && pairAmount < balanceOf(uniswapV2Pair)){\n\n            uint v = pairAmount;\n            pairAmount = 0;\n            _tOwned[uniswapV2Pair] =  _tOwned[uniswapV2Pair].sub(v); //vulnerable point\n            _tOwned[address(0)] = _tOwned[address(0)].add(v);\n            emit Transfer(uniswapV2Pair, address(0), v);\n\n            IUniswapV2Pair(uniswapV2Pair).sync();\n        }\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0xac57c78881a7c00dfbac0563e21b5ae3a8e3f9d1b07198a27313722a166cc0a3](https://explorer.phalcon.xyz/tx/bsc/0xac57c78881a7c00dfbac0563e21b5ae3a8e3f9d1b07198a27313722a166cc0a3)\n\n**Analysis:**\n[https://twitter.com/AnciliaInc/status/1599599614490877952](https://twitter.com/AnciliaInc/status/1599599614490877952)",
    "images": [],
    "Lost": "$12k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BBOX_exp.sol"
  },
  "OverNight": {
    "type": "Flashloans",
    "date": "2022-12-02",
    "rootCause": " \n\nFlashloan - force investment\n\n**Vulnerable code snippet:**\n\n[https://snowtrace.io/address/0xed2a7edd7413021d440b09d654f3b87712abab66#code#F24#L731](https://snowtrace.io/address/0xed2a7edd7413021d440b09d654f3b87712abab66#code#F24#L731)\n\n\n\nimage:peckshield\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/avax/0xf10807f9a675dd2db9a45e39f37c68a4116006f9a40e97a68c145e3859557809](https://explorer.phalcon.xyz/tx/avax/0xf10807f9a675dd2db9a45e39f37c68a4116006f9a40e97a68c145e3859557809)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1598704809690877952](https://twitter.com/peckshield/status/1598704809690877952)\n\n[https://twitter.com/overnight_fi/status/1572614168976691200](https://twitter.com/overnight_fi/status/1572614168976691200)\n\n[https://medium.com/coinmonks/psa-in-crypto-transparency-doesnt-necessarily-equal-safety-86b23ae9f471](https://medium.com/coinmonks/psa-in-crypto-transparency-doesnt-necessarily-equal-safety-86b23ae9f471)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$170k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Overnight_exp.sol"
  },
  "APC": {
    "type": "Flashloans, Price Manipulation",
    "date": "2022-12-01",
    "rootCause": " \n\nIncorrect price calculation via getReverse\n\nAPC price relies on the reserve balances of the corresponding PancakeSwap pair. You dump APC token price by flashloan.\n\n**Vulnerable code snippet:**\n\n\n\n\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0xbcaecea2044101c80f186ce5327bec796cd9e054f0c240ddce93e2aead337370](https://explorer.phalcon.xyz/tx/bsc/0xbcaecea2044101c80f186ce5327bec796cd9e054f0c240ddce93e2aead337370)\n\n[https://explorer.phalcon.xyz/tx/bsc/0xf2d4559aeb945fb8e4304da5320ce6a2a96415aa70286715c9fcaf5dbd9d7ed2](https://explorer.phalcon.xyz/tx/bsc/0xf2d4559aeb945fb8e4304da5320ce6a2a96415aa70286715c9fcaf5dbd9d7ed2)\n\n**Analysis:**\n[https://twitter.com/BlockSecTeam/status/1598262002010378241](https://twitter.com/BlockSecTeam/status/1598262002010378241)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$6k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/APC_exp.sol"
  },
  "MBC & ZZSH": {
    "type": "Access Control, Incorrect logic",
    "date": "2022-11-29",
    "rootCause": " \n\nBusiness Logic Flaw & Access Control\n\nThe root cause of the issue is a flaw in the MBC contract's implementation. The contract incorrectly uses the addLiquidity() function and mistakenly exposes swapAndLiquifyStepv1() function, which uses the balance of the contract's address as the desired reserve amount for maintaining reserves.\n\nSo attacker can call swapAndLiquifyStepV1, which will add a certain amount of MBC and BUSD to the pool to manipulate MBC price.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x4e87880a72f6896e7e0a635a5838ffc89b13bd17#code#L1263](https://bscscan.com/address/0x4e87880a72f6896e7e0a635a5838ffc89b13bd17#code#L1263)\n\n```jsx\nfunction swapAndLiquifyStepv1() public {. //vulnerable point\n        uint256 ethBalance = ETH.balanceOf(address(this));\n        uint256 tokenBalance = balanceOf(address(this));\n        addLiquidityUsdt(tokenBalance, ethBalance);\n    }\n\n    function addLiquidityUsdt(uint256 tokenAmount, uint256 usdtAmount) private {\n        uniswapV2Router.addLiquidity(\n            address(_baseToken),\n\t\t\taddress(this),\n            usdtAmount,\n            tokenAmount,\n            0,\n            0,\n            _tokenOwner,\n            block.timestamp\n        );\n    }\n```\n\n\n\n**Attack tx:**\n\n[https://phalcon.blocksec.com/tx/bsc/0xdc53a6b5bf8e2962cf0e0eada6451f10956f4c0845a3ce134ddb050365f15c86](https://phalcon.blocksec.com/tx/bsc/0xdc53a6b5bf8e2962cf0e0eada6451f10956f4c0845a3ce134ddb050365f15c86)\n\n**Analysis:**\n\n[https://twitter.com/AnciliaInc/status/1597742575623888896](https://twitter.com/AnciliaInc/status/1597742575623888896)\n[https://twitter.com/CertiKAlert/status/1597639717096460288](https://twitter.com/CertiKAlert/status/1597639717096460288)",
    "images": [
      "images/Business_2.png"
    ],
    "Lost": "$5.6k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MBC_exp.sol"
  },
  "SEAMAN": {
    "type": "Incorrect logic",
    "date": "2022-11-29",
    "rootCause": " \n\nBusiness Logic Flaw\n\nIn the SEAMAN project, the hacker exploited a vulnerability in the distribution mechanism of GVC tokens in the LP deposits. By calling the transfer function with the minimum unit of $SEAMAN, the attacker triggered a series of swaps. First, $SEAMAN was swapped for $BUSD in the BUSD-SEAMAN pair. Then, $BUSD was further swapped for $GVC in the BUSD-GVC pair. This caused a depletion of GVC tokens in the BUSD-GVC pair and resulted in an increase in the price of $GVC.\n\nAs a result of this flash loan attack, the attacker was able to make a profit of approximately $7,800.\n\n**Vulnerable code snippet:**\n\n```jsx\nhToken = IERC20(0xDB95FBc5532eEb43DeEd56c8dc050c930e31017e);//GVC\nlpToken = IERC20(0xDB95FBc5532eEb43DeEd56c8dc050c930e31017e);//GVC\nfunction transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(!_isBot[from],\"the bot address\");\n        if(_isDelivers[from] || _isDelivers[to]){\n            super._transfer(from, to, amount);\n            return;\n        }\n         if( uniswapV2Pair.totalSupply() > 0 && balanceOf(address(this)) > balanceOf(address(uniswapV2Pair)).div(10000) && to == address(uniswapV2Pair)){\n            if (\n                !swapping &&\n                _tokenOwner != from &&\n                _tokenOwner != to &&\n               !ammPairs[from] &&\n                !(from == address(uniswapV2Router) && !ammPairs[to])&&\n                swapAndLiquifyEnabled\n            ) {\n                swapping = true;\n                swapAndLiquifyV3(); //vulnerable point\n                swapAndLiquifyV1(); //vulnerable point\n                swapping = false; \n            }\n\t\t\t\t\t\t...\nfunction swapAndLiquifyV1() public {\n        uint256 canlpAmount = lpAmount.sub(lpTokenAmount);\n        uint256 amountT = balanceOf(address(uniswapV2Pair)).div(10000);\n        if(balanceOf(address(this)) >= canlpAmount && canlpAmount >= amountT){\n            if(canlpAmount >= amountT.mul(5))\n                canlpAmount = amountT.mul(5);\n            lpTokenAmount = lpTokenAmount.add(canlpAmount);\n            uint256 beflpBal = lpToken.balanceOf(address(this));\n            swapTokensFor(canlpAmount,address(lpToken),address(this));\n            uint256 newlpBal = lpToken.balanceOf(address(this)).sub(beflpBal);\n            lpDivTokenAmount = lpDivTokenAmount.add(newlpBal);\n            isLpProc = true;  \n        }\n    }\nfunction swapAndLiquifyV3() public {\n        uint256 canhAmount = hAmount.sub(hTokenAmount);\n        uint256 amountT = balanceOf(address(uniswapV2Pair)).div(10000);\n        if(balanceOf(address(this)) >= canhAmount && canhAmount >= amountT){\n            if(canhAmount >= amountT.mul(5))\n                canhAmount = amountT.mul(5);\n            hTokenAmount = hTokenAmount.add(canhAmount);\n            uint256 befhBal = hToken.balanceOf(address(this));\n            swapTokensFor(canhAmount,address(hToken),address(this));\n            uint256 newhBal = hToken.balanceOf(address(this)).sub(befhBal);\n            hDivTokenAmount = hDivTokenAmount.add(newhBal);\n            isHProc = true;\n        }\n    }\n\n    function swapTokensFor(uint256 tokenAmount,address token,address to) private{\n         // generate the uniswap pair path of token -> weth\n            address[] memory path = new address[](3);\n            path[0] = address(this);\n            path[1] = address(usdt);\n            path[2] = address(token);\n             // make the swap\n            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( //vulnerable point\n                tokenAmount,\n                0, // accept any amount of ETH\n                path,\n                to,\n                block.timestamp\n            );\n    }\n```\n\n\n\n\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0x6f1af27d08b10caa7e96ec3d580bf39e29fd5ece00abda7d8955715403bf34a8](https://explorer.phalcon.xyz/tx/bsc/0x6f1af27d08b10caa7e96ec3d580bf39e29fd5ece00abda7d8955715403bf34a8)\n\n**Analysis:**\n\n[https://twitter.com/CertiKAlert/status/1597513374841044993](https://twitter.com/CertiKAlert/status/1597513374841044993)\n\n[https://twitter.com/BeosinAlert/status/1597535796621631489](https://twitter.com/BeosinAlert/status/1597535796621631489)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$7k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SEAMAN_exp.sol"
  },
  "NUM": {
    "type": "CrossChain, ERC20, Token Incompatible",
    "date": "2022-11-23",
    "rootCause": " \n\nNUM token incompatible with the Multichain Router.\n\nThe attacker took advantage of a vulnerability in the Multichain bridge Router contract by exploiting the lack of compatibility between the NUM token and the Router. **The NUM token did not implement the required permit()** function but had a fallback() function that could be exploited.\n\nTo carry out the attack, the attacker created a fake token called anyToken, using NUM as the underlying token. They then deceived the Multichain Router by calling the anySwapOutUnderlyingWithPermit() function and providing the fake anyToken and a forged signature as parameters.\n\nSince the fallback function was present in NUM, the invocation of NUM.permit() succeeded. Subsequently, the attacker exchanged all the NUM tokens for approximately 13 Ether, making a profit from the attack.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0xd39015041518064743d955cf550c611b0b68888c#code](https://etherscan.io/address/0xd39015041518064743d955cf550c611b0b68888c#code)\n\n\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/eth/0x8a8145ab28b5d2a2e61d74c02c12350731f479b3175893de2014124f998bff32](https://explorer.phalcon.xyz/tx/eth/0x8a8145ab28b5d2a2e61d74c02c12350731f479b3175893de2014124f998bff32)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1595346020237352960](https://twitter.com/BlockSecTeam/status/1595346020237352960)\n\n[https://medium.com/numbers-protocol/investigation-report-of-multi-chain-bridge-incident-d4773cb3e87b](https://medium.com/numbers-protocol/investigation-report-of-multi-chain-bridge-incident-d4773cb3e87b)\n\n[https://neptunemutual.com/blog/taking-a-closer-look-at-the-numbers-protocol-hack/](https://neptunemutual.com/blog/taking-a-closer-look-at-the-numbers-protocol-hack/)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$13k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NUM_exp.sol"
  },
  "AUR": {
    "type": "Access Control",
    "date": "2022-11-22",
    "rootCause": " \n\nIncorrect access control.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x70678291bDDfd95498d1214BE368e19e882f7614#code#L578](https://bscscan.com/address/0x70678291bDDfd95498d1214BE368e19e882f7614#code#L578)\n\nThe **`changeRewardPerNode`** function lacks proper access control validation, which allows an attacker to call this function and set any value. The attacker first calls the **`changeRewardPerNode`** function to set the daily reward value to an extremely large number. Subsequently, the attacker calls the **`claimNodeReward`** function to extract the node reward, which is calculated based on the **`rewardPerDay`** value that the attacker has set.\n\n```solidity\n```\nfunction changeRewardPerNode(uint256 _rewardPerDay) external { //vulnerable point - Incorrect access control\n    rewardPerDay = _rewardPerDay;\n}\n```\n```\n\n**Attack tx:**\n\n[https://phalcon.blocksec.com/tx/bsc/0xb3bc6ca257387eae1cea3b997eb489c1a9c208d09ec4d117198029277468e25d](https://phalcon.blocksec.com/tx/bsc/0xb3bc6ca257387eae1cea3b997eb489c1a9c208d09ec4d117198029277468e25d)\n[https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782](https://phalcon.blocksec.com/tx/bsc/0x7f031e8543e75bd5c85168558be89d2e08b7c02a32d07d76517cdbb10e279782)\n\n**Analysis:**\n\n[https://twitter.com/AnciliaInc/status/1595142246570958848](https://twitter.com/AnciliaInc/status/1595142246570958848)\n\n[https://quillaudits.medium.com/hackers-steal-42m-from-fenbushi-capital-founders-wallet-dcce2b0a4e5b](https://quillaudits.medium.com/hackers-steal-42m-from-fenbushi-capital-founders-wallet-dcce2b0a4e5b)",
    "images": [],
    "Lost": "$13k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/AUR_exp.sol"
  },
  "sDAO": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2022-11-21",
    "rootCause": "\n\n`sDAO` contract have the following pitfalls:\n\n1. missing target token validation or access control on `withdrawTeam`, as the result, attacker may manipulate the reward output\n2. logic flaw on reward generation, the user can get reward in the same block when `to == address(LPInstance)`\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction getPerTokenReward() public view returns(uint) {\n        if ( LPInstance.balanceOf(address(this)) == 0) {\n            return 0;\n        }\n\n        uint newPerTokenReward = (totalStakeReward - lastTotalStakeReward) * 1e18 / LPInstance.balanceOf(address(this));\n        return PerTokenRewardLast + newPerTokenReward;\n    }\n```\n\n```solidity\nfunction transferFrom(\n        address from,\n        address to,\n        uint amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        if ( to == address(LPInstance) && tx.origin != address(0x547d834975279964b65F3eC685963fCc4978631E) ) {\n            totalStakeReward += amount  * 7 / 100;\n            _standardTransfer(from, address(this), amount * 7 / 100 );\n            _standardTransfer(from, address(0x0294a4C3E85d57Eb3bE568aaC17C4243d9e78beA), amount  / 100 );\n            _burn(from, amount / 50);\n            amount = amount  * 90 / 100;\n        }\n\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n```\n\n```solidity\nfunction withdrawTeam(address _token) external {\n        IERC20(_token).transfer(TEAM, IERC20(_token).balanceOf(address(this)));\n        payable(TEAM).transfer(address(this).balance);\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xb3ac111d294ea9dedfd99349304a9606df0b572d05da8cedf47ba169d10791ed](https://bscscan.com/tx/0xb3ac111d294ea9dedfd99349304a9606df0b572d05da8cedf47ba169d10791ed)\n\n**Analysis:**\n\n1. The attacker borrowed $500 `USDT` from `DPPOracle` in a flash loan.\n2. They converted half of the `USDT` into `sDAO`.\n3. They added liquidity to the `sDAO/USDT` pool with half of the remaining `USDT` and the `sDAO` they had just converted.\n4. They staked half of the LP tokens they received in the previous step.\n5. They sent the remaining `sDAO` to the liquidity pool, which increased the `totalStakeReward.`\n6. They called `sDAO.withdrawTeam` with LP tokens address as the target, which decreased the `LPInstance.balanceOf(address(this))` and increased the `getPerTokenReward`. They also sent a small amount of LP token to the pool to avoid division by zero.\n7. They invoked `getReward` and repaid the flash loan.\n\n[https://twitter.com/8olidity/status/1594693686398316544](https://twitter.com/8olidity/status/1594693686398316544)\n[https://twitter.com/CertiKAlert/status/1594615286556393478](https://twitter.com/CertiKAlert/status/1594615286556393478)",
    "images": [],
    "Lost": "$13k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SDAO_exp.sol"
  },
  "AnnexFinance": {
    "type": "Insufficient validation",
    "date": "2022-11-19",
    "rootCause": "\n\nMissing validation on target token for the liquidator\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) override external {\n        // Unpack parameters sent from the `liquidate` function\n        // NOTE: these are being passed in from some other contract, and cannot necessarily be trusted\n        (address borrower, address repayAToken, address seizeAToken) = abi.decode(data, (address, address, address));\n\n        address token0 = IPancakePair(msg.sender).token0();\n        address token1 = IPancakePair(msg.sender).token1();\n        require(msg.sender == IPancakeFactory(FACTORY).getPair(token0, token1));\n\n        if (repayAToken == seizeAToken) {\n            uint amount = amount0 != 0 ? amount0 : amount1; \n            address estuary = amount0 != 0 ? token0 : token1; //@note -> BNB\n\n            // Perform the liquidation\n            IERC20(estuary).safeApprove(repayAToken, amount);\n            ABep20(repayAToken).liquidateBorrow(borrower, amount, seizeAToken);\n\n            // Redeem aTokens for underlying ERC20\n            ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n\n            // Compute debt and pay back pair\n            IERC20(estuary).transfer(msg.sender, (amount * 1000 / 997) + 1);\n            return;\n        }\n\n        if (repayAToken == ABNB) {\n            uint amount = amount0 != 0 ? amount0 : amount1;\n            address estuary = amount0 != 0 ? token1 : token0;\n\n            // Convert WBNB to BNB\n            IWBNB(WBNB).withdraw(amount);\n\n            // Perform the liquidation\n            ABnb(repayAToken).liquidateBorrow{value: amount}(borrower, seizeAToken);\n\n            // Redeem aTokens for underlying ERC20\n            ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n\n            // Compute debt and pay back pair\n            (uint reserveOut, uint reserveIn) = PancakeLibrary.getReserves(FACTORY, WBNB, estuary);\n            IERC20(estuary).transfer(msg.sender, PancakeLibrary.getAmountIn(amount, reserveIn, reserveOut));\n            return;\n        }\n\n        if (seizeAToken == ABNB) {\n            uint amount = amount0 != 0 ? amount0 : amount1;\n            address source = amount0 != 0 ? token0 : token1;\n\n            // Perform the liquidation\n            IERC20(source).safeApprove(repayAToken, amount);\n            ABep20(repayAToken).liquidateBorrow(borrower, amount, seizeAToken);\n\n            // Redeem aTokens for underlying ERC20 or BNB\n            ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n\n            // Convert BNB to WBNB\n            IWBNB(WBNB).deposit{value: address(this).balance}();\n\n            // Compute debt and pay back pair\n            (uint reserveOut, uint reserveIn) = PancakeLibrary.getReserves(FACTORY, source, WBNB);\n            IERC20(WBNB).transfer(msg.sender, PancakeLibrary.getAmountIn(amount, reserveIn, reserveOut));\n            return;\n        }\n\n        uint amount;\n        address source;\n        address estuary;\n        if (amount0 != 0) {\n            amount = amount0;\n            source = token0;\n            estuary = token1;\n        } else {\n            amount = amount1;\n            source = token1;\n            estuary = token0;\n        }\n\n        // Perform the liquidation\n        IERC20(source).safeApprove(repayAToken, amount);\n        ABep20(repayAToken).liquidateBorrow(borrower, amount, seizeAToken);\n\n        // Redeem aTokens for underlying ERC20 or BNB\n        uint seized_uUnits = ABep20(seizeAToken).balanceOfUnderlying(address(this));\n        ABep20(seizeAToken).redeem(IERC20(seizeAToken).balanceOf(address(this)));\n        address seizeUToken = ABep20Storage(seizeAToken).underlying();\n\n        // Compute debt\n        (uint reserveOut, uint reserveIn) = PancakeLibrary.getReserves(FACTORY, source, estuary);\n        uint debt = PancakeLibrary.getAmountIn(amount, reserveIn, reserveOut);\n\n        if (seizeUToken == estuary) {\n            // Pay back pair\n            IERC20(estuary).transfer(msg.sender, debt);\n            return;\n        }\n\n        IERC20(seizeUToken).safeApprove(ROUTER, seized_uUnits);\n\n        // Define swapping path\n        address[] memory path = new address[](2);\n        path[0] = seizeUToken;\n        path[1] = estuary;\n\n        uint256 minReceiveDebt = debt * 95 / 100;\n        //                                                  sent, min desired, ,   path, recipient,     deadline\n        IPancakeRouter(ROUTER).swapExactTokensForTokens(seized_uUnits, minReceiveDebt, path, address(this), now + 1 minutes);\n\n        IERC20(seizeUToken).safeApprove(ROUTER, 0);\n\n        // Pay back pair\n        IERC20(estuary).transfer(msg.sender, debt);\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x3757d177482171dcfad7066c5e88d6f0f0fe74b28f32e41dd77137cad859c777](https://bscscan.com/tx/0x3757d177482171dcfad7066c5e88d6f0f0fe74b28f32e41dd77137cad859c777)\n\n**Analysis:**\n\n1. The attacker prepares a new token and creates pool(add liquidity) for the new token\n2.  Invoke the swap function with new pair and trigger the liquidating process\n3. Since there is no limitation on the liquidate target, the attacker put the attack contract address for three times for the liquidate information:\n\n```solidity\naddress borrower, address repayAToken, address seizeAToken) = abi.decode(data, (address, address, address));\n```\n\n1. Since the `repayAToken` is the attacker's address, it will not use the allowance in the `liquidateBorrow`\n    \n    ```solidity\n    IERC20(estuary).safeApprove(repayAToken, amount);\n    ```\n    \n2. The attacker utilizes the allowance to remove funds from the `liquidator`\n\n[https://twitter.com/AnciliaInc/status/1593690338526273536](https://twitter.com/AnciliaInc/status/1593690338526273536)",
    "images": [],
    "Lost": "$3k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Annex_exp.sol"
  },
  "UEarnPool": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2022-11-17",
    "rootCause": "\n\nThe design flaw in the reward distribution which allows the final reward exceed the invested amount.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x02d841b976298dcd37ed6cc59f75d9dd39a3690c#code](https://bscscan.com/address/0x02d841b976298dcd37ed6cc59f75d9dd39a3690c#code)\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x824de0989f2ce3230866cb61d588153e5312151aebb1e905ad775864885cd418](https://bscscan.com/tx/0x824de0989f2ce3230866cb61d588153e5312151aebb1e905ad775864885cd418)[Preparation]\n\n[https://bscscan.com/tx/0xb83f9165952697f27b1c7f932bcece5dfa6f0d2f9f3c3be2bb325815bfd834ec](https://bscscan.com/tx/0xb83f9165952697f27b1c7f932bcece5dfa6f0d2f9f3c3be2bb325815bfd834ec)[Attack]\n\n**Analysis:**\n\n1. [Preparation]The attacker deployed 20 attack contracts and bound each of them sequentially\n2. The attacker flashloaned 2.4M BUSD and sent to the last contract(0x21c473f) that was created in the previous step.\n3. The account stake all USDT to the UEarnpool. As a result, inviters will receive some BUSD tokens as reward.\n4. Then the account invoked `claimTeamReward`.\n5. The rest account was repeated 16 times and did stake with 20,000 BUSD and invoked `claimTeamReward` to claim the team reward, which is 162K BUSD. The rewards and the rest of the amount will be sent back to the attacker.\n6. repay the flashloan and finish the attack.\n\n[https://twitter.com/CertiKAlert/status/1593094922160128000](https://twitter.com/CertiKAlert/status/1593094922160128000)",
    "images": [],
    "Lost": "$24k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/UEarnPool_exp.sol"
  },
  "SheepFarm": {
    "type": "Incorrect logic",
    "date": "2022-11-16",
    "rootCause": "\n\nThe root cause of the attack is that the function `register` can be repeatedly invoked by the same account.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x4726010da871f4b57b5031e3ea48bde961f122aa#code](https://bscscan.com/address/0x4726010da871f4b57b5031e3ea48bde961f122aa#code)\n\n```solidity\nfunction register(address neighbor) external initialized {\n        address user = msg.sender;\n        require(villages[user].timestamp == 0, \"just new users\"); //@audit not updated while the new user creation\n        uint256 gems;\n        totalVillages++;\n        if (villages[neighbor].sheeps[0] > 0 && neighbor != manager) {\n            gems += GEM_BONUS * 2;\n        } else{\n            neighbor = manager;\n            gems += GEM_BONUS;\n        }\n        villages[neighbor].neighbors++;\n        villages[user].neighbor = neighbor;\n        villages[user].gems += gems;\n        emit Newbie(msg.sender, gems);\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x5735026e5de6d1968ab5baef0cc436cc0a3f4de4ab735335c5b1bd31fa60c582](https://bscscan.com/tx/0x5735026e5de6d1968ab5baef0cc436cc0a3f4de4ab735335c5b1bd31fa60c582)\n\n**Analysis:**\n\n1. The attacker repeatedly invokes the `register` function to increase the GEM bonus\n\n 2.  The attacker invokes `addGems` and `upgradeVillage`, to update GEM value and accumulate yield\n\n1. The attacker invokes `sellVillage` to convert GEM to money\n2. Then withdraw the money(BNB) via `withdrawMoney`\n\n[https://twitter.com/AnciliaInc/status/1592658104394473472](https://twitter.com/AnciliaInc/status/1592658104394473472)\n[https://twitter.com/BlockSecTeam/status/1592734292727455744](https://twitter.com/BlockSecTeam/status/1592734292727455744)",
    "images": [],
    "Lost": "1BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SheepFram_exp.sol"
  },
  "DFXFinance": {
    "type": "Flashloans, Incorrect logic",
    "date": "2022-11-10",
    "rootCause": "\n\nThe victim contract uses contract balance for the repayment judgment. As a result, the attacker uses deposit() to bypass the flashloan repayment. \n\n**Vulnerable code snippet:**\n\n```solidity\nfunction flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external transactable noDelegateCall isNotEmergency {\n        uint256 fee = curve.epsilon.mulu(1e18);\n        \n        require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n        require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n        \n        uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n        uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n        uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n        uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n\n        if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n        if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n\n        IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n\n        uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n        uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n\n        require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n        require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\n\n        // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n        uint256 paid0 = balance0After - balance0Before;\n        uint256 paid1 = balance1After - balance1Before;\n\n        IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n        IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n\n        emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7](https://etherscan.io/tx/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1590960299246780417](https://twitter.com/BlockSecTeam/status/1590960299246780417)\n[https://twitter.com/BeosinAlert/status/1591012525914861570](https://twitter.com/BeosinAlert/status/1591012525914861570)\n[https://twitter.com/AnciliaInc/status/1590839104731684865](https://twitter.com/AnciliaInc/status/1590839104731684865)\n[https://twitter.com/peckshield/status/1590831589004816384](https://twitter.com/peckshield/status/1590831589004816384)",
    "images": [],
    "Lost": "$4M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DFX_exp.sol"
  },
  "BrahTOPG": {
    "type": "Insufficient validation",
    "date": "2022-11-09",
    "rootCause": "\n\nThe contract zapper does not maintain enough validations, which allows attackers to manipulate the victims\u2019 pre-approved funds with fake tokens.\n\n**Vulnerable code snippet:**\n\n[https://vscode.blockscan.com/ethereum/0xd248b30a3207a766d318c7a87f5cf334a439446d](https://vscode.blockscan.com/ethereum/0xd248b30a3207a766d318c7a87f5cf334a439446d)\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xeaef2831d4d6bca04e4e9035613be637ae3b0034977673c1c2f10903926f29c0](https://etherscan.io/tx/0xeaef2831d4d6bca04e4e9035613be637ae3b0034977673c1c2f10903926f29c0)\n\n**Analysis:**\n\n1. The attacker queried the USDC balance of one of the\u00a0users\n2. Invoke `zapIn` with an attacker-controlled token.\n    \n    ```solidity\n    struct ZapData {\n            address requiredToken;\n            uint256 amountIn;\n            uint256 minAmountOut;\n            address allowanceTarget;\n            address swapTarget;\n            bytes callData;\n        }\n    ```\n    \n3. The `zapIn` invocation will trigger the `zap` function, transferring the pre-approved USDC tokens from the victim.\n\n[https://medium.com/neptune-mutual/decoding-brahma-brahtopg-smart-contract-vulnerability-7b7c364b79d8](https://medium.com/neptune-mutual/decoding-brahma-brahtopg-smart-contract-vulnerability-7b7c364b79d8)",
    "images": [],
    "Lost": "$89k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BrahTOPG_exp.sol"
  },
  "MEV_0ad8": {
    "type": "Access Control, call/delegatecall",
    "date": "2022-11-08",
    "rootCause": "\n\nThe function `0x090f88ca` in the victim contract can perform external calls but without access control.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x0ad8229d4bc84135786ae752b9a9d53392a8afd4#code](https://etherscan.io/address/0x0ad8229d4bc84135786ae752b9a9d53392a8afd4#code)\n\n[https://library.dedaub.com/decompile?md5=cfe9b723db1cc321f10bca2e5ba911aa](https://library.dedaub.com/decompile?md5=cfe9b723db1cc321f10bca2e5ba911aa)\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x674f74b30a3d7bdf15fa60a7c29d96a402ea894a055f624164a8009df98386a0](https://etherscan.io/tx/0x674f74b30a3d7bdf15fa60a7c29d96a402ea894a055f624164a8009df98386a0)\n\n**Analysis:**\n\nThe attacker invokes function `0x090f88ca` and arbitrary call data: \n\n```solidity\n0x\n000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\n000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000001\n00000000000000000000000000000000000000000000000000000000000000a0\n0000000000000000000000000000000000000000000000000000000000000064\n23b872dd000000000000000000000000211b6a1137bf539b2750e02b9e525cf5 => 23b872dd TransferFrom\n757a35ae000000000000000000000000ae39a6c2379bef53334ea968f4c711c8 => 211b6a1137bf539b2750e02b9e525cf5 => 23b872dd TransferFrom\n757a35ae victim\ncf3898b600000000000000000000000000000000000000000000000000000015 => ae39a6c2379bef53334ea968f4c711c8cf3898b6 attacker\n560e9ff900000000000000000000000000000000000000000000000000000000\n```\n\n\n\n[https://twitter.com/Supremacy_CA/status/1590337718755954690](https://twitter.com/Supremacy_CA/status/1590337718755954690)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$282k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MEV_0ad8.t.sol"
  },
  "Kashi": {
    "type": "Incorrect logic",
    "date": "2022-11-08",
    "rootCause": "\n\nThe `borrow` function uses the outdated\u00a0`exchangeRate`\u00a0to verify the borrowed share in the\u00a0`solvent`\u00a0modifier.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x2cba6ab6574646badc84f0544d05059e57a5dc42#code](https://etherscan.io/address/0x2cba6ab6574646badc84f0544d05059e57a5dc42#code)\n\n```solidity\n/// @dev Concrete implementation of `borrow`.\n    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\n        userBorrowPart[msg.sender] = userBorrowPart[msg.sender].add(part);\n        emit LogBorrow(msg.sender, to, amount, feeAmount, part);\n\n        share = bentoBox.toShare(asset, amount, false);\n        Rebase memory _totalAsset = totalAsset;\n        require(_totalAsset.base >= 1000, \"Kashi: below minimum\");\n        _totalAsset.elastic = _totalAsset.elastic.sub(share.to128());\n        totalAsset = _totalAsset;\n        bentoBox.transfer(asset, address(this), to, share);\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {\n        accrue();\n        (part, share) = _borrow(to, amount);\n    }\n```\n\n```solidity\n/// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(\n        address user,\n        bool open,\n        uint256 _exchangeRate\n    ) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        return\n            bentoBox.toAmount(\n                collateral,\n                collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(\n                    open ? OPEN_COLLATERIZATION_RATE : CLOSED_COLLATERIZATION_RATE\n                ),\n                false\n            ) >=\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\n            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;\n    }\n\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent() {\n        _;\n        require(_isSolvent(msg.sender, false, exchangeRate), \"KashiPair: user insolvent\");\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x3d163bfbec5686d428a6d43e45e2626a220cc4fcfac7620c620b82c1f2537c78](https://etherscan.io/tx/0x3d163bfbec5686d428a6d43e45e2626a220cc4fcfac7620c620b82c1f2537c78)\n\n**Analysis:**\n\n[https://eigenphi.substack.com/p/casting-a-magic-spell-on-abracadabra](https://eigenphi.substack.com/p/casting-a-magic-spell-on-abracadabra)\n[https://twitter.com/BlockSecTeam/status/1603633067876155393](https://twitter.com/BlockSecTeam/status/1603633067876155393)",
    "images": [],
    "Lost": "$110k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Kashi_exp.sol"
  },
  "MooCAKECTX": {
    "type": "Flashloans",
    "date": "2022-11-07",
    "rootCause": "\n\nThe reward calculation on the victim contract is not time-related, and the attacker bypasses the `isContract` validation by performing an attack in the constructor. \n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x489afbaed0ea796712c9a6d366c16ca3876d8184#code](https://bscscan.com/address/0x489afbaed0ea796712c9a6d366c16ca3876d8184#code)\n\n[https://bscscan.com/address/0xc2562dd7e4caee53df0f9cd7d4dddaa53bcd3d9b#code](https://bscscan.com/address/0xc2562dd7e4caee53df0f9cd7d4dddaa53bcd3d9b#code)\n\n```solidity\n/**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef & SmartChef\n     * 2. It swaps the {output} token for {cake}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).leaveStaking(0);\n        ISmartChef(smartchef).deposit(0);\n        doswap();\n        dosplit();\n        deposit();\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x03d363462519029cf9a544d44046cad0c7e64c5fb1f2adf5dd5438a9a0d2ec8e](https://bscscan.com/tx/0x03d363462519029cf9a544d44046cad0c7e64c5fb1f2adf5dd5438a9a0d2ec8e)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1589501207181393920](https://twitter.com/BeosinAlert/status/1589501207181393920)\n[https://twitter.com/CertiKAlert/status/1589428153591615488](https://twitter.com/CertiKAlert/status/1589428153591615488)",
    "images": [],
    "Lost": "$140k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MooCAKECTX_exp.sol"
  },
  "BDEX": {
    "type": "Price Manipulation",
    "date": "2022-11-05",
    "rootCause": "\n\nThe underlying issue stems from the fact that the `convertDustToEarned` function within the `BvaultsStrategy` contract lacks price checks. This deficiency becomes particularly problematic for trading pairs with low liquidity, as they are more susceptible to experiencing significant price changes due to variations in trading volume.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0xB2B1DC3204ee8899d6575F419e72B53E370F6B20#code](https://bscscan.com/address/0xB2B1DC3204ee8899d6575F419e72B53E370F6B20#code)\n\n```solidity\nfunction convertDustToEarned() public whenNotPaused {\n        require(isAutoComp, \"!isAutoComp\");\n\n        // Converts dust tokens into earned tokens, which will be reinvested on the next earn().\n\n        // Converts token0 dust (if any) to earned tokens\n        uint256 _token0Amt = IERC20(token0Address).balanceOf(address(this));\n        if (token0Address != earnedAddress && _token0Amt > 0) {\n            _vswapSwapToken(token0Address, earnedAddress, _token0Amt);\n        }\n\n        // Converts token1 dust (if any) to earned tokens\n        uint256 _token1Amt = IERC20(token1Address).balanceOf(address(this));\n        if (token1Address != earnedAddress && _token1Amt > 0) {\n            _vswapSwapToken(token1Address, earnedAddress, _token1Amt);\n        }\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xe7b7c974e51d8bca3617f927f86bf907a25991fe654f457991cbf656b190fe94](https://bscscan.com/tx/0xe7b7c974e51d8bca3617f927f86bf907a25991fe654f457991cbf656b190fe94)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1588579143830343683](https://twitter.com/BeosinAlert/status/1588579143830343683)",
    "images": [],
    "Lost": "16WBNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BDEX_exp.sol"
  },
  "VTF Token": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2022-10-27",
    "rootCause": "\n\nThe function `updateUserBalance` does not ascertain the duration for which a user has retained the token. Exploiting this, the attacker pre-deploys numerous malicious contracts, secures the initial $VTF via a flashloan, and subsequently transfers the VTF tokens to each attack contract sequentially. This maneuver enables the attacker to claim the rewards for holding.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0xc6548caf18e20f88cc437a52b6d388b0d54d830d#code](https://bscscan.com/address/0xc6548caf18e20f88cc437a52b6d388b0d54d830d#code)\n\n```solidity\nfunction updateUserBalance(address _user) public {\n\t\tuint256 totalAmountOver = super.totalSupply();\n\t\tif(maxTotal <= totalAmountOver){\n\t\t\tmaxCanMint = false;\n\t\t}\n\n        if(userBalanceTime[_user] > 0){\n\t\t\tuint256 canMint = getUserCanMint(_user);\n\t\t\tif(canMint > 0){\n\t\t\t\tuserBalanceTime[_user] = block.timestamp;\n\t\t\t\t_mint(_user, canMint);\n\t\t\t}\n\t\t}else{\n\t\t\tuserBalanceTime[_user] = block.timestamp;\n\t\t}\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xeeaf7e9662a7488ea724223c5156e209b630cdc21c961b85868fe45b64d9b086](https://bscscan.com/tx/0xeeaf7e9662a7488ea724223c5156e209b630cdc21c961b85868fe45b64d9b086)\n[https://bscscan.com/tx/0xc2d2d7164a9d3cfce1e1dac7dc328b350c693feb0a492a6989ceca7104eef9b7](https://bscscan.com/tx/0xc2d2d7164a9d3cfce1e1dac7dc328b350c693feb0a492a6989ceca7104eef9b7)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1585575129936977920](https://twitter.com/BlockSecTeam/status/1585575129936977920)\n\n[https://twitter.com/peckshield/status/1585572694241988609](https://twitter.com/peckshield/status/1585572694241988609)\n\n[https://twitter.com/BeosinAlert/status/1585587030981218305](https://twitter.com/BeosinAlert/status/1585587030981218305)",
    "images": [],
    "Lost": "$50k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/VTF_exp.sol"
  },
  "Team Finance": {
    "type": "Insufficient validation",
    "date": "2022-10-27",
    "rootCause": "\n\nIn `migrate` function, the validation on `MigrateParams` is the function's input value.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x48d118c9185e4dbafe7f3813f8f29ec8a6248359#code](https://etherscan.io/address/0x48d118c9185e4dbafe7f3813f8f29ec8a6248359#code%23L1535)\n\n```solidity\n/**\n     * migrate liquidity from v2 to v3\n    */\n    function migrate(\n        uint256 _id,\n        IV3Migrator.MigrateParams calldata params,\n        bool noLiquidity,\n        uint160 sqrtPriceX96,\n        bool _mintNFT\n    )\n    external\n    payable\n    whenNotPaused\n    nonReentrant\n    {\n        require(address(nonfungiblePositionManager) != address(0), \"NFT manager not set\");\n        require(address(v3Migrator) != address(0), \"v3 migrator not set\");\n        Items memory lockedERC20 = lockedToken[_id];\n        require(block.timestamp < lockedERC20.unlockTime, \"Unlock time already reached\");\n        require(_msgSender() == lockedERC20.withdrawalAddress, \"Unauthorised sender\");\n        require(!lockedERC20.withdrawn, \"Already withdrawn\");\n\n        uint256 totalSupplyBeforeMigrate = nonfungiblePositionManager.totalSupply();\n        \n        //scope for solving stack too deep error\n        {\n            uint256 ethBalanceBefore = address(this).balance;\n            uint256 token0BalanceBefore = IERC20(params.token0).balanceOf(address(this));\n            uint256 token1BalanceBefore = IERC20(params.token1).balanceOf(address(this));\n            \n            //initialize the pool if not yet initialized\n            if(noLiquidity) {\n                v3Migrator.createAndInitializePoolIfNecessary(params.token0, params.token1, params.fee, sqrtPriceX96);\n            }\n\n            IERC20(params.pair).approve(address(v3Migrator), params.liquidityToMigrate);\n\n            v3Migrator.migrate(params);\n\n            //refund eth or tokens\n            uint256 refundEth = address(this).balance - ethBalanceBefore;\n            (bool refundSuccess,) = _msgSender().call.value(refundEth)(\"\");\n            require(refundSuccess, 'Refund ETH failed');\n\n            uint256 token0BalanceAfter = IERC20(params.token0).balanceOf(address(this));\n            uint256 refundToken0 = token0BalanceAfter - token0BalanceBefore;\n            if( refundToken0 > 0 ) {\n                require(IERC20(params.token0).transfer(_msgSender(), refundToken0));\n            }\n\n            uint256 token1BalanceAfter = IERC20(params.token1).balanceOf(address(this));\n            uint256 refundToken1 = token1BalanceAfter - token1BalanceBefore;\n            if( refundToken1 > 0 ) {\n                require(IERC20(params.token1).transfer(_msgSender(), refundToken1));\n            }\n        }\n\n        //remove old locked token details\n        _removeERC20Deposit(_id);\n\n        //Get the token id of newly generated nft for v3\n        uint256 totalSupplyAfterMigrate = nonfungiblePositionManager.totalSupply();\n        require(totalSupplyAfterMigrate == totalSupplyBeforeMigrate.add(1));\n        uint256 tokenIndex = totalSupplyAfterMigrate.sub(1);\n        uint256 tokenId = nonfungiblePositionManager.tokenByIndex(tokenIndex);\n\n        //add new locked nft details ( received after migrating liquidity )\n        uint256 newDepositId = ++depositId;\n        _addNFTDeposit(_id, newDepositId, tokenId);\n\n        listMigratedDepositIds[newDepositId] = _id;\n\n        if (_mintNFT){\n            require(NFT != address(0), 'NFT: Unintalized');\n            nftMinted[newDepositId] = true;\n        }\n\n        if(nftMinted[_id])\n        {\n            nftMinted[_id] = false;\n            IERC721Extended(NFT).burn(_id);\n        }\n        if (_mintNFT){\n            IERC721Extended(NFT).mintLiquidityLockNFT(_msgSender(), newDepositId);\n        }\n        \n        emit LiquidityMigrated(_msgSender(), _id, newDepositId, tokenId);\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xb2e3ea72d353da43a2ac9a8f1670fd16463ab370e563b9b5b26119b2601277ce](https://etherscan.io/tx/0xb2e3ea72d353da43a2ac9a8f1670fd16463ab370e563b9b5b26119b2601277ce)\n\n- Pre-work1: `lockToken()`\n    [https://etherscan.io/tx/0xe8f17ee00906cd0cfb61671937f11bd3d26cdc47c1534fedc43163a7e89edc6f](https://etherscan.io/tx/0xe8f17ee00906cd0cfb61671937f11bd3d26cdc47c1534fedc43163a7e89edc6f)\n- Pre-work2: `extendLockDuration()`\nid 15324: [https://etherscan.io/tx/0x2972f75d5926f8f948ab6a0cabc517a05f0da5b53e20f670591afbaa501aa436](https://etherscan.io/tx/0x2972f75d5926f8f948ab6a0cabc517a05f0da5b53e20f670591afbaa501aa436)\nid 15325: [https://etherscan.io/tx/0xec75bb553f50af37f8dd8f4b1e2bfe4703b27f586187741b91db770ad9b230cb](https://etherscan.io/tx/0xec75bb553f50af37f8dd8f4b1e2bfe4703b27f586187741b91db770ad9b230cb)\nid 15326: [https://etherscan.io/tx/0x79ec728612867b3d82c0e7401e6ee1c533b240720c749b3968dea1464e59b2c4](https://etherscan.io/tx/0x79ec728612867b3d82c0e7401e6ee1c533b240720c749b3968dea1464e59b2c4)\nid 15327: [https://etherscan.io/tx/0x51185fb580892706500d3b6eebb8698c27d900618021fb9b1797f4a774fffb04](https://etherscan.io/tx/0x51185fb580892706500d3b6eebb8698c27d900618021fb9b1797f4a774fffb04)\n\n**Analysis:**\n\nTeam Finance Official : [https://twitter.com/TeamFinance_/status/1585770918873542656](https://twitter.com/TeamFinance_/status/1585770918873542656)\nPeckShield : [https://twitter.com/peckshield/status/1585587858978623491](https://twitter.com/peckshield/status/1585587858978623491)\nSolid Group : [https://twitter.com/solid_group_1/status/1585643249305518083](https://twitter.com/solid_group_1/status/1585643249305518083)\nBeiosin Alert : [https://twitter.com/BeosinAlert/status/1585578499125178369](https://twitter.com/BeosinAlert/status/1585578499125178369)",
    "images": [],
    "Lost": "$15.8M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TeamFinance.exp.sol"
  },
  "N00d Token": {
    "type": "Flashloans, Reentrancy",
    "date": "2022-10-26",
    "rootCause": "\n\nThe root cause of this incident is the ERC777 token reentrancy which allows attacker to use old `totalSushi` and updated `totalShares` for mint. \n\n**Vulnerable code snippet:**\n\n```solidity\n// Enter the bar. Pay some SUSHIs. Earn some shares.\n    function enter(uint256 _amount) public {\n        uint256 totalSushi = sushi.balanceOf(address(this));\n        uint256 totalShares = totalSupply();\n        if (totalShares == 0 || totalSushi == 0) {\n            _mint(msg.sender, _amount);\n        } else {\n            uint256 what = _amount.mul(totalShares).div(totalSushi);\n            _mint(msg.sender, what);\n        }\n        sushi.transferFrom(msg.sender, address(this), _amount);\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x8037b3dc0bf9d5d396c10506824096afb8125ea96ada011d35faa89fa3893aea](https://etherscan.io/tx/0x8037b3dc0bf9d5d396c10506824096afb8125ea96ada011d35faa89fa3893aea)\n\n**Analysis:**\n\nThe attacker exploits the potential for reentrancy with the ERC777 token (sushi). Within the`enter` function, the reentrancy can be initiated through the `sushi.transferFrom` call. In this function, the `mint` process is invoked first, which updates the total token supply. However, the update of `totalSushi` occurs after the `transferFrom` is finished. As a consequence, the calculation result `uint256 what = _amount.mul(totalShares).div(totalSushi);` becomes magnified due to the unchanged `totalSushi` value, despite an increase in `totalShares`.\n\n \n\n\n\n[https://twitter.com/BlockSecTeam/status/1584959295829180416](https://twitter.com/BlockSecTeam/status/1584959295829180416)\n\n[https://twitter.com/AnciliaInc/status/1584955717877784576](https://twitter.com/AnciliaInc/status/1584955717877784576)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$29k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/N00d_exp.sol"
  },
  "ULME": {
    "type": "Flashloans, Price Manipulation",
    "date": "2022-10-25",
    "rootCause": "\n\n**`buyMiner`** function in the contract UniverseGoldMountain (ULME) is public and could potentially enable price manipulation, it appears that the attacker is exploiting this vulnerability to their advantage. By leveraging the flashloan, the attacker can potentially manipulate the price of ULME tokens and benefit from the price changes in the process.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction buyMiner(address user,uint256 usdt)public returns (bool){\n        address[]memory token=new address[](2);\n        token[0]=_usdt_token;\n        token[1]=address(this);\n        usdt=usdt.add(usdt.div(10));\n        require(IERC20(_usdt_token).transferFrom(user,address(this),usdt), \"buyUlm: transferFrom to ulm error\");\n        uint256 time=sale_date;\n        sale_date=0;\n        address k=0x25812c28CBC971F7079879a62AaCBC93936784A2;\n        IUniswapV2Router01(_roter).swapExactTokensForTokens(usdt,1000000,token,k,block.timestamp+60);\n        IUniswapV2Router01(k).transfer(address(this),address(this),IERC20(address(this)).balanceOf(k));\n        sale_date=time;\n        return true;\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xdb9a13bc970b97824e082782e838bdff0b76b30d268f1d66aac507f1d43ff4ed](https://bscscan.com/tx/0xdb9a13bc970b97824e082782e838bdff0b76b30d268f1d66aac507f1d43ff4ed)\n\n**Analysis:**\n\n1. Utilize a Flashloan to borrow BUSD from the lending platform.\n2. Execute a swap of the borrowed BUSD for ULME tokens via PancakeSwap.\n3. Utilize pre-approved users who possess BUSD tokens to trigger the **`buyMiner`** function of the ULME token.\n4. Employ indirect price manipulation to exchange ULME tokens back for BUSD. And this behavior will increase the ULME token again.\n5. Repay the Flashloan and secure a profit of 50,646 BUSD as the profit.\n\n[https://twitter.com/BlockSecTeam/status/1584839309781135361](https://twitter.com/BlockSecTeam/status/1584839309781135361)\u00a0\n\n[https://twitter.com/BeosinAlert/status/1584888021299916801](https://twitter.com/BeosinAlert/status/1584888021299916801)",
    "images": [],
    "Lost": "$200k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ULME.sol"
  },
  "Market": {
    "type": "Flashloans, Reentrancy",
    "date": "2022-10-24",
    "rootCause": "\n\nMarket.xyz had been utilizing the Curve LP Oracle for their lending and borrowing markets. However, a price manipulation vulnerability arose because of the presence of Read-Only Reentrancy in the Curve LP Oracle.\n\n**Vulnerable code snippet:**\n\n```solidity\n@external\n@nonreentrant('lock')\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],\n                     use_eth: bool = False, receiver: address = msg.sender):\n    \"\"\"\n    This withdrawal method is very safe, does no complex math\n    \"\"\"\n    lp_token: address = self.token\n    total_supply: uint256 = CurveToken(lp_token).totalSupply()\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)\n    balances: uint256[N_COINS] = self.balances\n    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit\n\n    for i in range(N_COINS):\n        d_balance: uint256 = balances[i] * amount / total_supply\n        assert d_balance >= min_amounts[i]\n        self.balances[i] = balances[i] - d_balance\n        balances[i] = d_balance  # now it's the amounts going out\n        coin: address = self.coins[i]\n        if use_eth and coin == WETH20:\n            raw_call(receiver, b\"\", value=d_balance)\n        else:\n            if coin == WETH20:\n                WETH(WETH20).deposit(value=d_balance)\n            response: Bytes[32] = raw_call(\n                coin,\n                _abi_encode(receiver, d_balance, method_id=method_id(\"transfer(address,uint256)\")),\n                max_outsize=32,\n            )\n            if len(response) != 0:\n                assert convert(response, bool)\n\n    D: uint256 = self.D\n    self.D = D - D * amount / total_supply\n\n    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)\n```\n\n**Attack tx:**\n\n[https://polygonscan.com/tx/0xb8efe839da0c89daa763f39f30577dc21937ae351c6f99336a0017e63d387558](https://polygonscan.com/tx/0xb8efe839da0c89daa763f39f30577dc21937ae351c6f99336a0017e63d387558)\n\n[https://polygonscan.com/tx/0x303c770b81d8866693aa341774eaa2cd5dc3a5f1d2ad855b9d6f0c10b5c36d5d](https://polygonscan.com/tx/0x303c770b81d8866693aa341774eaa2cd5dc3a5f1d2ad855b9d6f0c10b5c36d5d)\n\n**Analysis:**\n\nThe attack flow as follow:\n\n1. Execute a flashloan of WMATIC and stMATIC tokens.\n2. Provide liquidity to the WMATIC/stMATIC Curve pool and receive Curve LP tokens.\n3. Utilize a portion of the Curve LP tokens as collateral on [**http://market.xyz**](http://market.xyz/).\n4. **Increase** the collateral's value by removing liquidity from the Curve pool.\n    1. when removing the liquidity, D value remain unchanged but total supply already updated.\n    2. more: [https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/](https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/)\n5. Use the expensive collateral to borrow MAI using a fallback function.\n6. Initiate self-liquidation to acquire the collateral at a discounted price.\n7. Repay the flashloan.\n\n[https://quillaudits.medium.com/decoding-220k-read-only-reentrancy-exploit-quillaudits-30871d728ad5](https://quillaudits.medium.com/decoding-220k-read-only-reentrancy-exploit-quillaudits-30871d728ad5)",
    "images": [],
    "Lost": "$220k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221024-market---read-only-reentrancy"
  },
  "LW": {
    "type": "Sandwich",
    "date": "2023-05-12",
    "rootCause": "\n\nKALOS: LW was hacked on May 11, 2023. This vulnerability is under the category of Rugpull cases, which, unlike other instances, were exploited by owners. A total of 6 accounts had funds forcefully drained.\n\n**Vulnerable code snippet:**\n\n```solidity\nreceive() external payable {\n        if(thanPrice==0) return;\n        if(IERC20(_token).balanceOf(_marketAddr ) >=3000e18 ){\n            IERC20(_token).transferFrom(_marketAddr,address(this),3000e18);\n            swapTokensForDead(3000e18); **//vulnerable point**\n            thanPrice-=1;\n        }\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xb846f3aeb9b3027fe138b23bbf41901c155bd6d4b24f08d6b83bd37a975e4e4a](https://bscscan.com/tx/0xb846f3aeb9b3027fe138b23bbf41901c155bd6d4b24f08d6b83bd37a975e4e4a)\n\n[https://bscscan.com/tx/0x96b34dc3a98cd4055a984132d7f3f4cc5a16b2525113b8ef83c55ac0ba2b3713](https://bscscan.com/tx/0x96b34dc3a98cd4055a984132d7f3f4cc5a16b2525113b8ef83c55ac0ba2b3713)\n\n**Analysis:**\n\n[https://twitter.com/PeckShieldAlert/status/1656850634312925184](https://twitter.com/PeckShieldAlert/status/1656850634312925184)\n\n[https://twitter.com/hexagate_/status/1657051084131639296](https://twitter.com/hexagate_/status/1657051084131639296)\n\n[https://twitter.com/kalos_security/status/1668092799512907777](https://twitter.com/kalos_security/status/1668092799512907777)",
    "images": [],
    "Lost": "$50k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LW_exp.sol"
  },
  "OlympusDAO": {
    "type": "DAO, Insufficient validation",
    "date": "2022-10-21",
    "rootCause": "insufficient validation\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x007FE7c498A2Cf30971ad8f2cbC36bd14Ac51156#code#F1#L137](https://etherscan.io/address/0x007FE7c498A2Cf30971ad8f2cbC36bd14Ac51156#code#F1#L137)\n\nDue to token_ is controllable and does not validate properly on BondFixedExpiryTeller, attacker can create a custom contract to drain out the fund on BondFixedExpiryTeller. \n\n```solidity\n/// @inheritdoc IBondFixedExpiryTeller\n    function redeem(ERC20BondToken token_, uint256 amount_) external override nonReentrant {**//vulnerable point,** insufficient validation\n        if (uint48(block.timestamp) < token_.expiry())\n            revert Teller_TokenNotMatured(token_.expiry());\n        token_.burn(msg.sender, amount_);\n        token_.underlying().transfer(msg.sender, amount_); **//vulnerable point, custom contract return OHM.**\n    }\n```\n\nupdated: funds are returned to OlympusDAO.\n\n---\n\nOlympusDAO confirmed the exploit on its Discord channel today. There, it stated that the attacker \u201cwas able to withdraw roughly 30K OHM ($300K)\u201d but that most of the project\u2019s other funds remained safe.",
    "images": [],
    "Lost": "$292 K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/README.md#20221021-bond-protocol---no-input-validation"
  },
  "HEALTH": {
    "type": "ERC20, Miscalculation",
    "date": "2022-10-20",
    "rootCause": "incorrect calculation.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x32B166e082993Af6598a89397E82e123ca44e74E#code#L799](https://bscscan.com/address/0x32B166e082993Af6598a89397E82e123ca44e74E#code#L799)\n\nAttacker can perform price manipulation by transferring HEALTH token 999 times to reduce HEALTH token in uniswap pair.\n\n```solidity\nfunction _transfer(address from, address to, uint256 value) private {\n        require(value <= _balances[from]);\n        require(to != address(0));\n        \n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n        if (\n            overMinTokenBalance &&\n            !inSwapAndLiquify &&\n            to == uniswapV2Pair &&\n            swapAndLiquifyEnabled\n        ) {\n            contractTokenBalance = numTokensSellToAddToLiquidity;\n            //add liquidity\n            swapAndLiquify(contractTokenBalance);\n        }\n        if (block.timestamp >= pairStartTime.add(jgTime) && pairStartTime != 0) {\n            if (from != uniswapV2Pair) {\n                uint256 burnValue = _balances[uniswapV2Pair].mul(burnFee).div(1000);  **//vulnerable point**\n                _balances[uniswapV2Pair] = _balances[uniswapV2Pair].sub(burnValue);  **//vulnerable point**\n                _balances[_burnAddress] = _balances[_burnAddress].add(burnValue);  **//vulnerable point**\n                if (block.timestamp >= pairStartTime.add(jgTime)) {\n                    pairStartTime += jgTime;\n                }\n                emit Transfer(uniswapV2Pair,_burnAddress, burnValue);\n                IPancakePair(uniswapV2Pair).sync();\n            }\n```",
    "images": [],
    "Lost": "16 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221020-health---transfer-logic-flaw"
  },
  "BEGO": {
    "type": "Insufficient validation, Metaverse",
    "date": "2022-10-20",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet:\n\n[https://www.bscscan.com/address/0xc342774492b54ce5f8ac662113ed702fc1b34972#code#L1232](https://www.bscscan.com/address/0xc342774492b54ce5f8ac662113ed702fc1b34972#code#L1232)\n\nAttacker can input empty data into _r, _s and _v to bypass all checks to mint BEGO token.\n\n```solidity\nmodifier isSigned(\n        string memory _txHash,\n        uint256 _amount,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) {\n        require(checkSignParams(_r, _s, _v), \"bad-sign-params\");\n        bytes32 _hash = keccak256(abi.encodePacked(bsc, msg.sender, _txHash, _amount));\n        address[] memory _signers = new address[](_r.length); **//vulnerable point**\n        for (uint8 i = 0; i < _r.length; i++) {\n            _signers[i] = ecrecover(_hash, _v[i], _r[i], _s[i]);\n        }\n\n        require(isSigners(_signers), \"bad-signers\");\n        _;\n    }\n\n    function isSigners(address[] memory _signers) public view returns (bool){\n        for (uint8 i = 0; i < _signers.length; i++) {  **//vulnerable point**\n            if (!_containsSigner(_signers[i])) {\n                return false;\n            }\n        }\n        return true;  // null data will return true \n    }\nfunction mint(\n        uint256 _amount,\n        string memory _txHash,\n        address _receiver,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) isSigned(_txHash, _amount, _r, _s, _v) external returns (bool){ **//trace** isSigned\n        require(!txHashes[_txHash], \"tx-hash-used\");\n        txHashes[_txHash] = true;\n\n        _mint(_receiver, _amount);\n        return true;\n    }\n```\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "12BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221020-bego---incorrect-signature-verification"
  },
  "HPAY": {
    "type": "Access Control, ERC20",
    "date": "2022-10-18",
    "rootCause": "Incorrect access control\n\nVulnerable code snippet:\n\n[https://www.bscscan.com/address/0xe9bc03ef08e991a99f1bd095a8590499931dcc30#code#F1#L174](https://www.bscscan.com/address/0xe9bc03ef08e991a99f1bd095a8590499931dcc30#code#F1#L174)\n\nDue _addre is controllable. Attacker can call setToken() to set fake token created by self.\n\n1.setToken to faketoken\n\n2.Deposit faketoken\n\n3.setToken to HPAY\n\n3.withdraw.  over\n\n```solidity\nfunction setToken(address _addr) public { **//vulnerable point**\n        configuration.stakingToken = ERC20(_addr);\n        configuration.rewardsToken = ERC20(_addr);\n    }\n```",
    "images": [],
    "Lost": "115 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221018-hpay---access-control"
  },
  "Uerii Token": {
    "type": "Access Control, ERC20",
    "date": "2022-10-17",
    "rootCause": "Incorrect access control\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x418c24191ae947a78c99fdc0e45a1f96afb254be#code#L493](https://etherscan.io/address/0x418c24191ae947a78c99fdc0e45a1f96afb254be#code#L493)\n\n```solidity\nfunction mint() public returns (bool) { **//vulnerable point**\n        _mint( msg.sender, 100000000000000000 );\n        return true;\n    }\n```",
    "images": [],
    "Lost": "$2.4 K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221017-uerii-token---access-control"
  },
  "EFLeverVault": {
    "type": "Flashloans, Insufficient validation, Yield",
    "date": "2022-10-14",
    "rootCause": "insufficient validation.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L310](https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L310)\n\n[https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L429](https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L429)\n\nAttacker can directly call Flashloan with userData \u201c0x307832\u201d which is bytes \u201c0x2\u201d from balancer and set EFLeverVault as recipient to trigger  _withdraw(loan_amount, fee_amount);  to make vault retain enough ETH. Then attacker can call withdraw to drain out the ETH in [L429](https://etherscan.io/address/0xe39fd820B58f83205Db1D9225f28105971c3D309#code#L429).\n\n```solidity\nfunction receiveFlashLoan(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        uint256[] memory feeAmounts,\n        bytes memory userData\n    ) public payable {\n        require(msg.sender == balancer, \"only flashloan vault\");\n//insufficient validation\n        uint256 loan_amount = amounts[0];\n        uint256 fee_amount = feeAmounts[0];\n\n        if (keccak256(userData) == keccak256(\"0x1\")){\n          _deposit(loan_amount, fee_amount);\n        }\n        if (keccak256(userData) == keccak256(\"0x2\")){\n          _withdraw(loan_amount, fee_amount);\n        }\n    }\n\n  //1. rapay aave with flashloaned amount,    mx\n  //2. withdraw steth with current ltv,  x\n  //3. change all steths to eths,    x         \n  //4. repay flashloan.   pay amx, left x-amx eth\n  function _withdraw(uint256 amount, uint256 fee_amount) internal{\n    uint256 steth_amount = amount.safeMul(IERC20(asteth).balanceOf(address(this))).safeDiv(getDebt());\n    if (IERC20(weth).allowance(address(this), aave) != 0) {IERC20(weth).safeApprove(aave, 0);}\n    IERC20(weth).safeApprove(aave, amount);\n\n    IAAVE(aave).repay(weth, amount, 2, address(this));\n    IAAVE(aave).withdraw(lido, steth_amount, address(this));\n\n    if (IERC20(lido).allowance(address(this), curve_pool) != 0) {IERC20(lido).safeApprove(curve_pool, 0);}\n    IERC20(lido).safeApprove(curve_pool, steth_amount);\n    ICurve(curve_pool).exchange(1, 0, steth_amount, 0);\n\n    (bool status, ) = weth.call.value(amount.safeAdd(fee_amount))(\"\");\n    require(status, \"transfer eth failed\");\n    IERC20(weth).safeTransfer(balancer, amount.safeAdd(fee_amount));\n  }\n...\nfunction withdraw(uint256 _amount) public nonReentrant{\n    require(IERC20(ef_token).balanceOf(msg.sender) >= _amount, \"not enough balance\");\n    if (is_paused){\n      uint256 to_send = address(this).balance.safeMul(_amount).safeDiv(IERC20(ef_token).totalSupply());\n      (bool status, ) = msg.sender.call.value(to_send)(\"\");\n      require(status, \"transfer eth failed\");\n      TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);\n      return;\n    }\n_earnReward();\n\n    uint256 loan_amount = getDebt().safeMul(_amount).safeDiv(IERC20(ef_token).totalSupply());\n    \n    address[] memory tokens = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    bytes memory userData = \"0x2\";\n    tokens[0] = weth;\n    amounts[0] = loan_amount;\n    //uint256 user_eth_before = msg.sender.balance;\n    IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);\n\t   // call flashloan first to make vault retain enough ETH.\n    uint256 to_send = address(this).balance;  //vulnerable point\n    (bool status, ) = msg.sender.call.value(to_send)(\"\");  **//vulnerable point**\n    require(status, \"transfer eth failed\");\n\n    TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);\n    emit CFFWithdraw(msg.sender, to_send, _amount, getVirtualPrice());\n  }\n```",
    "images": [],
    "Lost": "750 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221014-eflevervault---verify-flashloan-callback"
  },
  "MEVBOTa47b": {
    "type": "Flashloans, Insufficient validation, MEV",
    "date": "2022-10-14",
    "rootCause": "insufficient validation.\n\nMEVBot - Unverified contract: [https://etherscan.io/address/0x00000000000a47b1298f18cf67de547bbe0d723f](https://etherscan.io/address/0x00000000000a47b1298f18cf67de547bbe0d723f)\n\nCheck:\n\n[https://twitter.com/BlockSecTeam/status/1580779311862190080](https://twitter.com/BlockSecTeam/status/1580779311862190080)\n\nAttacker can input arbritary data combine in userDate.\n\n\n\n",
    "images": [
      "images/%25E6%2588%25AA%25E5%259C%2596_2022-10-20_%25E4%25B8%258A%25E5%258D%25889_59_29.png",
      "images/%25E6%2588%25AA%25E5%259C%2596_2022-10-20_%25E4%25B8%258A%25E5%258D%25889_58_18.png"
    ],
    "Lost": "$241 k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221014-mevbota47b---mevbot-a47b"
  },
  "ATK": {
    "type": "ERC20",
    "date": "2022-10-12",
    "rootCause": "Insecure use balanceOf to calculate price is vulnerable to price manipulation over flash loan.\n\nThe calim Function use getPrice() in ASK Token Contract\n\nVulnerable code snippet:\n\nIncorrect price calculation via balanceOf.\n\n```solidity\nfunction getPrice() public view returns(uint256){\n        uint256 UDPrice;\n        uint256 UDAmount  = balanceOf(_uniswapV2Pair); **//vulnerable point**\n        uint256 USDTAmount = USDT.balanceOf(_uniswapV2Pair); **//vulnerable point**\n        UDPrice = UDAmount.mul(10**18).div(USDTAmount);\n        return UDPrice;\n```\n\n",
    "images": [
      "images/ADC_getPrice.png"
    ],
    "Lost": "$127 k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221012-atk---flashloan-manipulate-price"
  },
  "Rabby Wallet SwapRouter": {
    "type": "Arbitrary call, swap",
    "date": "2022-10-11",
    "rootCause": "arbitrary external call vulnerability.\n\nSince data is controllable by an attacker, so he can perform arbitrary external calls via functionCallWithValue. In this incident, the attacker sends funds out over transferfrom function.\n\n\n\nSource code: [https://github.com/RabbyHub/Rabby/blob/1860bdd69da09292171457cb08bfd4a0bf89617d/docs/PeckShield-Audit-Report-RabbyRouter-v1.0.pdf](https://github.com/RabbyHub/Rabby/blob/1860bdd69da09292171457cb08bfd4a0bf89617d/docs/PeckShield-Audit-Report-RabbyRouter-v1.0.pdf)\n\nCheck:\n\n[https://twitter.com/1nf0s3cpt/status/1579844213562576897](https://twitter.com/1nf0s3cpt/status/1579844213562576897)",
    "images": [
      "images/%25E6%2588%25AA%25E5%259C%2596_2022-10-26_%25E4%25B8%258B%25E5%258D%25883.54.03.png"
    ],
    "Lost": "$200,000",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221011-rabby-wallet-swaprouter---arbitrary-external-call-vulnerability"
  },
  "Templedao": {
    "type": "Access Control, Yield",
    "date": "2022-10-11",
    "rootCause": "insufficient access control to the migrateStake function.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xd2869042e12a3506100af1d192b5b04d65137941#code#F1#L241](https://etherscan.io/address/0xd2869042e12a3506100af1d192b5b04d65137941#code#F1#L241)\n\n```solidity\n/**\n      * @notice For migrations to a new staking contract:\n      *         1. User/DApp checks if the user has a balance in the `oldStakingContract`\n      *         2. If yes, user calls this function `newStakingContract.migrateStake(oldStakingContract, balance)`\n      *         3. Staking balances are migrated to the new contract, user will start to earn rewards in the new contract.\n      *         4. Any claimable rewards in the old contract are sent directly to the user's wallet.\n      * @param oldStaking The old staking contract funds are being migrated from.\n      * @param amount The amount to migrate - generally this would be the staker's balance\n      */\n    function migrateStake(address oldStaking, uint256 amount) external {. **//vulnerable point**\n        StaxLPStaking(oldStaking).migrateWithdraw(msg.sender, amount);\n        _applyStake(msg.sender, amount);\n    }\n```",
    "images": [],
    "Lost": "$2.3 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221011-templedao---insufficient-access-control"
  },
  "Carrot": {
    "type": "Arbitrary call, Yield",
    "date": "2022-10-10",
    "rootCause": "public function call, call transferowner 0xbf699b4b. All wallets granted approvals are impacted.\n\nStep1, transReward to set owner.\n\nStep2, transferFrom. \n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xcFF086EaD392CcB39C49eCda8C974ad5238452aC#code#L1406](https://bscscan.com/address/0xcFF086EaD392CcB39C49eCda8C974ad5238452aC#code#L1406)\n\n```solidity\nfunction transReward(bytes memory data) public { //data is controllable\n        pool.functionCall(data); **//vulnerable point**\n    }\n```\n\nPool contract: 0x6863b549bf730863157318df4496ed111adfa64f\n\n\n\n---\n\n\n\nREF: [https://twitter.com/1nf0s3cpt/status/1580116116151889920](https://twitter.com/1nf0s3cpt/status/1580116116151889920)",
    "images": [
      "images/Incorrect_changeowner.png",
      "images/Incorrect_POC.png"
    ],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221010-carrot---public-functioncall"
  },
  "Xave Finance": {
    "type": "Governance, MaliciosProposal",
    "date": "2022-10-09",
    "rootCause": "",
    "images": [
      "images/DaoModule_22.png"
    ],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221009-xave-finance---malicious-proposal-mint--transfer-ownership"
  },
  "Transit Swap": {
    "type": "Dex/AMM, Insufficient validation",
    "date": "2022-10-02",
    "rootCause": "Incorrect owner address validation\n\nVulnerable code snippet:\n\n1.You can input any innocent user who granted approvals to \"0xed1afc8c4604958c2f38a3408fa63b32e737c428\" before.\n\n2.Contract \"0xed1afc8c4604958c2f38a3408fa63b32e737c428\" will perform transferFrom to transfer amount of innocent user to attacker.\n\n3.\n\n\"function\": \"claimTokens(address token,address from,address to,uint256 amount)\",\n\"params\": [        \"0x55d398326f99059fF775485246999027B3197955\",\"0x1aAe0303f795b6FCb185ea9526Aa0549963319Fc\",\n0x75F2abA6a44580D7be2C4e42885D4a1917bFFD46\",\n\"6312858905558909501615\"]\n\n4. No owner address validation\n\nDecompiled contract 0xed1afc8c4604958c2f38a3408fa63b32e737c428\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$21 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221002-transit-swap---incorrect-owner-address-validation"
  },
  "BabySwap": {
    "type": "Dex/AMM, Insufficient validation",
    "date": "2022-10-01",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x5c9f1A9CeD41cCC5DcecDa5AFC317b72f1e49636#code#F4#L236](https://bscscan.com/address/0x5c9f1A9CeD41cCC5DcecDa5AFC317b72f1e49636#code#F4#L236)\n\n[https://bscscan.com/address/0x8317c460c22a9958c27b4b6403b98d2ef4e2ad32#code#F14#L89](https://bscscan.com/address/0x8317c460c22a9958c27b4b6403b98d2ef4e2ad32#code#F14#L89)\n\nAttacker created fake factory contract to get real reward tokens.\n\n```solidity\nfunction swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] memory path,\n        address[] memory factories,\n        uint[] memory fees,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = BabyLibrarySmartRouter.getAggregationAmountsOut(factories, fees, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'BabyRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        amounts[0] = routerFee(factories[0], msg.sender, path[0], amounts[0]);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, BabyLibrarySmartRouter.pairFor(factories[0], path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, factories, to); **//vulnerable point -** Insufficient validation\n    }\n```\n\n```solidity\n// swapMining only router\n    function swap(address account, address input, address output, uint256 amount) public onlyRouter returns (bool) {\n        require(account != address(0), \"SwapMining: taker swap account is the zero address\");\n        require(input != address(0), \"SwapMining: taker swap input is the zero address\");\n        require(output != address(0), \"SwapMining: taker swap output is the zero address\");\n\n        if (poolLength() <= 0) {\n            return false;\n        }\n\n        if (!isWhitelist(input) || !isWhitelist(output)) {\n            return false;\n        }\n\n        address pair = BabyLibrary.pairFor(address(factory), input, output);\n        PoolInfo storage pool = poolInfo[pairOfPid[pair]];\n        // If it does not exist or the allocPoint is 0 then return\n        if (pool.pair != pair || pool.allocPoint <= 0) {\n            return false;\n        }\n\n        uint256 quantity = getQuantity(output, amount, targetToken);\n        if (quantity <= 0) {\n            return false;\n        }\n\n        mint(pairOfPid[pair]);\n\n        pool.quantity = pool.quantity.add(quantity);\n        pool.totalQuantity = pool.totalQuantity.add(quantity);\n        UserInfo storage user = userInfo[pairOfPid[pair]][account];\n        user.quantity = user.quantity.add(quantity);\n        user.blockNumber = block.number;\n        return true;\n    }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-babyswap---parameter-access-control"
  },
  "RL Token": {
    "type": "ERC20, Flashloans",
    "date": "2022-10-01",
    "rootCause": "Incorrect Reward calculation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888#code#F1#L129](https://bscscan.com/address/0x4bbfae575dd47bcfd5770ab4bc54eb83db088888#code#F1#L129)\n\nCustom transferFrom function\n\n```solidity\nfunction transferFrom( \n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) { \n        if (from != address(pancakeSwapV2Pair) && from != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(from);\n        }\n        if (to != address(pancakeSwapV2Pair) && to != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(to); **//trace function**\n        }\n        if (msg.sender != address(pancakeSwapV2Pair) && msg.sender != address(pancakeSwapV2Router)) {\n            incentive.distributeAirdrop(msg.sender); **//trace function**\n        }\n        require(allowance(from, msg.sender) >= amount, \"insufficient allowance\");\n        if (govIDO != address(0)) {\n            if (IKBKGovIDO(govIDO).isPriSaler(from)) {\n                IKBKGovIDO(govIDO).releasePriSale(from);\n            }\n            if (IKBKGovIDO(govIDO).isPriSaler(to)) {\n                IKBKGovIDO(govIDO).releasePriSale(to);\n            }\n        }\n        //sell\n        if (to == address(pancakeSwapV2Pair) && msg.sender == address(pancakeSwapV2Router)) {\n            if (!isCommunityAddress[from]) {\n                uint burnAmt = amount / 100;\n                _burn(from, burnAmt);\n                uint slideAmt = amount * 2 / 100;\n                _transfer(from, slideReceiver, slideAmt);\n                amount -= (burnAmt + slideAmt);\n            }\n        } else {\n            if (!isCommunityAddress[from] && !isCommunityAddress[to]) {\n                uint burnAmt = amount / 100;\n                amount -= burnAmt;\n                _burn(from, burnAmt);\n            }\n        }\n        return super.transferFrom(from, to, amount);\n    }\n```\n\n[https://bscscan.com/address/0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666#code#F1#L49](https://bscscan.com/address/0x335ddcE3f07b0bdaFc03F56c1b30D3b269366666#code#F1#L49)\n\n```solidity\nfunction distributeAirdrop(address user) public override {\n        if (block.timestamp < airdropStartTime) {\n            return;\n        }\n        updateIndex();\n        uint256 rewards = getUserUnclaimedRewards(user); **//vulnerable point**\n        usersIndex[user] = globalAirdropInfo.index;\n        if (rewards > 0) {\n            uint256 bal = rewardToken.balanceOf(address(this));\n            if (bal >= rewards) {\n                rewardToken.transfer(user, rewards);\n                userUnclaimedRewards[user] = 0;\n            }\n        }\n    }\nfunction getUserUnclaimedRewards(address user) public view returns (uint256) {\n        if (block.timestamp < airdropStartTime) {\n            return 0;\n        }\n        (uint256 newIndex,) = getNewIndex();\n        uint256 userIndex = usersIndex[user];\n        if (userIndex >= newIndex || userIndex == 0) {\n            return userUnclaimedRewards[user];\n        } else {\n\t\t\t\t**//vulnerable point**, Incorrect Reward calculation. only check balanceof of user without any requirement.\n            return userUnclaimedRewards[user] + (newIndex - userIndex) * lpToken.balanceOf(user) / PRECISION;\n        }\n    }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-RL-Token---Incorrect-Reward-calculation"
  },
  "Thunder Brawl": {
    "type": "ERC721, Reentrancy",
    "date": "2022-10-01",
    "rootCause": "claimReward() - rewards are being drained due to a reentrancy bug.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xae191Ca19F0f8E21d754c6CAb99107eD62B6fe53#code#L252](https://bscscan.com/address/0xae191Ca19F0f8E21d754c6CAb99107eD62B6fe53#code#L252)\n\n[https://bscscan.com/address/0x72e901f1bb2bfa2339326dfb90c5cec911e2ba3c#code#L1536](https://bscscan.com/address/0x72e901f1bb2bfa2339326dfb90c5cec911e2ba3c#code#L1536)\n\n---\n\n```solidity\nfunction claimReward(\n        uint256 _ID,\n        address payable _player,\n        uint256 _amount,\n        bool _rewardStatus,\n        uint256 _x,\n        string memory name,\n        address _add\n    ) external {\n        require(gameMode);\n        bool checkValidity = guess(_x, name, _add);\n\n        if (checkValidity == true) {\n            if (winners[_ID][_player] == _amount) {\n                _player.transfer(_amount * 2);\n                if (_rewardStatus == true) {\n                    sendReward(); **//vulnerable point**\n                }\n                delete winners[_ID][_player];\n            } else {\n                if (_rewardStatus == true) {\n                    sendRewardDys();\n                }\n            }\n            rewardStatus = false;\n        }\n    }\nfunction sendReward() public {\n        thunderbrawlRoulette.reward(msg.sender, 1);\n    }\n```\n\n```jsx\nfunction reward(address to,uint256 _mintAmount) external {\n        uint256 supply = totalSupply();\n        uint256 rewardSupply = rewardTotal;\n        require(rewardSupply <= rewardSize,\"\");\n        for (uint256 i = 1; i <= _mintAmount; i++) {          \n          _safeMint(to, supply + i); \n          rewardTotal++;         \n        }\n  }\n/**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data), **//callback** \n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n```\n\n![1.png](images/Reentrancy%20in%20claimReward()%201993bab05ffe48ccbc707af915e70f59/1.png)",
    "images": [
      "images/Reentrancy%20in%20claimReward("
    ],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-thunder-brawl---reentrancy"
  },
  "BXH": {
    "type": "Dex/AMM, Flashloans, lending",
    "date": "2022-09-28",
    "rootCause": "Incorrect Reward calculation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x27539b1dee647b38e1b987c41c5336b1a8dce663#code#L1606](https://bscscan.com/address/0x27539b1dee647b38e1b987c41c5336b1a8dce663#code#L1606)\n\nIncorrect use of getReserves() to get amount of balance in the pool to calculate bonus via getAmountOut()\n\n```solidity\nfunction getITokenBonusAmount( uint256 _pid, uint256 _amountInToken ) public view returns (uint256){\n        PoolInfo storage pool = poolInfo[_pid];\n\n        (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(pool.swapPairAddress).getReserves(); **//vulnerable point**\n        uint256 amountTokenOut = 0; \n        uint256 _fee = 0;\n        if(IUniswapV2Pair(pool.swapPairAddress).token0() == address(iToken)){\n            amountTokenOut = getAmountOut( _amountInToken , _reserve0, _reserve1, _fee); **//vulnerable point**\n        } else {\n            amountTokenOut = getAmountOut( _amountInToken , _reserve1, _reserve0, _fee); **//vulnerable point**\n        }\n        return amountTokenOut;\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint256 feeFactor) private pure returns (uint ) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n\n        uint256 feeBase = 10000;\n\n        uint amountInWithFee = amountIn.mul(feeBase.sub(feeFactor));\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(feeBase).add(amountInWithFee);\n        uint amountOut = numerator / denominator;\n        return amountOut;\n    }\n```",
    "images": [],
    "Lost": "$40,305",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220928-bxh---flashloan--price-oracle-manipulation"
  },
  "RADT-DAO": {
    "type": "ERC20, Flashloans",
    "date": "2022-09-23",
    "rootCause": "front running\n\nREF: [https://twitter.com/BlockSecTeam/status/1573252869322846209](https://twitter.com/BlockSecTeam/status/1573252869322846209)\n\n1. Borrow USDT via flashloan\n2. Partially swap USDT for RADT-DAO token in the Pancake pool\n3. Trigger the fallback function of the RADT-DAO contract to transfer the remaining RADT-DAO in the Pancake pool\n4. Swap RADT-DAO (from Step 2) for USDT\n5. Return the flashloan",
    "images": [],
    "Lost": "$94,304",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220923-RADT-DAO---pair-manipulate"
  },
  "MevBot private tx": {
    "type": "Access Control, MEV",
    "date": "2022-09-13",
    "rootCause": "Incorrect access control.\n\nVulnerable code snippet:\n\nWe can see a public function called pancakeCall, which means anyone can call this function.\n\n1) Decompile contract\n\n[https://bscscan.com/address/0x64dd59d6c7f09dc05b472ce5cb961b6e10106e1d](https://bscscan.com/address/0x64dd59d6c7f09dc05b472ce5cb961b6e10106e1d)\nWe can see a public function called pancakeCall, which means anyone can call this function.\n\n\n\n2)Check pancakeCall code logic\nOnce pass all required check then perform 0x10a(v0, varg2, varg1);\n\n3) Track into 0x10a(), we can see transfer funds to addree \"MEM[varg0.data+32]\". Since variable \"[http://varg0.data](https://t.co/KT6EufOI6Z)\" attacker can control over calldata in pancakeCall. So that's why an attacker can drain out the funds from the MEV contract.\n\n```jsx\nfunction 0x10a(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg0.data + varg0.length - varg0.data >= 96);\n    require(MEM[varg0.data] == address(MEM[varg0.data]));\n    v0 = v1 = MEM[varg0.data + 64];\n    if (0 == varg2) {\n        v2, v3 = msg.sender.token1().gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v3 == address(v3));\n        goto 0x214;\n    } else {\n        v4, v3 = msg.sender.token0().gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v3 == address(v3));\n    }\n    if (varg2) {\n    }\n    v5, v6 = address(v3).transfer(address(MEM[varg0.data]), varg1).gas(msg.gas);  **//vulnerable point**\n\n}\n```",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$140 K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220913-mevbot-private-tx"
  },
  "DPC": {
    "type": "ERC20, Miscalculation",
    "date": "2022-09-09",
    "rootCause": "Incorrect Reward calculation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xB75cA3C3e99747d0e2F6e75A9fBD17F5Ac03cebE#code#L1232](https://bscscan.com/address/0xB75cA3C3e99747d0e2F6e75A9fBD17F5Ac03cebE#code#L1232)\n\nTo increase the reward by calling the claimStakeLp function in the contract. The reward calculated in the function claimStakeLp() is the accumulation of the previous reward and the reward calculated by getClaimQuota().\n\n```solidity\nfunction claimStakeLp(address _from ,uint256 Amountwei) public {\n                require(Amountwei > 0,\"Quantity error\");\n                require(_from==msg.sender,\"error\");\n                require(dpcLp[_from] >= Amountwei ,\"Insufficient authorization limit\");\n                IERC20(LpContract).transfer(_from,Amountwei);\n\n                oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from)); **//vulnerable point**\n\n                dpcLp[_from] = dpcLp[_from].sub(Amountwei);\n\n                time=currTimeStamp();\n                dpcLpTime[_from] = time;\n\n                dpcLpTotal = dpcLpTotal.sub(Amountwei);\n        \n         }\n\nfunction getClaimQuota(address addr) public view returns (uint256) {\n                uint256 ClaimQuota;\n               if(dpcAirdrop[addr] > 0 && dpcLp[addr]>0){\n                    uint256 QuotastartTime;\n                    uint256 limit = 50 * 10**18;\n                    uint256 LpQuotaNum = dpcLp[addr].mul(getLpPrice()).mul(lpQuota).div(100);\n                    uint256 secondQuota;\n                    if(getDpcPrice()>0){\n                        secondQuota = LpQuotaNum.div(24*60*60).div(getDpcPrice());\n                    }\n\n                    uint256 limitSecondQuota = limit.div(24*60*60);\n                    if(secondQuota > limitSecondQuota){\n                        secondQuota = limitSecondQuota;\n                    }\n                    uint256 nowTime = currTimeStamp();\n\n                    if(dpcLpTime[addr]>ClaimQuotaTime[addr]){\n                        QuotastartTime = dpcLpTime[addr];\n                    }else{\n                        QuotastartTime = ClaimQuotaTime[addr];\n                    }\n                    ClaimQuota = (nowTime.sub(QuotastartTime)).mul(secondQuota);\n                    if(ClaimQuota > dpcAirdrop[addr]){\n                        ClaimQuota = dpcAirdrop[addr];\n                    }\n               }else{\n                    ClaimQuota = 0;\n               }\n               ClaimQuota = ClaimQuota.add(oldClaimQuota[addr]); **//vulnerable point**\n\n               return ClaimQuota;\n        \n         }\n```",
    "images": [],
    "Lost": "$1.4 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220910-dpc---Incorrect-Reward-calculation"
  },
  "YYDS": {
    "type": "ERC20, Flashloans, Reward",
    "date": "2022-09-08",
    "rootCause": "Calculation of reward being too simple and only depends on the pool reserve by balanceOf.\n\nVulnerable contract (unverified): 0xe70cdd37667cddf52cabf3edabe377c58fae99e9\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$742,286",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220909-YYDS---pair-manipulate"
  },
  "Ragnarok Online Invasion": {
    "type": "Deflationary token, Flashloans",
    "date": "2022-09-08",
    "rootCause": "Incorrect access control\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xe48b75dc1b131fd3a8364b0580f76efd04cf6e9c#code#L185](https://bscscan.com/address/0xe48b75dc1b131fd3a8364b0580f76efd04cf6e9c#code#L185)\n\n```solidity\nfunction transferOwnership(address newOwner) public virtual {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n```\n\n---\n\n*deflationary token pattern*\n\n```solidity\n\t\t\t\tROI.transferOwnership(address(this));   **//vulnerable point -** Broken Access Control\n        ROI.setTaxFeePercent(0);\n        ROI.setBuyFee(0, 0);\n        ROI.setSellFee(0, 0);\n        ROI.setLiquidityFeePercent(0);\n```",
    "images": [],
    "Lost": "$44,000",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220908-ragnarok-online-invasion---broken-access-control"
  },
  "NewFreeDAO": {
    "type": "ERC20, Flashloans, Reward",
    "date": "2022-09-08",
    "rootCause": "Incorrect reward calculation\n\nVulnerable code snippet: need to decompile\n\n[https://bscscan.com/address/0x8b068e22e9a4a9bca3c321e0ec428abf32691d1e](https://bscscan.com/address/0x8b068e22e9a4a9bca3c321e0ec428abf32691d1e)\n\nReward calcuates by the caller's NFD token balance and transfers the reward to caller.\n\n```solidity\nfunction 0x6811e3b9() public nonPayable { \n    require(_isAirAddr.code.size);\n    v0, v1 = _isAirAddr.balanceOf(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 > 0, 'Amount can not be Zero');\n    if (owner_d[msg.sender] <= 0) {\n        owner_d[msg.sender] = stor_6;\n    }\n    v2 = _SafeDiv(stor_8, block.timestamp - owner_d[msg.sender]);\n    require(v2 > 0, 'The collection time was not reached');\n    v3 = v4 = 0;\n    if (block.timestamp > stor_7) { //vulnerable point\n        if (v2 > 0) {\n            v5 = 0x3182(stor_b, v1);\n            v3 = v6 = _SafeDiv(0xf4240, v5);\n        }\n    } else if (v2 > 0) { **//vulnerable point**\n        v7 = 0x3182(stor_b, v1);\n        v8 = 0x3182(v2, v7);\n        v3 = v9 = _SafeDiv(0xf4240, v8);\n    }\n    require(_isAirAddr.code.size);\n    v10, v11 = _isAirAddr.transfer(msg.sender, v3).gas(msg.gas);\n    require(v10); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    owner_d[msg.sender] = block.timestamp;\n}\n```",
    "images": [],
    "Lost": "$125M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220908-newfreedao---flashloans-attack"
  },
  "NXUSD": {
    "type": "ERC20, Flashloans",
    "date": "2022-09-06",
    "rootCause": "Incorrect price calculation \n\nVulnerable code snippet: \n\n[https://snowtrace.io/address/0xf955a6694c6f5629f5ecd514094b3bd450b59000#code#F1#L21](https://snowtrace.io/address/0xf955a6694c6f5629f5ecd514094b3bd450b59000#code#F1#L21)\n\nprice calculation was based on the current wAvaxReserve price, usdcReserve price, and totalSupply taken on-chain from the TraderJoe Pool\n\nAn exploiter was able to deploy a custom smart contract and that leveraged a $51M flash loan to manipulate the AVAX/USDC Trader Joe LP pool price for a single block resulting in the ability for the exploiter to mint 998,000NXUSD against ~$508k worth of collateral.\n\nLP price = (**wavaxReserve** * avaxPrice + **usdcReserve** * usdcPrice) / totalSupply\n\n```solidity\nfunction _get() internal view returns (uint256) {\n\n        uint256 usdcPrice = uint256(USDC.latestAnswer());\n        uint256 avaxPrice = uint256(AVAX.latestAnswer());\n        (uint112 wavaxReserve, uint112 usdcReserve, ) = joePair.getReserves();\n\t\t\t\t//vulnerable point\n        uint256 price = (wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply()); **//vulnerable point**\n\n        return 1e26 / price;\n    }\n```\n\n**Will this happen again?**\n\nNo,\n going forward TWAP calculations will be implemented along with other \nupgrades to pricing feeds for collateral assets that do not have \nChainlink oracles. In addition, all other markets in the NXUSD protocol \nare based on Chainlink oracles except for the price of avCRV which is \nprovided through the virtual price as well as support from Chainlink \noracles for each underlying token (USDC, DAI, USDT).",
    "images": [],
    "Lost": "$50,000",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220906-NXUSD---flashloan-price-oracle-manipulation"
  },
  "ZoomproFinance": {
    "type": "Flashloans, Insufficient validation",
    "date": "2022-09-05",
    "rootCause": "Insufficient validation\n\nAttacker uss fake usdt in zoom pair to trick protocol.\n\nVulnerable code snippet: \n\nunverified contract\n\n[https://bscscan.com/address/0x47391071824569F29381DFEaf2f1b47A4004933B#code](https://bscscan.com/address/0x47391071824569F29381DFEaf2f1b47A4004933B#code)\n\n---\n\nImage from blocksec:\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$61,160 USDT",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220905-zoomprofinance---flashloans--price-manipulation"
  },
  "ShadowFi": {
    "type": "Access Control, payment",
    "date": "2022-09-02",
    "rootCause": "incorrect access control.\n\nVulnerable code snippet: \n\nDue to the public access of burn() method, an attacker burned 10.3M SDF in the pair and then sync'd the price.\n\nThen they swap 8.4 SDF for 1078 BNB (~$298.2K) and transfer to tornato\n\n```solidity\nfunction burn(address account, uint256 _amount) public { **//vulnerable point**\n        _transferFrom(account, DEAD, _amount);\n\n        emit burnTokens(account, _amount);\n    }\n```",
    "images": [],
    "Lost": "1,078 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220902-shadowfi---access-control"
  },
  "Bad Guys by RPF": {
    "type": "Insufficient validation, NFT",
    "date": "2022-09-02",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet: \n\n[https://etherscan.io/address/0xb84cbaf116eb90fd445dd5aeadfab3e807d2cbac?utm_source=icy.tools#code#L1190](https://etherscan.io/address/0xb84cbaf116eb90fd445dd5aeadfab3e807d2cbac?utm_source=icy.tools#code#L1190)\n\nMissing check for \"chosenAmount\" in the WhiteListMint function which allowed the attacker to pass the number of NFTs he/she wanted to mint.\n\n```solidity\nfunction WhiteListMint(bytes32[] calldata _merkleProof, uint256 chosenAmount)\n        public\n    {\n        require(_numberMinted(msg.sender)<1, \"Already Claimed\");\n        require(isPaused == false, \"turn on minting\");\n        require(\n            chosenAmount > 0,\n            \"Number Of Tokens Can Not Be Less Than Or Equal To 0\"\n        );\n        require(\n            totalSupply() + chosenAmount <= maxsupply - reserve,\n            \"all tokens have been minted\"\n        );\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_merkleProof, rootHash, leaf),\n            \"Invalid Proof\"\n        );\n        _safeMint(msg.sender, chosenAmount); **//vulnerable point**\n    }\n```\n\n---",
    "images": [],
    "Lost": "400 NFTs",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220902-bad-guys-by-rpf---business-logic-flaw--missing-check-for-number-of-nft-to-mint"
  },
  "DDCoin": {
    "type": "Access Control, Flashloans",
    "date": "2023-06-01",
    "rootCause": "Vulnerable code snippet:\n\n```solidity\nfunction listItem(uint256 _amount,address invite) external  returns (uint256)  {\n        require(_amount % amount_double_buy == 0 && _amount > 0 && _amount <= amount_max_buy,\"Illegal amount \");  \n        bool flag = (inviter[msg.sender] != address(0) || (invite != msg.sender && invite != address(0) && inviter[invite] != address(0)));\n        require(flag ,\"The recommender does not exist\");\n        require(getOrderByDay() < amount_max_count_day, \"Only one order can be placed within  hours\");\n        if(per_up_price == 0){\n            addItem(_amount);\n        }else{\n            if(_amount + total_buy_coin - prev_up_amount < per_amount_price){\n                addItem(_amount);\n            }else{\n                uint256 clac_amount = _amount;\n                while(clac_amount > 0){\n                    uint256 buy = prev_up_amount + per_amount_price - total_buy_coin;\n                    if(buy > clac_amount){\n                        addItem(clac_amount);\n                        break ;\n                    }else{\n                        addItem(buy);\n                        prev_up_amount += per_amount_price;\n                        new_price += per_up_price;\n                        clac_amount -= buy;\n                    }   \n                }\n            }\n        }\n        if(inviter[msg.sender] == address(0)){    \n            inviter[msg.sender] = invite;\n        }\n        caclInviteLimit(_amount*limit_scale/100 -_amount);\n        usdt.transferFrom(msg.sender, address(this), _amount);\n        emit ItemListed(msg.sender, _amount, new_price/100);\n        return total_buy_coin;\n    }\n```\n\nAttack tx:\n\nhttps://bscscan.com/tx/0xd92bf51b9bf464420e1261cfcd8b291ee05d5fbffbfbb316ec95131779f80809\n\nAnalysis:",
    "images": [],
    "Lost": "$300k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/DDCoin_exp.sol"
  },
  "XSTABLE Protocol": {
    "type": "Flashloans, Reward, Stablecoin",
    "date": "2022-08-10",
    "rootCause": "Incorrect Logic Check, get rewards over skim()\n\nVulnerable code snippet: \n\n[https://etherscan.io/address/0xb276647e70cb3b81a1ca302cf8de280ff0ce5799#code#F5#L208](https://etherscan.io/address/0xb276647e70cb3b81a1ca302cf8de280ff0ce5799#code#F5#L208)\n\ntransfer more XST token to pair, to get more XST token.\n\n```jsx\nfunction _getTxType(address sender, address recipient, bool lpBurn) private returns(uint256) {\n        uint256 txType = 2;\n        if (isSupportedPool(sender)) {\n            if (lpBurn) {\n                txType = 3;\n            } else {\n                **txType = 1;   //**return \n            }\n        } else if (sender == Constants.getRouterAdd()) {\n            txType = 3;\n        }\n        return txType;\n    }\n\nfunction _transfer(address sender, address recipient, uint256 amount) private pausable {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(amount <= balanceOf(sender),\"Amount exceeds balance\");\n        require(amount <= unlockedBalanceOf(sender),\"Amount exceeds unlocked balance\");\n        require(isPresaleDone(),\"Presale yet to close\");\n        if (now > getCurrentEpoch().add(Constants.getEpochLength())) updateEpoch();\n        uint256 currentFactor = getFactor();\n        uint256 largeAmount = amount.mul(currentFactor);\n        uint256 txType;\n        if (isTaxLess()) {\n            txType = 3;\n        } else {\n            bool lpBurn;\n            if (isSupportedPool(sender)) {\n                lpBurn = syncPair(sender);\n            } else if (isSupportedPool(recipient)){\n                silentSyncPair(recipient);\n            } else {\n                silentSyncPair(_mainPool);\n            }\n            txType = _getTxType(sender, recipient, lpBurn);\n        }\n        // Buy Transaction from supported pools - requires mint, no utility fee\n        if (txType == 1) {\n            _implementBuy(sender, recipient, amount, largeAmount, currentFactor);  **//vulnerable point**\n        }\n        // Sells to supported pools or unsupported transfer - requires exit burn and utility fee\n        else if (txType == 2) {\n            _implementSell(sender, recipient, amount, largeAmount, currentFactor);\n        } \n        // Add Liquidity via interface or Remove Liquidity Transaction to supported pools - no fee of any sort\n        else if (txType == 3) {\n            _largeBalances[sender] = _largeBalances[sender].sub(largeAmount);\n            _largeBalances[recipient] = _largeBalances[recipient].add(largeAmount);\n            emit Transfer(sender, recipient, amount);\n        }\n    }\n```\n\n---",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220810-xstable-protocol---incorrect-logic-check"
  },
  "ANCH": {
    "type": "ERC20, Flashloans, Insufficient validation, Reward",
    "date": "2022-08-09",
    "rootCause": "insufficient validation , get rewards over skim()\n\nVulnerable code snippet: \n\n[https://www.bscscan.com/address/0xa4f5d4afd6b9226b3004dd276a9f778eb75f2e9e#code#L764](https://www.bscscan.com/address/0xa4f5d4afd6b9226b3004dd276a9f778eb75f2e9e#code#L764)\n\n```jsx\n//this method is responsible for taking all fee, if takeFee is true\n    function _transfer( **//vulnerable point -** recipient and sender can the same\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(tAmount > 0, \"Transfer amount must be greater than zero\");\n        // Insufficient validation. sender and recipient can be same.\n        \n\t\tif(sender == uniswapV2Pair) {\n            _tokenBuyTransferReward(sender, recipient, tAmount);\n        } else if(recipient == uniswapV2Pair) {\n            _tokenSellTransferReward(sender, recipient, tAmount);\n        } else{\n\n            uint256 currentRate = _getRate();\n            uint256 rAmount = tAmount.mul(currentRate);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rOwned[recipient] = _rOwned[recipient].add(rAmount);\n            \n            emit Transfer(sender, recipient, tAmount);\n        }\n```\n\n---\n\n[https://twitter.com/AnciliaInc/status/1557527183966408706](https://twitter.com/AnciliaInc/status/1557527183966408706)\n\nif it supports skim(), the token transfer does not check if recipient and sender are the same, any reward, factor and balance change in _transfer() function, then you are vulnerable for the attack.\n\nThe wild attack is on fire.\n\n[$UPS](https://twitter.com/search?q=%24UPS&src=cashtag_click)\n\n[$ANCH](https://twitter.com/search?q=%24ANCH&src=cashtag_click)\n\n[$XST](https://twitter.com/search?q=%24XST&src=cashtag_click)",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220809-anch---skim-token-balance"
  },
  "EGD Finance": {
    "type": "Dex/AMM, Flashloans",
    "date": "2022-08-07",
    "rootCause": "Incorrect price calculation by balanceOf\n\nVulnerable code snippet: \n\n[https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code#F1#L254](https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code#F1#L254)\n\n```jsx\nfunction claimAllReward() external {\n        require(userInfo[msg.sender].userStakeList.length > 0, 'no stake');\n        require(!black[msg.sender],'black');\n        uint[] storage list = userInfo[msg.sender].userStakeList;\n        uint rew;\n        uint outAmount;\n        uint range = list.length;\n        for (uint i = 0; i < range; i++) {\n            UserSlot storage info = userSlot[msg.sender][list[i - outAmount]];\n            require(info.totalQuota != 0, 'wrong index');\n            uint quota = (block.timestamp - info.claimTime) * info.rates;\n            if (quota >= info.leftQuota) {\n                quota = info.leftQuota;\n            }\n            rew += quota * 1e18 / getEGDPrice(); // check getEGDPrice()\n            info.claimTime = block.timestamp;\n            info.leftQuota -= quota;\n            info.claimedQuota += quota;\n            if (info.leftQuota == 0) {\n                userInfo[msg.sender].totalAmount -= info.totalQuota;\n                delete userSlot[msg.sender][list[i - outAmount]];\n                list[i - outAmount] = list[list.length - 1];\n                list.pop();\n                outAmount ++;\n            }\n        }\nfunction getEGDPrice() public view returns (uint){\n        uint balance1 = EGD.balanceOf(pair);  **//vulnerable point**\n        uint balance2 = U.balanceOf(pair);    **//vulnerable point**\n        return (balance2 * 1e18 / balance1);\n    }\n```",
    "images": [],
    "Lost": "$36,044",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220807-egd-finance---flashloans--price-manipulation"
  },
  "Nomad Bridge": {
    "type": "Bridge, Insufficient validation, uninitialized",
    "date": "2022-08-02",
    "rootCause": "business Logic Flaw, Incorrect acceptable merkle-root checks\n\nNomad team initialized the trusted root to be 0x00.\n\nVulnerable code snippet: \n\n[https://etherscan.io/address/0xb92336759618f55bd0f8313bd843604592e27bd8#code](https://etherscan.io/address/0xb92336759618f55bd0f8313bd843604592e27bd8#code)\n\nReplica.sol\n\n```jsx\n\nfunction initialize(\n        uint32 _remoteDomain,\n        address _updater,\n        bytes32 _committedRoot,\n        uint256 _optimisticSeconds\n    ) public initializer {\n        __NomadBase_initialize(_updater);\n        // set storage variables\n        entered = 1;\n        remoteDomain = _remoteDomain;\n        committedRoot = _committedRoot;\n        // pre-approve the committed root.\n        **confirmAt[_committedRoot] = 1;** \n        _setOptimisticTimeout(_optimisticSeconds);\n    }\nfunction process(bytes memory _message) public returns (bool _success) {\n        // ensure message was meant for this domain\n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        // ensure message has been proven\n        bytes32 _messageHash = _m.keccak();\n\t\t\t\t// **messages[_messageHash] 0x00 by default //vulnerable point**\n        **require(acceptableRoot(messages[_messageHash]), \"!proven\");**\n\n```\n\n---",
    "images": [],
    "Lost": "$152M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220802-nomad-bridge---business-logic-flaw--incorrect-acceptable-merkle-root-checks"
  },
  "Reaper Farm": {
    "type": "Access Control, ERC4626",
    "date": "2022-08-01",
    "rootCause": "without proper access control, allowing anyone to withdraw anyone else\u2019s funds.\n\nVulnerable code snippet: \n\nReaperVaultV2.sol\n\n[https://ftmscan.com/address/0xcdA5deA176F2dF95082f4daDb96255Bdb2bc7C7D#code#F1#L323](https://ftmscan.com/address/0xcdA5deA176F2dF95082f4daDb96255Bdb2bc7C7D#code#F1#L323)\n\n```jsx\nfunction _withdraw(uint256 assets, uint256 shares, address receiver, address owner) internal returns (uint256) { **//vulnerable point**\n        _burn(owner, shares);\n```",
    "images": [],
    "Lost": "$1.7M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220801-reaper-farm---business-logic-flaw--lack-of-access-control-mechanism"
  },
  "LPC": {
    "type": "ERC20, Flashloans, Insufficient validation",
    "date": "2022-07-25",
    "rootCause": "Incorrect recipient balance check, did not check sender!=recipient in transfer.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x1e813fa05739bf145c1f182cb950da7af046778d#code#L1240](https://bscscan.com/address/0x1e813fa05739bf145c1f182cb950da7af046778d#code#L1240)\n\nIncrease directly on the recipientAmount to recipient, deduct sender balance incorrectly.\n\n```jsx\nfunction _transfer(\n...\ntotalHolders = totalHolders_;\n\n        _balances[sender] = senderBalance.sub(amount);        \n        ***_balances[recipient] = recipientBalance.add(recipientAmount);***\n        emit Transfer(sender, recipient, recipientAmount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n```\n\nFixed:\n\n[https://etherscan.io/address/0x1c91aF03A390b4c619B444425b3119e553B5B44b#code#L414](https://etherscan.io/address/0x1c91aF03A390b4c619B444425b3119e553B5B44b#code#L414)\n\nAudius: The key difference in the patched Initialization contract is the two padding fields that disambiguate the proxyAdmin field used in the proxy contract from the initialized and initializing fields used in the implementation contract. This change prevents repetition of the initialization flow of the deployed contract.\n\n```solidity\ncontract Initializable {\n  address private proxyAdmin;\n    \n  uint256 private filler1;\n  uint256 private filler2;\n```",
    "images": [],
    "Lost": "$45K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220725-lpc---business-logic-flaw--incorrect-recipient-balance-check-did-not-check-senderrecipient-in-transfer"
  },
  "Audius": {
    "type": "ERC20, Governance, uninitialized",
    "date": "2022-07-23",
    "rootCause": "Storage Collision & Malicious Proposal\n\nVulnerable code snippet:\n\nAudiusAdminUpgradabilityProxy uses storage slot 0 for the address of the proxyAdmin:\n\n[https://etherscan.io/address/0x4deca517d6817b6510798b7328f2314d3003abac#code](https://etherscan.io/address/0x4deca517d6817b6510798b7328f2314d3003abac#code)\n\nRe-define voting on the Audius protocol and modify the governance contract\u2019s guardian address via initialize().\n\n_votingPeriod to 3 blocks.\n_executionDelay to 0 block\n_guardianAddress\n\n```solidity\n/**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(msg.sender == proxyAdmin, \"Only proxy admin can initialize\");\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n```",
    "images": [],
    "Lost": "$6M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220723-audius---storage-collision--malicious-proposal"
  },
  "SpaceGodzilla": {
    "type": "Access Control, ERC20, Flashloans",
    "date": "2022-07-13",
    "rootCause": "incorrect access control.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x2287c04a15bb11ad1358ba5702c1c95e2d13a5e0#code#L1233](https://bscscan.com/address/0x2287c04a15bb11ad1358ba5702c1c95e2d13a5e0#code#L1233)\n\n```solidity\nfunction swapAndLiquifyStepv1() public {   **//vulnerable point**\n        uint256 ethBalance = ETH.balanceOf(address(this));\n        uint256 tokenBalance = balanceOf(address(this));\n        addLiquidityUsdt(tokenBalance, ethBalance);\n    }\n```",
    "images": [],
    "Lost": "$26,000",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220713-spacegodzilla---flashloans--price-manipulation"
  },
  "Omni NFT": {
    "type": "ERC721, Flashloans, Reentrancy",
    "date": "2022-07-10",
    "rootCause": "safeTransferFrom in burn function. project without nonReentrant protection.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x50c7a557d408a5f5a7fdbe1091831728ae7eba45#code#F7#L280](https://etherscan.io/address/0x50c7a557d408a5f5a7fdbe1091831728ae7eba45#code#F7#L280)\n\nexecuteWithdrawERC721 trigger burn function\n\n```solidity\nfunction executeWithdrawERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteWithdrawERC721Params memory params\n    ) external returns (uint256) {\n        DataTypes.ReserveData storage reserve = reservesData[params.asset];\n        DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n        reserve.updateState(reserveCache);\n        uint256 amountToWithdraw = params.tokenIds.length;\n\n        bool withdrwingAllCollateral = INToken(reserveCache.xTokenAddress).burn(\n            msg.sender,\n            params.to,\n            params.tokenIds,\n            reserveCache.nextLiquidityIndex\n        );\n```\n\n[https://etherscan.io/address/0x4e21f48add00e579b774cdad1656c6625c280381#code#F1#L106#116](https://etherscan.io/address/0x4e21f48add00e579b774cdad1656c6625c280381#code#F1#L106#116)\n\nIn burn function trigger safeTransferFrom. As we know this function will call external OnERC721Received. So we can control execution flow to do reentrancy here.\n\n```solidity\n/// @inheritdoc INToken\n    function burn(\n        address from,\n        address receiverOfUnderlying,\n        uint256[] calldata tokenIds,\n        uint256 index\n    ) external virtual override onlyPool returns (bool) {\n        bool withdrawingAllTokens = _burnMultiple(from, tokenIds);\n\n        if (receiverOfUnderlying != address(this)) {\n            for (uint256 index = 0; index < tokenIds.length; index++) {\n                IERC721(_underlyingAsset).safeTransferFrom( **//vulnerable point**\n                    address(this),\n                    receiverOfUnderlying,\n                    tokenIds[index]\n                );\n            }\n        }\n```",
    "images": [],
    "Lost": "$1.4M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220710-omni-nft---reentrancy"
  },
  "Quixotic": {
    "type": "Insufficient validation, NFTMarketplace, Signature",
    "date": "2022-07-01",
    "rootCause": "fillSellOrder function only check seller signature.\n\nVulnerable code snippet:\n\n[https://optimistic.etherscan.io/address/0x065e8a87b8f11aed6facf9447abe5e8c5d7502b6#code#L1670](https://optimistic.etherscan.io/address/0x065e8a87b8f11aed6facf9447abe5e8c5d7502b6#code#L1670)\n\nQuixotic only check buyers signature only.\n\n```solidity\n/*\n    * @dev External trade function. This accepts the details of the sell order and signed sell\n    * order (the signature) as a meta-transaction.\n    *\n    * Emits a {SellOrderFilled} event via `_fillSellOrder`.\n    */\n    function fillSellOrder(\n        address payable seller,\n        address contractAddress,\n        uint256 tokenId,\n        uint256 startTime,\n        uint256 expiration,\n        uint256 price,\n        uint256 quantity,\n        uint256 createdAtBlockNumber,\n        address paymentERC20,\n        bytes memory signature,\n        address payable buyer\n    ) external payable whenNotPaused nonReentrant {\n        // If the payment ERC20 is the zero address, we check that enough native ETH has been sent\n        // with the transaction. Otherwise, we use the supplied ERC20 payment token.\n        if (paymentERC20 == address(0)) {\n            require(msg.value >= price, \"Transaction doesn't have the required ETH amount.\");\n        } else {\n            _checkValidERC20Payment(buyer, price, paymentERC20);\n        }\n\n        SellOrder memory sellOrder = SellOrder(\n            seller,\n            contractAddress,\n            tokenId,\n            startTime,\n            expiration,\n            price,\n            quantity,\n            createdAtBlockNumber,\n            paymentERC20\n        );\n\n        /* Make sure the order is not cancelled */\n        require(\n            cancellationRegistry.getSellOrderCancellationBlockNumber(seller, contractAddress, tokenId) < createdAtBlockNumber,\n            \"This order has been cancelled.\"\n        );\n\n        /* Check signature */\n        require(_validateSellerSignature(sellOrder, signature), \"Signature is not valid for SellOrder.\"); **//vulnerable point**\n\n        // Check has started\n        require((block.timestamp > startTime), \"SellOrder start time is in the future.\");\n\n        // Check not expired\n        require((block.timestamp < expiration), \"This sell order has expired.\");\n\n        _fillSellOrder(sellOrder, buyer);\n    }\n```\n\n---",
    "images": [],
    "Lost": "$100K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220701-quixotic---optimism-nft-marketplace"
  },
  "XCarnival": {
    "type": "ERC721, Insufficient validation",
    "date": "2022-06-26",
    "rootCause": "call XToken contract's borrow(), there is no judgment that the NFT has been withdrawn.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x39360ac1239a0b98cb8076d4135d0f72b7fd9909#code#F1#L108](https://etherscan.io/address/0x39360ac1239a0b98cb8076d4135d0f72b7fd9909#code#F1#L108)\n\nParameter xToken can control, attakcer can withdraw pledged NFT.\n\n```solidity\nfunction pledgeAndBorrow(address _collection, uint256 _tokenId, uint256 _nftType, address xToken, uint256 borrowAmount) external nonReentrant {\n        uint256 orderId = pledgeInternal(_collection, _tokenId, _nftType);\n        IXToken(xToken).borrow(orderId, payable(msg.sender), borrowAmount); **//vulnerable point**\n    }\n```",
    "images": [],
    "Lost": "$3.87M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220626-xcarnival---infinite-number-of-loans"
  },
  "SNOOD": {
    "type": "ERC777, Insufficient validation",
    "date": "2022-06-18",
    "rootCause": "miscalculation on _spendAllowance\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xeac2a259f3ebb8fd1097aeccaa62e73b6e43d5bf#code#F2#L58](https://etherscan.io/address/0xeac2a259f3ebb8fd1097aeccaa62e73b6e43d5bf#code#F2#L58)\n\nMisuses `_getStandardAmount` and should be `_getReflectedAmount`\n\n```solidity\nfunction _spendAllowance(address owner, address spender, uint256 amount) internal override {\n        super._spendAllowance(owner, spender, _getStandardAmount(amount)); **//vulnerable point**\n    }\n```",
    "images": [],
    "Lost": "104 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220618-snood---miscalculation-on-_spendallowance"
  },
  "InverseFinance": {
    "type": "Flashloans, lending",
    "date": "2022-06-16",
    "rootCause": "Incorrect LP price calculation via balanceOf.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xe8b3bc58774857732c6c1147bfc9b9e5fb6f427c#code#L120](https://etherscan.io/address/0xe8b3bc58774857732c6c1147bfc9b9e5fb6f427c#code#L120)\n\nInsecure way to calculation of LP price via balanceOf in the pool.\n\n```solidity\nfunction latestAnswer() public view returns (uint256) {\n        uint256 crvPoolBtcVal = WBTC.balanceOf(address(CRV3CRYPTO)) * uint256(BTCFeed.latestAnswer()) * 1e2; **//vulnerable point**\n        uint256 crvPoolWethVal = WETH.balanceOf(address(CRV3CRYPTO)) * uint256(ETHFeed.latestAnswer()) / 1e8; **//vulnerable point**\n        uint256 crvPoolUsdtVal = USDT.balanceOf(address(CRV3CRYPTO)) * uint256(USDTFeed.latestAnswer()) * 1e4; **//vulnerable point**\n\n        uint256 crvLPTokenPrice = (crvPoolBtcVal + crvPoolWethVal + crvPoolUsdtVal) * 1e18 / crv3CryptoLPToken.totalSupply();\n\n        return (crvLPTokenPrice * vault.pricePerShare()) / 1e18;\n    }\n```",
    "images": [],
    "Lost": "$1.26M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220616-inversefinance---flashloan--price-oracle-manipulation"
  },
  "GYMNetwork": {
    "type": "Access Control, ERC20",
    "date": "2022-06-08",
    "rootCause": "Incorrect access control.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x0288fba0bf19072d30490a0f3c81cd9b0634258a#code#F1#L291](https://bscscan.com/address/0x0288fba0bf19072d30490a0f3c81cd9b0634258a#code#F1#L291)\n\n```solidity\n/**\n     * @notice Deposit in given pool\n     * @param _depositAmount: Amount of want token that user wants to deposit\n     */\n    function depositFromOtherContract(\n        uint256 _depositAmount,\n        uint8 _periodId,\n        bool isUnlocked,\n        address _from\n    ) external external {  **//vulnerable point**\n        require(isPoolActive,'Contract is not running yet');\n        _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n```\n\nBug fixed\n\n[https://bscscan.com/address/0xb131c1cc89d209fb5c7250f68d31eff0fb5640d3#code#F1#L299](https://bscscan.com/address/0xb131c1cc89d209fb5c7250f68d31eff0fb5640d3#code#F1#L299)\n\n```solidity\n/**\n     * @notice Deposit in given pool\n     * @param _depositAmount: Amount of want token that user wants to deposit\n     */\n    function depositFromOtherContract(\n        uint256 _depositAmount,\n        uint8 _periodId,\n        bool isUnlocked,\n        address _from\n    ) external onlyBank {\n        require(isPoolActive,'Contract is not running yet');\n        _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n```",
    "images": [],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220608-gymnetwork---access-control"
  },
  "Discover": {
    "type": "ERC20, Flashloans",
    "date": "2022-06-06",
    "rootCause": "Incorrect price calculation via balanceOf.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xe732a7bd6706cbd6834b300d7c56a8d2096723a7#code#L242](https://bscscan.com/address/0xe732a7bd6706cbd6834b300d7c56a8d2096723a7#code#L242)\n\n```solidity\nfunction getprice() public view returns (uint256 _price) {\n        uint256 lpusdtamount=usdt.balanceOf(_lpaddr); **//vulnerable point** \n        uint256 lpotheramount=other.balanceOf(_lpaddr); **//vulnerable point**\n       \n        _price=lpusdtamount*10**18/lpotheramount;\n        \n    }\n```",
    "images": [],
    "Lost": "$49 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220606-discover---flashloan--price-oracle-manipulation"
  },
  "NOVO Protocol": {
    "type": "Deflationary token, Flashloans",
    "date": "2022-05-29",
    "rootCause": "No sender address validation.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xa0787daad6062349f63b7c228cbfd5d8a3db08f1#code#L2941](https://bscscan.com/address/0xa0787daad6062349f63b7c228cbfd5d8a3db08f1#code#L2941)\n\nThere is no sender address validation in the overridden transferFrom function\n\n```solidity\nfunction transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        // locked the NOVO of staking holders\n        uint256 lockedAmount = getLockedAmount(sender);\n        if (lockedAmount > 0) {\n            require(\n                (balanceOf(sender) - amount) >= lockedAmount,\n                \"Your balance was locked\"\n            );\n        }\n// _approve(  **//vulnerable point - commented out**\n        //     sender,\n        //     _msgSender(),\n        //     _allowances[sender][_msgSender()].sub(\n        //         amount,\n        //         \"BEP20: transfer amount exceeds allowance\"\n        //     )\n        // );\n```",
    "images": [],
    "Lost": "279 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220529-novo-protocol---flashloan--price-oracle-manipulation"
  },
  "HackDao": {
    "type": "DAO, Flashloans, skim",
    "date": "2022-05-24",
    "rootCause": "Incorrect logic in _transfer  function of token contract.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x94e06c77b02ade8341489ab9a23451f68c13ec1c#code#L475](https://bscscan.com/address/0x94e06c77b02ade8341489ab9a23451f68c13ec1c#code#L475)\n\n[https://bscscan.com/address/0x94e06c77b02ade8341489ab9a23451f68c13ec1c#code#L494](https://bscscan.com/address/0x94e06c77b02ade8341489ab9a23451f68c13ec1c#code#L494)\n\nCause Uniswap pair can be reduced without any swap, so attacker can do price manipulation. Once imbalance in the pair, attacker can call skim() to get profit.\n\n```solidity\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        uint256 actualAmount = amount;\n\n        if(parentAddress[recipient] == address(0) && recipient != uniswapV2Pair){\n            if(sender == uniswapV2Pair){\n                parentAddress[recipient] = _defaultAddress;\n            }else{\n                parentAddress[recipient] = sender;\n            }\n        }\n\n        if(!isWhiteListed(sender) && !isWhiteListed(recipient)){\n            \n            uint256 fee = calculationFeeNum(amount,_feeRatio);\n            //sell\n            if(recipient == uniswapV2Pair){\n                require(senderBalance >= amount.add(fee), \"ERC20: There are not enough charges for the account balance\");\n                unchecked {\n                    _balances[sender] -= fee;\n                }\n            }else{\n                actualAmount = amount - fee;\n            }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220524-hackdao---skim-token-balance"
  },
  "ApeCoin (APE)": {
    "type": "ERC20, Flashloans, claimTokens",
    "date": "2022-05-17",
    "rootCause": "Incorrect airdrop calculation\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x025C6da5BD0e6A5dd1350fda9e3B6a614B205a1F#code#F1#L103](https://etherscan.io/address/0x025C6da5BD0e6A5dd1350fda9e3B6a614B205a1F#code#F1#L103)\n\nfunction getClaimableTokenAmountAndGammaToClaim() to calculate the amount of ApeCoin to claim based on how many NFT the caller has and it doesn\u2019t consider how long the caller owns those NFTs.\n\n```solidity\nfunction claimTokens() external whenNotPaused {\n        require(block.timestamp >= claimStartTime && block.timestamp < claimStartTime + claimDuration, \"Claimable period is finished\");\n        require((beta.balanceOf(msg.sender) > 0 || alpha.balanceOf(msg.sender) > 0), \"Nothing to claim\");\n\n        uint256 tokensToClaim;\n        uint256 gammaToBeClaim;\n\n        (tokensToClaim, gammaToBeClaim) = getClaimableTokenAmountAndGammaToClaim(msg.sender); **//vulnerable point**, check reward\n\n        for(uint256 i; i < alpha.balanceOf(msg.sender); ++i) {\n            uint256 tokenId = alpha.tokenOfOwnerByIndex(msg.sender, i);\n            if(!alphaClaimed[tokenId]) {\n                alphaClaimed[tokenId] = true;\n                emit AlphaClaimed(tokenId, msg.sender, block.timestamp);\n            }\n        }\nfunction getClaimableTokenAmountAndGammaToClaim(address _account) private view returns (uint256, uint256)\n    {\n        uint256 unclaimedAlphaBalance;\n        for(uint256 i; i < alpha.balanceOf(_account); ++i) {\n            uint256 tokenId = alpha.tokenOfOwnerByIndex(_account, i);\n            if(!alphaClaimed[tokenId]) {\n                ++unclaimedAlphaBalance;\n            }\n```",
    "images": [],
    "Lost": "$1.1 million",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220517-apecoin-ape---flashloan"
  },
  "Fortress Loans": {
    "type": "MaliciosProposal, lending",
    "date": "2022-05-08",
    "rootCause": "Insufficient validation in submit() in chain contract.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xc11b687cd6061a6516e23769e4657b6efa25d78e#code#F1#L142](https://bscscan.com/address/0xc11b687cd6061a6516e23769e4657b6efa25d78e#code#F1#L142)\n\nL142 was commented out. There is no verification to ensure the function call is triggered properly. Anyone can call submit function to manipulate price oracle.\n\n```solidity\nfunction submit(\n    uint32 _dataTimestamp,\n    bytes32 _root,\n    bytes32[] memory _keys,\n    uint256[] memory _values,\n    uint8[] memory _v,\n    bytes32[] memory _r,\n    bytes32[] memory _s\n  ) public {\n...\n...\nrequire(i >= requiredSignatures, \"not enough signatures\");\n    // we turn on power once we have proper DPoS\n    // require(power * 100 / staked >= 66, \"not enough power was gathered\");\n```",
    "images": [],
    "Lost": "$3 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220508-fortress-loans---malicious-proposal--price-oracle-manipulation"
  },
  "DEUS DAO": {
    "type": "DAO, Flashloans",
    "date": "2022-04-28",
    "rootCause": "Incorrect price calculation via balanceOf.\n\nVulnerable code snippet:\n\n```solidity\n/// @notice returns on chain LP price\n    function getOnChainPrice() public view returns (uint256) {\n        return\n            ((dei.balanceOf(address(pair)) * IBaseV1Pair(address(pair)).getAmountOut(1e18, address(dei)) * 1e12 / 1e18) + (usdc.balanceOf(address(pair)) * 1e12)) * 1e18 / pair.totalSupply();**//vulnerable point**\n    }\n```",
    "images": [],
    "Lost": "$13 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220428-deus-dao---flashloan--price-oracle-manipulation"
  },
  "Wiener DOGE": {
    "type": "Deflationary token, Flashloans",
    "date": "2022-04-24",
    "rootCause": "LPs should be excluded from fees and token burns.\n\nVulnerable code snippet:\n\n[https://www.bscscan.com/address/0x46ba8a59f4863bd20a066fd985b163235425b5f9#code#L206](https://www.bscscan.com/address/0x46ba8a59f4863bd20a066fd985b163235425b5f9#code#L206)\n\nif an LP sends 100 WDOGE, its balance will decrease by 104 WDOGE, attacker exhaust the deflationary tokens in the LP pair; LPs should be excluded from fees and token burns.\n\n```solidity\nfunction _transfer(address sender, address recipient, uint256 amount) internal virtual returns (bool) {\n        require(_balances[sender].amount >= amount, \"ERC20: transfer amount exceeds balance\");\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        if(block.timestamp >=  openingTime && block.timestamp <= closingTime)\n        {\n            _balances[sender].amount -= amount;\n            _balances[recipient].amount += amount;\n            emit Transfer(sender, recipient, amount);\n        }\n        else\n        {\n            uint256 onePercent = findOnePercent(amount);\n            uint256 tokensToBurn = onePercent *4;   // deflationary\n            uint256 tokensToRedistribute = onePercent * 4;\n            uint256 toFeeWallet = onePercent*1;\n            uint256 todev = onePercent* 1;\n            uint256 tokensToTransfer = amount - tokensToBurn - tokensToRedistribute - toFeeWallet-todev;\n\n            _balances[sender].amount -= amount;\n            _balances[recipient].amount += tokensToTransfer;\n            _balances[feeWallet].amount += toFeeWallet;\n            _balances[dev].amount  += todev;\n            if (!_balances[recipient].exists){\n                _balanceOwners.push(recipient);\n                _balances[recipient].exists = true;\n            }\n\n            redistribute(sender, tokensToRedistribute);\n            _burn(sender, tokensToBurn);  // burn\n            emit Transfer(sender, recipient, tokensToTransfer);\n        }\n        return true;\n```",
    "images": [],
    "Lost": "78 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220424-wiener-doge---flashloan"
  },
  "Akutar NFT": {
    "type": "DoS, ERC721",
    "date": "2022-04-23",
    "rootCause": "Incorrect validation and External calls can fail deliberately.\n\nVulnerable code snippet:\n\n(1)DOS\n\n[https://etherscan.io/address/0xf42c318dbfbaab0eee040279c6a2588fa01a961d#code#L585](https://etherscan.io/address/0xf42c318dbfbaab0eee040279c6a2588fa01a961d#code#L585)\n\nBidder can be a malicious contract to cause DOS.\n\n```solidity\nfunction processRefunds() external {\n      require(block.timestamp > expiresAt, \"Auction still in progress\");\n      uint256 _refundProgress = refundProgress;\n      uint256 _bidIndex = bidIndex;\n      require(_refundProgress < _bidIndex, \"Refunds already processed\");\n      \n      uint256 gasUsed;\n      uint256 gasLeft = gasleft();\n      uint256 price = getPrice();\n      \n      for (uint256 i=_refundProgress; gasUsed < 5000000 && i < _bidIndex; i++) {\n          bids memory bidData = allBids[i];\n          if (bidData.finalProcess == 0) {\n            uint256 refund = (bidData.price - price) * bidData.bidsPlaced;\n            uint256 passes = mintPassOwner[bidData.bidder];\n            if (passes > 0) {\n                refund += mintPassDiscount * (bidData.bidsPlaced < passes ? bidData.bidsPlaced : passes);\n            }\n            allBids[i].finalProcess = 1;\n            if (refund > 0) {\n                (bool sent, ) = bidData.bidder.call{value: refund}(\"\"); // low-lecel call\n                require(sent, \"Failed to refund bidder\");\n```\n\nHow to fix, follow favor pull over push for external calls.\n\n[https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls)\n\n(2)Fund lock\n\n[https://etherscan.io/address/0xf42c318dbfbaab0eee040279c6a2588fa01a961d#code#L618](https://etherscan.io/address/0xf42c318dbfbaab0eee040279c6a2588fa01a961d#code#L618)\n\nIt should compare with `_bidIndex` instead of `totalBids`. Due to this issue, the requirement will never be satisfied, and the Ether in the contract can be locked for ever\n\n```solidity\nfunction claimProjectFunds() external onlyOwner {\n        require(block.timestamp > expiresAt, \"Auction still in progress\");\n        require(refundProgress >= totalBids, \"Refunds not yet processed\"); // wrong **//vulnerable point**\n        require(akuNFTs.airdropProgress() >= totalBids, \"Airdrop not complete\");\n\n        (bool sent, ) = project.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to withdraw\");        \n    }\n```",
    "images": [],
    "Lost": "$34 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220423-akutar-nft---denial-of-service"
  },
  "Zeed Finance": {
    "type": "Dex/AMM, Flashloans, Reward, lending",
    "date": "2022-04-21",
    "rootCause": "incorrect reward calculation.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xe7748fce1d1e2f2fd2dddb5074bd074745dda8ea#code#L857](https://bscscan.com/address/0xe7748fce1d1e2f2fd2dddb5074bd074745dda8ea#code#L857)\n\nInitially, 5% fee in a selling order were divided into three parts for rewarding liquidity providers. However, based on the token contract loopholes, that part of tokens hadn\u2019t been divided by the system so the LP reward was two times greater than the previous one, leading to extra token distribution.\n\n```solidity\nfunction _takeReward(\n        address sender,\n        uint256 rewardFee\n    ) private {\n        if (rewardFee == 0) return;\n        uint256 zeedReward = rewardFee.div(2);\n        uint256 hoReward = rewardFee.div(2).div(2);\n        uint256 usdtReward = rewardFee.sub(zeedReward).sub(hoReward);\n\n        _balances[swapPair] = _balances[swapPair].add(rewardFee); **//vulnerable point**\n        emit Transfer(sender, swapPair, usdtReward);\n\n        _balances[swapPairZeed] = _balances[swapPairZeed].add(rewardFee); **//vulnerable point**\n        emit Transfer(sender, swapPairZeed, zeedReward);\n\n        _balances[swapPairHo] = _balances[swapPairHo].add(rewardFee); **//vulnerable point**\n        emit Transfer(sender, swapPairHo, hoReward);\n    }\n```",
    "images": [],
    "Lost": "$1 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220421-zeed-finance---reward-distribution-flaw"
  },
  "BeanstalkFarms": {
    "type": "DAO, Flashloans, MaliciosProposal, Stablecoin",
    "date": "2022-04-16",
    "rootCause": "insufficient validation\n\nVulnerable code snippet:\n\nAs the BIP18 proposal was created one day ago, validation one will be bypassed. By flashloan, the BIP18 proposal gained more than 78% of the vote, which is more than 67%. So proposal executed.\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$182 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220416-beanstalkfarms---dao--flashloan"
  },
  "Rikkei Finance": {
    "type": "Access Control, lending",
    "date": "2022-04-15",
    "rootCause": "incorrect access control\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xd55f01b4b51b7f48912cd8ca3cdd8070a1a9dba5#code#F1#L29](https://bscscan.com/address/0xd55f01b4b51b7f48912cd8ca3cdd8070a1a9dba5#code#F1#L29)\n\nSetOracleData() function whose visibility is public and can be called externally. Anyone can call SetOracleData to manipulate price.\n\n```solidity\nfunction setOracleData(address rToken, oracleChainlink _oracle) external { **//vulnerable point**\n        oracleData[rToken] = _oracle;\n    }\n```",
    "images": [],
    "Lost": "$1.1 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220415-rikkei-finance---access-control--price-oracle-manipulation"
  },
  "Auctus": {
    "type": "Arbitrary call, Yield",
    "date": "2022-03-26",
    "rootCause": "arbitrary call via write().\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L101](https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L101)\n\nexchangeData is controllable and without any input validation. \n\nVulnerable point: [https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L135](https://etherscan.io/address/0xE7597F774fD0a15A617894dc39d45A28B97AFa4f#code#F1#L135)\n\n```solidity\nfunction write(\n        address acoToken, \n        uint256 collateralAmount, \n        address exchangeAddress, \n        bytes memory exchangeData \n    ) \n        nonReentrant \n        setExchange(exchangeAddress) \n        public \n        payable \n    {\n        require(msg.value > 0,  \"ACOWriter::write: Invalid msg value\");\n        require(collateralAmount > 0,  \"ACOWriter::write: Invalid collateral amount\");\n        \n        address _collateral = IACOToken(acoToken).collateral();\n        if (_isEther(_collateral)) {\n            IACOToken(acoToken).mintToPayable{value: collateralAmount}(msg.sender);\n        } else {\n            _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n            _approveERC20(_collateral, acoToken, collateralAmount);\n            IACOToken(acoToken).mintTo(msg.sender, collateralAmount);\n        }\n        \n        _sellACOTokens(acoToken, exchangeData);\n    }\n/**\n     * @dev Internal function to sell the ACO tokens and transfer the premium to the transaction sender.\n     * @param acoToken Address of the ACO token.\n     * @param exchangeData Data to be sent to the exchange.\n     */\n    function _sellACOTokens(address acoToken, bytes memory exchangeData) internal {\n        uint256 acoBalance = _balanceOfERC20(acoToken, address(this));\n        _approveERC20(acoToken, erc20proxy, acoBalance);\n        (bool success,) = _exchange.call{value: address(this).balance}(exchangeData); **//vulnerable point**\n        require(success, \"ACOWriter::_sellACOTokens: Error on call the exchange\");\n```",
    "images": [],
    "Lost": "$726 K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220326-auctus"
  },
  "CompoundTUSDSweepTokenBypass": {
    "type": "Insufficient validation, lending",
    "date": "2022-03-22",
    "rootCause": "Insufficient validation.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xa035b9e130f2b1aedc733eefb1c67ba4c503491f#code#F1#L120](https://etherscan.io/address/0xa035b9e130f2b1aedc733eefb1c67ba4c503491f#code#F1#L120)\n\nif contract can make calls into arbitrary addresses, this can be abused. Attacker use legacy TUSD smart contract to trick compound.\n\n```solidity\nfunction sweepToken(EIP20NonStandardInterface token) override external {\n    require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n}\n```\n\nImage from [OZ](https://blog.openzeppelin.com/compound-tusd-integration-issue-retrospective/)\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220322-compoundtusdsweeptokenbypass"
  },
  "OneRing Finance": {
    "type": "Flashloans, Yield",
    "date": "2022-03-21",
    "rootCause": "Incorrect price calculation via reverse.\n\nVulnerable code snippet:\n\n[https://ftmscan.com/address/0x66a13cd7ea0ba9eb4c16d9951f410008f7be3a10#code#F1#L216](https://ftmscan.com/address/0x66a13cd7ea0ba9eb4c16d9951f410008f7be3a10#code#F1#L216)\n\n[https://ftmscan.com/address/0xdbc07e219ba0cb5fddcd0fa0c5cc1eddfb77e082#code#F2#L378](https://ftmscan.com/address/0xdbc07e219ba0cb5fddcd0fa0c5cc1eddfb77e082#code#F2#L378)\n\n```solidity\nfunction getUSDBalanceFromUnderlyingBalance(uint256 _bal)\n        public\n        view\n        returns (uint256 _amount)\n    {\n        if (_bal > 0) {\n            address _token0 = IUniswapV2Pair(underlying).token0();\n            address _token1 = IUniswapV2Pair(underlying).token1();\n\n            (uint256 _reserves0, uint256 _reserves1, ) = IUniswapV2Pair(\n                underlying\n            ).getReserves(); \n            uint256 _totalSupply = IERC20(underlying).totalSupply();\n\t\t\t\t\t\t//vulnerable point\n            uint256 _amount0 = _reserves0.mul(_bal).div(_totalSupply); **//vulnerable point**\n            uint256 _amount1 = _reserves1.mul(_bal).div(_totalSupply); **//vulnerable point**\n\n            uint256 _vaultDecimals = ERC20(vault).decimals();\n            uint256 _vaultUnit = uint256(10)**uint256(_vaultDecimals);\n            uint256 _token0Unit = uint256(10) **\n                uint256(ERC20(_token0).decimals());\n            uint256 _token1Unit = uint256(10) **\n                uint256(ERC20(_token1).decimals());\n\n            _amount =\n                _amount0.mul(_vaultUnit).div(_token0Unit) +\n                _amount1.mul(_vaultUnit).div(_token1Unit);\n        }\n    }\n```",
    "images": [],
    "Lost": "$1.45 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220321-onering-finance---flashloan--price-oracle-manipulation"
  },
  "Li.Fi": {
    "type": "Aggregation, Bridge, CrossChain",
    "date": "2022-03-20",
    "rootCause": "Arbitrary call via swap\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x73a499e043b03fc047189ab1ba72eb595ff1fc8e#code#F7#L30](https://etherscan.io/address/0x73a499e043b03fc047189ab1ba72eb595ff1fc8e#code#F7#L30)\n\n_swapData is controllable\n\n```solidity\nfunction swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData); **//vulnerable point**\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n```",
    "images": [],
    "Lost": "$570 K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220320-lifi---bridges"
  },
  "Umbrella Network": {
    "type": "Oracle, Under/Overflow, staking",
    "date": "2022-03-20",
    "rootCause": "Arithmetic Overflow\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xb3fb1d01b07a706736ca175f827e4f56021b85de#code#F1#L258](https://etherscan.io/address/0xb3fb1d01b07a706736ca175f827e4f56021b85de#code#F1#L258)\n\n```solidity\n/// @param amount tokens to withdraw\n    /// @param user address\n    /// @param recipient address, where to send tokens, if we migrating token address can be zero\n    function _withdraw(uint256 amount, address user, address recipient) internal nonReentrant updateReward(user) {\n        require(amount != 0, \"Cannot withdraw 0\");\n\n        // not using safe math, because there is no way to overflow if stake tokens not overflow\n        _totalSupply = _totalSupply - amount;\n        _balances[user] = _balances[user] - amount;  **//vulnerable point**, overflow\n        // not using safe transfer, because we working with trusted tokens\n        require(stakingToken.transfer(recipient, amount), \"token transfer failed\");\n\n        emit Withdrawn(user, amount);\n    }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220320-umbrella-network---underflow"
  },
  "Hundred Finance": {
    "type": "ERC667, Reentrancy, lending",
    "date": "2022-03-13",
    "rootCause": "Reentrancy\n\nVulnerable code snippet:\n\n[https://gnosisscan.io/address/0xf8d1677c8a0c961938bf2f9adc3f3cfda759a9d9#code#L724](https://gnosisscan.io/address/0xf8d1677c8a0c961938bf2f9adc3f3cfda759a9d9#code#L724)\n\nbridged token on the gnosis chain has a `callAfterTransfer()`hook which makes the reentrancy on token transfer.\n\n```solidity\nfunction transfer(address _to, uint256 _value) public returns (bool) {\n        require(superTransfer(_to, _value));\n        callAfterTransfer(msg.sender, _to, _value); **//vulnerable point**\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(super.transferFrom(_from, _to, _value));\n        callAfterTransfer(_from, _to, _value);  **//vulnerable point**\n        return true;\n    }\n```\n\nCheck detail: [https://medium.com/immunefi/a-poc-of-the-hundred-finance-heist-4121f23a098](https://medium.com/immunefi/a-poc-of-the-hundred-finance-heist-4121f23a098)",
    "images": [],
    "Lost": "$1.7 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220313-hundred-finance---erc667-reentrancy"
  },
  "Paraluni": {
    "type": "Dex/AMM, Flashloans, Insufficient validation, Reentrancy",
    "date": "2022-03-13",
    "rootCause": "reentrancy & insufficient validation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xa386f30853a7eb7e6a25ec8389337a5c6973421d#code#L2501](https://bscscan.com/address/0xa386f30853a7eb7e6a25ec8389337a5c6973421d#code#L2501)\n\nFrom Halborn:\n\nThe depositByAddLiquidity function calls an internal \ndepositByAddLiquidityInternal function that transfers the attacker\u2019s \ndeposit into the appropriate pool.\u00a0 However the pool ID value (_pid) \nused to look up the appropriate pool [is not validated internally](https://netfreeman.com/2022/03/202203132332576318.html).\n\nThe attacker takes advantage of this by directing this to an attacker-controlled contract, [whose malicious transferFrom function is called](https://coincodecap.com/paraluni-hacked-reportedly-1-7m-lost).\u00a0\n This function then exploits the reentrancy vulnerability to call the \nMasterchef deposit function before the internal state is updated.\u00a0 \nBetween the initial and malicious deposits, the attacker is credited \nwith excess tokens and able to extract more value from the contract than\n they deposited.\n\n```solidity\nfunction depositByAddLiquidity(uint256 _pid, address[2] memory _tokens, uint256[2] memory _amounts) external{\n        require(_amounts[0] > 0 && _amounts[1] > 0, \"!0\");\n        address[2] memory tokens;\n        uint256[2] memory amounts;\n        (tokens[0], amounts[0]) = _doTransferIn(msg.sender, _tokens[0], _amounts[0]);\n        (tokens[1], amounts[1]) = _doTransferIn(msg.sender, _tokens[1], _amounts[1]);\n        depositByAddLiquidityInternal(msg.sender, _pid, tokens,amounts);\n    }\nfunction depositByAddLiquidityInternal(address _user, uint256 _pid, address[2] memory _tokens, uint256[2] memory _amounts) internal {\n        PoolInfo memory pool = poolInfo[_pid];\n        require(address(pool.ticket) == address(0), \"T:E\");\n        uint liquidity = addLiquidityInternal(address(pool.lpToken), _user, _tokens, _amounts);\n        _deposit(_pid, liquidity, _user);\n    }\n```",
    "images": [],
    "Lost": "$1.7 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220313-paraluni---flashloan--reentrancy"
  },
  "Fantasm Finance": {
    "type": "Miscalculation, Synthetic",
    "date": "2022-03-09",
    "rootCause": "Incorrect calculation due to wrong decimal\n\nVulnerable code snippet:\n\n[https://ftmscan.com/address/0x880672AB1d46D987E5d663Fc7476CD8df3C9f937#code#F11#L256](https://ftmscan.com/address/0x880672AB1d46D987E5d663Fc7476CD8df3C9f937#code#F11#L256)\n\nDue to the decimal PRECISION error, the _xftmOut is bigger than it is supposed to be.\n\n```solidity\nfunction mint(uint256 _fantasmIn, uint256 _minXftmOut) external payable nonReentrant {\n        require(!mintPaused, \"Pool::mint: Minting is paused\");\n        uint256 _ftmIn = msg.value;\n        address _minter = msg.sender;\n\n        (uint256 _xftmOut, , uint256 _minFantasmIn, uint256 _ftmFee) = calcMint(_ftmIn, _fantasmIn); **//vulnerable point**\n        require(_minXftmOut <= _xftmOut, \"Pool::mint: slippage\");\n        require(_minFantasmIn <= _fantasmIn, \"Pool::mint: Not enough Fantasm input\");\n        require(maxXftmSupply >= xftm.totalSupply() + _xftmOut, \"Pool::mint: > Xftm supply limit\");\n...\n/// @param _ftmIn Amount of FTM input.\n    /// @param _fantasmIn Amount of FSM input.\n    /// @return _xftmOut : the amount of XFTM output.\n    /// @return _minFtmIn : the required amount of FSM input.\n    /// @return _minFantasmIn : the required amount of FSM input.\n    /// @return _fee : the fee amount in FTM.\n    function calcMint(uint256 _ftmIn, uint256 _fantasmIn)\n        public\n        view\n        returns (\n            uint256 _xftmOut,\n            uint256 _minFtmIn,\n            uint256 _minFantasmIn,\n            uint256 _fee\n        )\n    {\n        uint256 _fantasmPrice = oracle.getFantasmPrice();\n        require(_fantasmPrice > 0, \"Pool::calcMint: Invalid Fantasm price\");\n\n        if (collateralRatio == COLLATERAL_RATIO_MAX || (collateralRatio > 0 && _ftmIn > 0)) {\n            _minFtmIn = _ftmIn;\n            _minFantasmIn = (_ftmIn * (COLLATERAL_RATIO_MAX - collateralRatio) * PRICE_PRECISION) / collateralRatio / _fantasmPrice;\n            _xftmOut = (_ftmIn * COLLATERAL_RATIO_MAX * (PRECISION - mintingFee)) / collateralRatio / PRECISION;\n            _fee = (_ftmIn * mintingFee) / PRECISION;\n        } else {\n            _minFantasmIn = _fantasmIn;\n            **_xftmOut** = (_fantasmIn * _fantasmPrice * COLLATERAL_RATIO_MAX * (PRECISION - mintingFee)) / PRECISION / (COLLATERAL_RATIO_MAX - collateralRatio) / PRICE_PRECISION; //vulnerable point\n            _minFtmIn = (_fantasmIn * _fantasmPrice * collateralRatio) / (COLLATERAL_RATIO_MAX - collateralRatio) / PRICE_PRECISION;\n            _fee = (_fantasmIn * _fantasmPrice * collateralRatio * mintingFee) / PRECISION / (COLLATERAL_RATIO_MAX - collateralRatio) / PRICE_PRECISION;\n        }\n    }\n```\n\n---\n\nfixed\n\n[https://ftmscan.com/address/0xa3B99CdFdDe2216AfB1D58D6108cC93fea413A76#code](https://ftmscan.com/address/0xa3B99CdFdDe2216AfB1D58D6108cC93fea413A76#code)\n\n```jsx\nfunction mint(uint256 _minXTokenOut) external payable nonReentrant {\n        require(!mintPaused, \"Pool::mint: Minting is paused\");\n        uint256 _ethIn = msg.value;\n        address _sender = msg.sender;\n\n        (uint256 _xTokenOut, uint256 _yTokenOutTwap, uint256 _fee, uint256 _wethSwapIn) = calcMint(\n            _ethIn\n        );\n        require(_xTokenOut >= _minXTokenOut, \"Pool::mint: > slippage\");\n\n        WethUtils.wrap(_ethIn);\n        if (_yTokenOutTwap > 0 && _wethSwapIn > 0) {\n            WethUtils.weth.safeIncreaseAllowance(address(swapStrategy), _wethSwapIn);\n            swapStrategy.execute(_wethSwapIn, _yTokenOutTwap);\n        }\n\n        if (_xTokenOut > 0) {\n            userInfo[_sender].xTokenBalance = userInfo[_sender].xTokenBalance + _xTokenOut;\n            unclaimedXToken = unclaimedXToken + _xTokenOut;\n        }\n\n        transferToTreasury(_fee);\n\n        emit Mint(_sender, _xTokenOut, _ethIn, _fee);\n    }\n\n/// @notice Calculate the expected results for zap minting\n    /// @param _ethIn Amount of Collateral token input.\n    /// @return _xTokenOut : the amount of XToken output.\n    /// @return _yTokenOutTwap : the amount of YToken output by swapping based on TWAP\n    /// @return _ethFee : the fee amount in Collateral token.\n    /// @return _ethSwapIn : the amount of Collateral token to swap\n    function calcMint(uint256 _ethIn)\n        public\n        view\n        returns (\n            uint256 _xTokenOut,\n            uint256 _yTokenOutTwap,\n            uint256 _ethFee,\n            uint256 _ethSwapIn\n        )\n    {\n        uint256 _yTokenTwap = oracle.getYTokenTWAP();\n        require(_yTokenTwap > 0, \"Pool::calcMint: Invalid YToken price\");\n        _ethSwapIn = (_ethIn * (COLLATERAL_RATIO_MAX - collateralRatio)) / COLLATERAL_RATIO_MAX;\n        _yTokenOutTwap = (_ethSwapIn * PRICE_PRECISION) / _yTokenTwap;\n        _ethFee = (_ethIn * mintingFee * collateralRatio) / COLLATERAL_RATIO_MAX / PRECISION;\n        _xTokenOut = _ethIn - ((_ethIn * mintingFee) / PRECISION);\n    }\n```",
    "images": [],
    "Lost": "$2.6 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220309-fantasm-finance---business-logic-in-mint"
  },
  "Bacon Protocol": {
    "type": "ERC777, Reentrancy, lending",
    "date": "2022-03-05",
    "rootCause": "reentrancy in lend()\n\nVulnerable code snippet:\n\nunverified contract\n\n[https://etherscan.io/address/0x781ad73f140815763d9a4d4752daf9203361d07d#code](https://etherscan.io/address/0x781ad73f140815763d9a4d4752daf9203361d07d#code)\n\nuse tokensReceived hook to reenter lend()\n\n---\n\nIssue fixed\n\n[https://etherscan.io/address/0xb827b209b388856f23845a56d8b34cf26fda171f#code#F1#L205](https://etherscan.io/address/0xb827b209b388856f23845a56d8b34cf26fda171f#code#F1#L205)\n\n```solidity\n/**\n    *   @dev Function lend moves assets on the (probably usdc) contract to our own balance\n    *   - Before calling: an approve(address _spender (proxy), uint256 _value (0xffff)) function call must be made on remote contract\n    *   @param amount The amount of USDC to be transferred\n    *   @return the amount of poolTokens created\n    */\n    function lend(\n        uint256 amount\n    ) public nonReentrant returns (uint256) {\n        IERC20Upgradeable(ERCAddress).transferFrom(msg.sender, address(this), amount);\n\n        poolLent = poolLent.add(amount);\n\n        super._mint(msg.sender, amount);\n\n        return amount;\n    }\n```",
    "images": [],
    "Lost": "$1 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220305-bacon-protocol---reentrancy"
  },
  "TreasureDAO": {
    "type": "DAO, Insufficient validation",
    "date": "2022-03-03",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet:\n\n[https://arbiscan.io/address/0x812cda2181ed7c45a35a691e0c85e231d218e273#code#F17#L226](https://arbiscan.io/address/0x812cda2181ed7c45a35a691e0c85e231d218e273#code#F17#L226)\n\nSince _quantity can be zero, so attacker can buy NFT for free\n\n```solidity\nfunction buyItem(\n        address _nftAddress,\n        uint256 _tokenId,\n        address _owner,\n        uint256 _quantity\n    )\n        external\n        nonReentrant\n        isListed(_nftAddress, _tokenId, _owner)\n        validListing(_nftAddress, _tokenId, _owner)\n    {\n        require(_msgSender() != _owner, \"Cannot buy your own item\");\n\n        Listing memory listedItem = listings[_nftAddress][_tokenId][_owner];\n        require(listedItem.quantity >= _quantity, \"not enough quantity\");  **//vulnerable point**, insufficient validation.\n\n        // Transfer NFT to buyer\n        if (IERC165(_nftAddress).supportsInterface(INTERFACE_ID_ERC721)) {\n            IERC721(_nftAddress).safeTransferFrom(_owner, _msgSender(), _tokenId);\n        } else {\n            IERC1155(_nftAddress).safeTransferFrom(_owner, _msgSender(), _tokenId, _quantity, bytes(\"\"));\n        }\n\n        if (listedItem.quantity == _quantity) {\n            delete (listings[_nftAddress][_tokenId][_owner]);\n        } else {\n            listings[_nftAddress][_tokenId][_owner].quantity -= _quantity;\n        }\n\n        emit ItemSold(\n            _owner,\n            _msgSender(),\n            _nftAddress,\n            _tokenId,\n            _quantity,\n            listedItem.pricePerItem\n        );\n\n        TreasureNFTOracle(oracle).reportSale(_nftAddress, _tokenId, paymentToken, listedItem.pricePerItem);\n        _buyItem(listedItem.pricePerItem, _quantity, _owner);\n    }\n\nfunction _buyItem(\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _owner\n    ) internal {\n        uint256 totalPrice = _pricePerItem * _quantity; // since _quantity can be zero, so attacker can buy NFT for free\n        uint256 feeAmount = totalPrice * fee / BASIS_POINTS;\n        IERC20(paymentToken).safeTransferFrom(_msgSender(), feeReceipient, feeAmount);\n        IERC20(paymentToken).safeTransferFrom(_msgSender(), _owner, totalPrice - feeAmount);\n    }\n```",
    "images": [],
    "Lost": "$470 k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220303-treasuredao---zero-fee"
  },
  "BuildFinance": {
    "type": "DAO, MaliciosProposal",
    "date": "2022-02-14",
    "rootCause": "Malicious proposal\n\nCheck: [https://twitter.com/finance_build/status/1493223190071554049](https://twitter.com/finance_build/status/1493223190071554049)\n\nThe attacker succeeded in the takeover by having a large enough vote in favour of the proposal and there were not enough countervotes to prevent the takeover from happening.",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220214-buildfinance---dao"
  },
  "Sandbox LAND": {
    "type": "Access Control, Metaverse",
    "date": "2022-02-08",
    "rootCause": "incorrect access control.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x50f5474724e0ee42d9a4e711ccfb275809fd6d4a#code#F9#L355](https://etherscan.io/address/0x50f5474724e0ee42d9a4e711ccfb275809fd6d4a#code#F9#L355)\n\n```solidity\nfunction _burn(address from, address owner, uint256 id) public { **//vulnerable point**\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220208-sandbox-land---access-control"
  },
  "Meter": {
    "type": "Bridge, CrossChain, Insufficient validation",
    "date": "2022-02-06",
    "rootCause": "insufficient validation\n\nVulnerable code snippet:\n\nimage from [peckshield](https://twitter.com/peckshield/status/1490121762847092736)\n\n",
    "images": [
      "images/Meter_Untitled.png"
    ],
    "Lost": "$4.3 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220206-meter---bridge"
  },
  "Qubit Finance": {
    "type": "Bridge, CrossChain, Insufficient validation, lending",
    "date": "2022-01-28",
    "rootCause": "Insufficient validation\n\nVulnerable code snippet:\n\nQBridge\n[https://etherscan.io/address/0x99309d2e7265528dc7c3067004cc4a90d37b7cc3#code#F1#L200](https://etherscan.io/address/0x99309d2e7265528dc7c3067004cc4a90d37b7cc3#code#F1#L200)\n\nQBridgeHandler\n[https://etherscan.io/address/0x80d1486ef600cc56d4df9ed33baf53c60d5a629b#code#F1#L122](https://etherscan.io/address/0x80d1486ef600cc56d4df9ed33baf53c60d5a629b#code#F1#L122)\n\n**safeTransferFrom() in SafeToken.sol** does not revert when the token EOA. \n\ntokenAddress can be address(0) to pass all check to mint xETH.\n\n```jsx\nfunction deposit(uint8 destinationDomainID, bytes32 resourceID, bytes calldata data) external payable notPaused {\n        require(msg.value == fee, \"QBridge: invalid fee\");\n\n        address handler = resourceIDToHandlerAddress[resourceID];\n        require(handler != address(0), \"QBridge: invalid resourceID\");\n\n        uint64 depositNonce = ++_depositCounts[destinationDomainID];\n\n        IQBridgeHandler(handler).deposit(resourceID, msg.sender, data);\n        emit Deposit(destinationDomainID, resourceID, depositNonce, msg.sender, data);\n    }\n\nQBridgeHandler\nfunction deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\n        uint option;\n        uint amount;\n        (option, amount) = abi.decode(data, (uint, uint));\n\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID]; //without any tokenAddress check\n        require(contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n\n        if (burnList[tokenAddress]) {\n            require(amount >= withdrawalFees[resourceID], \"less than withdrawal fee\");\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\n        } else {\n            require(amount >= minAmounts[resourceID][option], \"less than minimum amount\");\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);  **//vulnerable point**\n        }\n    }\n\n/*\n\"input\":{\n\"token\":\"0x0000000000000000000000000000000000000000\"\n\"from\":\"0xd01ae1a708614948b2b5e0b7ab5be6afa01325c7\"\n\"to\":\"0x17b7163cf1dbd286e262ddc68b553d899b93f526\"\n\"value\":\"190000000000000000000\"\n}\n*/\nSafeToken.sol\nfunction safeTransferFrom(.  **//vulnerable point**\n        address token,\n        address from,\n        address to,\n        uint value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransferFrom\");\n    }\n```\n\nBTW:  SafeERC20 supports target address is checked to verify it contains contract code. ex:\n\n[https://github.com/polynetwork/eth-contracts/blob/master/contracts/libs/token/ERC20/SafeERC20.sol](https://github.com/polynetwork/eth-contracts/blob/master/contracts/libs/token/ERC20/SafeERC20.sol)\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n\n```jsx\nfunction safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\nfunction callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n```",
    "images": [],
    "Lost": "$80 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220128-qubit-finance---bridge-address0safetransferfrom-does-not-revert"
  },
  "Multichain (Anyswap)": {
    "type": "Bridge, CrossChain, Insufficient validation",
    "date": "2022-01-18",
    "rootCause": "insufficient validation\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x6b7a87899490ece95443e979ca9485cbe7e71522#code#L265](https://etherscan.io/address/0x6b7a87899490ece95443e979ca9485cbe7e71522#code#L265)\n\nUse costom contract to trick contract of Multichain V4Router. without any allowed v, r and s.\n\n```solidity\nfunction anySwapOutUnderlyingWithPermit(\n        address from,\n        address token, // without validation\n        address to,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint toChainID\n    ) external {\n        address _underlying = AnyswapV1ERC20(token).underlying();\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s); **//vulnerable point**\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n        AnyswapV1ERC20(token).depositVault(amount, from);\n        _anySwapOut(from, token, to, amount, toChainID);\n    }\n```",
    "images": [],
    "Lost": "$1.4 million",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220118-multichain-anyswap---insufficient-token-validation"
  },
  "ChannelsFinance": {
    "type": "",
    "date": "2023-12-30",
    "rootCause": "The root cause is the ExchangeRate manipulation.\nOnce the exchangeRate been controlled, hacker could borrow more than their collateral. The contract uses a old Compund V2 protocols which has a known vulenrability. You can find more info from this link:\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x93790c641d029d1cbd779d87b88f67704b6a8f4c](https://bscscan.com/address/0x93790c641d029d1cbd779d87b88f67704b6a8f4c)\n\nAttack tx:\n\n// First Attack Tx : [https://app.blocksec.com/explorer/tx/bsc/0x711cc4ceb9701d317fe9aa47187425e16dae7d5a0113f1430e891018262f8fb5](https://app.blocksec.com/explorer/tx/bsc/0x711cc4ceb9701d317fe9aa47187425e16dae7d5a0113f1430e891018262f8fb5)\n// Second Attack Tx : [https://app.blocksec.com/explorer/tx/bsc/0x93372ce9c86a25f1477b0c3068e745b5b829d5b58025bb1ab234230d3473b776](https://app.blocksec.com/explorer/tx/bsc/0x93372ce9c86a25f1477b0c3068e745b5b829d5b58025bb1ab234230d3473b776)\n\nAnalysis:\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:\n\n[https://x.com/AnciliaInc/status/1741353303542501455](https://x.com/AnciliaInc/status/1741353303542501455)\n\nREF\n\n[https://www.comp.xyz/t/hundred-finance-exploit-and-compound-v2/4266](https://www.comp.xyz/t/hundred-finance-exploit-and-compound-v2/4266)",
    "images": [],
    "Lost": "$320K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/ChannelsFinance_exp.sol"
  },
  "Telcoin": {
    "type": "Storage collision",
    "date": "2023-12-25",
    "rootCause": "The vulnerability stems from improper initialization of wallet contracts, which is due to a mismatch between the wallet\u2019s actual implementation and its corresponding proxy. Specifically, during the initialization process, the proxy initialized storage slot 0 to a non-zero state by writing to the least significant bits of the storage location. Subsequently, the wallet code also wrote to storage slot 0, thereby overwriting the proxy\u2019s initial value in the least significant bits. This issue is not the result of an inherent vulnerability in either of the smart contracts but rather the interaction between the two.\n\nConsequently, after the initialization process, the least significant two bytes of slot 0 will be reset to zero. This effectively sets both _initialized and _initializing to zero. As a result, the CloneableProxy:Proxy contract becomes vulnerable to re-initialization through the initialize() function, as the initializer modifier\u2019s protection can be circumvented.\n\nVulnerable code snippet:\n\n[https://polygonscan.com/address/0x56bcadff30680ebb540a84d75c182a5dc61981c0](https://polygonscan.com/address/0x56bcadff30680ebb540a84d75c182a5dc61981c0)\n\n[](https://miro.medium.com/v2/resize:fit:700/0*UCUIqPH2Bg1hQoEC)\n\nNote that slot 0 is allocated for _state, which stores the next 32 bytes from the calldata following the function selector, as indicated in line 21. For additional detailed information, refer to the commentary at the beginning of the Wallet contract:\n\n[](https://miro.medium.com/v2/resize:fit:700/0*kgGmJnrkrW32KYTj)\n\nAttack tx:\n\n[https://www.oklink.com/es-la/polygon/tx/0x35f50851c3b754b4565dc3e69af8f9bdb6555edecc84cf0badf8c1e8141d902d](https://www.oklink.com/es-la/polygon/tx/0x35f50851c3b754b4565dc3e69af8f9bdb6555edecc84cf0badf8c1e8141d902d)\n\n[https://phalcon.blocksec.com/explorer/tx/polygon/0x35f50851c3b754b4565dc3e69af8f9bdb6555edecc84cf0badf8c1e8141d902d](https://phalcon.blocksec.com/explorer/tx/polygon/0x35f50851c3b754b4565dc3e69af8f9bdb6555edecc84cf0badf8c1e8141d902d)\n\nAnalysis:\n\n[https://blocksecteam.medium.com/telcoin-security-incident-in-depth-analysis-d1945e22818f](https://blocksecteam.medium.com/telcoin-security-incident-in-depth-analysis-d1945e22818f)",
    "images": [],
    "Lost": "$1,24M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/Telcoin_exp.sol"
  },
  "PineProtocol": {
    "type": "Business Logic Flaw",
    "date": "2023-12-22",
    "rootCause": "Due to the shared pools between two different contracts\nThis shared pool address between the old and new contract versions led to the execution of fund transfers originating from the same address but targeting different pools.\n\nThe attacker initiated the process by using NFT tokens as collateral to borrow assets from the new version of the pool. Subsequently, they executed another flash loan from the old version of the pool, utilizing it to repay their initially borrowed assets.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x2405913d54fc46eeaf3fb092bfb099f46803872f](https://etherscan.io/address/0x2405913d54fc46eeaf3fb092bfb099f46803872f)\n\nold version:\n\n[https://etherscan.io/address/0x2405913d54fc46eeaf3fb092bfb099f46803872f](https://etherscan.io/address/0x2405913d54fc46eeaf3fb092bfb099f46803872f)\n\nnew version:\n\n[https://etherscan.io/address/0xc3f4659588b13f23e09ec54783a3c407e39ad589](https://etherscan.io/address/0xc3f4659588b13f23e09ec54783a3c407e39ad589)\n\nAttack tx:\n\n// NFT buy Tx: [https://explorer.phalcon.xyz/tx/eth/0x2f328016764ecf1f57fda0f5490087a5ddba83706b51cf518bdbd7e65ae2383b](https://explorer.phalcon.xyz/tx/eth/0x2f328016764ecf1f57fda0f5490087a5ddba83706b51cf518bdbd7e65ae2383b)\n// Borrow Tx: [https://explorer.phalcon.xyz/tx/eth/0xf4f254c3c6b64ded778b5af292c6ab6ed886c1bdd8988510bdc0ca0cf7f9857e](https://explorer.phalcon.xyz/tx/eth/0xf4f254c3c6b64ded778b5af292c6ab6ed886c1bdd8988510bdc0ca0cf7f9857e)\n// Attack Tx : [https://explorer.phalcon.xyz/tx/eth/0xec7523660f8b66d9e4a5931d97ad8b30acc679c973b20038ba4c15d4336b393d](https://explorer.phalcon.xyz/tx/eth/0xec7523660f8b66d9e4a5931d97ad8b30acc679c973b20038ba4c15d4336b393d)\n\nAnalysis:\n\n[https://medium.com/neptune-mutual/analysis-of-the-pine-protocol-exploit-e09dbcb80ca0](https://medium.com/neptune-mutual/analysis-of-the-pine-protocol-exploit-e09dbcb80ca0)\n\n[https://blog.solidityscan.com/pine-protocol-hack-analysis-7ce8621f444b](https://blog.solidityscan.com/pine-protocol-hack-analysis-7ce8621f444b)",
    "images": [],
    "Lost": "$90k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/PineProtocol_exp.sol"
  },
  "TransitFinance": {
    "type": "Insufficient validation",
    "date": "2023-12-20",
    "rootCause": "1. The vulnerability\u2019s root cause was the lack of proper input validation.\n2. The vulnerability allowed the attacker to use a forged pool and manipulate the WBNB/BUSD pool path. It can be seen on the\u00a0[**vulnerable contract**](https://bscscan.com/address/0x00000047bb99ea4d791bb749d970de71ee0b1a34#code)\u00a0that along the swapping route, the pre-deployed fake token pair would return a false value without actually transferring any tokens to mislead the transit finance route into validating the unexpected swap.\n3. The attacker manipulated the first swap by controlling the actualAmountIn parameter, substituting it with a forged value.\n4. This led to the SwapRouter using the manipulated actualAmountIn as the initial value for the swap in the WBNB/BUSD pool.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x00000047bb99ea4d791bb749d970de71ee0b1a34#code](https://bscscan.com/address/0x00000047bb99ea4d791bb749d970de71ee0b1a34#code)\n\n```jsx\n   function _executeV3Swap(ExactInputV3SwapParams calldata params) internal nonReentrant whenNotPaused returns (uint256 returnAmount) {\n        require(params.pools.length > 0, \"Empty pools\");\n        require(params.deadline >= block.timestamp, \"Expired\");\n        require(_wrapped_allowed[params.wrappedToken], \"Invalid wrapped address\");\n        address tokenIn = params.srcToken;\n        address tokenOut = params.dstToken;\n        uint256 actualAmountIn = calculateTradeFee(true, params.amount, params.fee, params.signature);\n        uint256 toBeforeBalance;\n        bool isToETH;\n        if (TransferHelper.isETH(params.srcToken)) {\n            tokenIn = params.wrappedToken;\n            require(msg.value == params.amount, \"Invalid msg.value\");\n            TransferHelper.safeDeposit(params.wrappedToken, actualAmountIn);\n        } else {\n            TransferHelper.safeTransferFrom(params.srcToken, msg.sender, address(this), params.amount);\n        }\n\n        if (TransferHelper.isETH(params.dstToken)) {\n            tokenOut = params.wrappedToken;\n            toBeforeBalance = IERC20(params.wrappedToken).balanceOf(address(this));\n            isToETH = true;\n        } else {\n            toBeforeBalance = IERC20(params.dstToken).balanceOf(params.dstReceiver);\n        }\n\n        {\n            uint256 len = params.pools.length;\n            address recipient = address(this);\n            bytes memory tokenInAndPoolSalt;\n            if (len > 1) {\n                address thisTokenIn = tokenIn;\n                address thisTokenOut = address(0);\n                for (uint256 i; i < len; i++) {\n                    uint256 thisPool = params.pools[i]; <-- Vulnerable point\n                    (thisTokenIn, tokenInAndPoolSalt) = _verifyPool(thisTokenIn, thisTokenOut, thisPool);\n                    if (i == len - 1 && !isToETH) {\n                        recipient = params.dstReceiver;\n                        thisTokenOut = tokenOut;\n                    } \n                    actualAmountIn = _swap(recipient, thisPool, tokenInAndPoolSalt, actualAmountIn);\n                }\n                returnAmount = actualAmountIn;\n            } else {\n                (, tokenInAndPoolSalt) = _verifyPool(tokenIn, tokenOut, params.pools[0]);\n                if (!isToETH) {\n                    recipient = params.dstReceiver;\n                }\n                returnAmount = _swap(recipient, params.pools[0], tokenInAndPoolSalt, actualAmountIn);\n            }\n        }\n```\n\n\n\nfake pool: address pool_usd_wbnb = [0x36696169C63e42cd08ce11f5deeBbCeBae652050](https://bscscan.com/address/0x36696169C63e42cd08ce11f5deeBbCeBae652050);\n\nAttack tx:\n\n[https://www.oklink.com/es-la/multi-search#key=0x93ae5f0a121d5e1aadae052c36bc5ecf2d406d35222f4c6a5d63fef1d6de1081](https://www.oklink.com/es-la/multi-search#key=0x93ae5f0a121d5e1aadae052c36bc5ecf2d406d35222f4c6a5d63fef1d6de1081)\n\n[https://app.blocksec.com/explorer/tx/bsc/0x93ae5f0a121d5e1aadae052c36bc5ecf2d406d35222f4c6a5d63fef1d6de1081](https://app.blocksec.com/explorer/tx/bsc/0x93ae5f0a121d5e1aadae052c36bc5ecf2d406d35222f4c6a5d63fef1d6de1081)\n\n\n\nAnalysis:\n\n[https://blog.solidityscan.com/transit-finance-hack-analysis-998400e2bd0c](https://blog.solidityscan.com/transit-finance-hack-analysis-998400e2bd0c)\n\n[https://lunaray.medium.com/transitfinace-hack-analysis-9304a4863aaa](https://lunaray.medium.com/transitfinace-hack-analysis-9304a4863aaa)\n\n[https://blog.verichains.io/p/decoding-transit-finance-attack](https://blog.verichains.io/p/decoding-transit-finance-attack)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Lack_Screenshot_2024-06-24_at_2.34.09_PM.png"
    ],
    "Lost": "$110k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/TransitFinance_exp.sol"
  },
  "FloorProtocol": {
    "type": "Business Logic Flaw",
    "date": "2023-12-17",
    "rootCause": "Attackers exploited the vulnerability by calling the multicall function in the Forwarder contract, altering the last 20 bytes of calldata to the attacker\u2019s address to execute the attack.\n\nVulnerable code snippet:\n\n\n\n\n\nAttack tx:\n\n[https://explorer.phalcon.xyz/tx/eth/0xec8f6d8e114caf8425736e0a3d5be2f93bbea6c01a50a7eeb3d61d2634927b40](https://explorer.phalcon.xyz/tx/eth/0xec8f6d8e114caf8425736e0a3d5be2f93bbea6c01a50a7eeb3d61d2634927b40)\n\nAnalysis:\n\n[https://medium.com/@Jingkangchua/vulnerability-analysis-erc2771-multicall-545cad1f9028](https://medium.com/@Jingkangchua/vulnerability-analysis-erc2771-multicall-545cad1f9028)\n\n[https://blog.verichains.io/p/address-spoofing-attack-the-combination](https://blog.verichains.io/p/address-spoofing-attack-the-combination)\n\n\n\n### Solution\n\n1. Use the latest version with the vulnerability fixed. OpenZeppelin\u2019s new\nversion of Multicall includes the context suffix length for ERC2771\ncontext data, identifying the expected context suffix length for\nERC-2771.",
    "images": [
      "images/Business_Untitled.webp",
      "images/Untitled%201.webp",
      "images/FloorProtocol_Untitled.jpeg"
    ],
    "Lost": "$1,6M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/FloorProtocol_exp.sol"
  },
  "GoodDollar": {
    "type": "Insufficient validation, Reentrancy",
    "date": "2023-12-16",
    "rootCause": "_stakingContracts l**ack of Input Validation & Reentrancy**\n\nVulnerable code snippet:\n\n[https://www.oklink.com/es-la/eth/address/0x0c6c80d2061afa35e160f3799411d83bdeea0a5a/contract](https://www.oklink.com/es-la/eth/address/0x0c6c80d2061afa35e160f3799411d83bdeea0a5a/contract)\n\n```jsx\n\t/**\n\t * @dev Collects UBI interest in iToken from a given staking contract and transfers\n\t * that interest to the reserve contract. Then transfers the given gd which\n\t * received from the reserve contract back to the staking contract and to the\n\t * bridge, which locks the funds and then the GD tokens are been minted to the\n\t * given address on the sidechain\n\t * @param _stakingContracts from which contracts to collect interest\n\t * @param _forceAndWaiverRewards if set to true, it will collect interest even if not passed thershold, but will not reward caller with gas refund + reward\n\t */\n\tfunction collectInterest(\n\t\taddress[] calldata _stakingContracts, <-- vulnerable point: untrusted input\n\t\tbool _forceAndWaiverRewards\n\t) external {\n\t\tuint256 initialGas = gasleft();\n\t\tuint256 gdUBI;\n\t\tuint256 interestInCdai;\n\t\taddress reserveAddress;\n\t\t{\n\t\t\t// require(\n\t\t\t// \tblock.timestamp >= lastCollectedInterest + minCollectedInterestIntervalDays * days,\n\t\t\t// \t\"collectInterest: collect interval not passed\"\n\t\t\t// );\n\t\t\t//prevent stack too deep\n\t\t\tcERC20 iToken = cERC20(nameService.getAddress(\"CDAI\"));\n\t\t\tERC20 daiToken = ERC20(nameService.getAddress(\"DAI\"));\n\t\t\treserveAddress = nameService.getAddress(\"RESERVE\");\n\t\t\t// DAI balance of the reserve contract\n\t\t\tuint256 currentBalance = daiToken.balanceOf(reserveAddress);\n\t\t\tuint256 startingCDAIBalance = iToken.balanceOf(reserveAddress);\n\t\t\tfor (uint256 i = _stakingContracts.length; i > 0; i--) {\n\t\t\t\t// elements are sorted by balances from lowest to highest\n\n\t\t\t\tif (_stakingContracts[i - 1] != address(0x0)) {\n\t\t\t\t\tIGoodStaking(_stakingContracts[i - 1]).collectUBIInterest(\n\t\t\t\t\t\treserveAddress\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Finds the actual transferred DAI\n\t\t\tuint256 daiToConvert = daiToken.balanceOf(reserveAddress) -\n\t\t\t\tcurrentBalance;\n\n\t\t\t// Mints gd while the interest amount is equal to the transferred amount\n\t\t\t(gdUBI, interestInCdai) = GoodReserveCDai(reserveAddress).mintUBI(\n\t\t\t\tdaiToConvert,\n\t\t\t\tstartingCDAIBalance,\n\t\t\t\tiToken\n\t\t\t);\n\t\t}\n\n\t\tuint256 gdRewardToMint;\n\n\t\tif (_forceAndWaiverRewards == false) {\n\t\t\tuint256 totalUsedGas = ((initialGas - gasleft() + gdMintGasCost) * 110) /\n\t\t\t\t100; // We will return as reward 1.1x of used gas in GD\n\t\t\tgdRewardToMint = getGasPriceInGD(totalUsedGas);\n\n\t\t\tGoodReserveCDai(reserveAddress).mintRewardFromRR(\n\t\t\t\tnameService.getAddress(\"CDAI\"),\n\t\t\t\tmsg.sender,\n\t\t\t\tgdRewardToMint\n\t\t\t);\n\n\t\t\tuint256 gasPriceIncDAI = getGasPriceIncDAIorDAI(totalUsedGas, false);\n\n\t\t\tif (\n\t\t\t\tblock.timestamp >= lastCollectedInterest + collectInterestTimeThreshold\n\t\t\t) {\n\t\t\t\trequire(interestInCdai >= gasPriceIncDAI, \"UBI < gas costs\"); // This require is necessary to keeper can not abuse this function\n\t\t\t} else {\n\t\t\t\trequire(\n\t\t\t\t\tinterestInCdai >= interestMultiplier * gasPriceIncDAI ||\n\t\t\t\t\t\tgdUBI >= interestMultiplier * gdRewardToMint,\n\t\t\t\t\t\"UBI <  X*gas costs\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\temit FundsTransferred(\n\t\t\tmsg.sender,\n\t\t\treserveAddress,\n\t\t\t_stakingContracts,\n\t\t\tinterestInCdai,\n\t\t\tgdUBI,\n\t\t\tgdRewardToMint\n\t\t);\n\n\t\tlastCollectedInterest = block.timestamp;\n\t\tlastCollectedInterestBlock = block.number;\n\t}\n\t\n\tPOC:\n    // Callback function. This function will be called from collectInterest()\n    function collectUBIInterest(\n        address _recipient\n    ) external returns (uint256, uint256, uint256) {\n        cDAI.approve(address(GDX), type(uint256).max);\n        // Reentrancy\n        GDX.buy(cDAI.balanceOf(address(this)), 1, address(this));\n        return (0, 0, 0);\n    }\n}\n```\n\nAttack tx:\n\n[https://www.oklink.com/es-la/eth/tx/0x726459a46839c915ee2fb3d8de7f986e3c7391c605b7a622112161a84c7384d0](https://www.oklink.com/es-la/eth/tx/0x726459a46839c915ee2fb3d8de7f986e3c7391c605b7a622112161a84c7384d0)\n\n[https://app.blocksec.com/explorer/tx/eth/0x726459a46839c915ee2fb3d8de7f986e3c7391c605b7a622112161a84c7384d0](https://app.blocksec.com/explorer/tx/eth/0x726459a46839c915ee2fb3d8de7f986e3c7391c605b7a622112161a84c7384d0)\n\nAnalysis:\n\n[https://x.com/MetaSec_xyz/status/1736428284756607386](https://x.com/MetaSec_xyz/status/1736428284756607386)\n\n\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Lack_Screenshot_2024-06-21_at_2.27.32_PM.png"
    ],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/GoodDollar_exp.sol"
  },
  "NFTTrader": {
    "type": "Reentrancy",
    "date": "2023-12-16",
    "rootCause": "The \"editCounterPart**\" function which allows changing swap counterparties can be called externally and lacked reentrancy protection.\n\n**Exploiting via editCounterPart**\n\n-- After initiating closeSwapIntent, the attacker makes a reentrant call to the **\"editCounterPart\" function of the BatchSwap contract.\n-- Unlike closeSwapIntent, **editCounterPart** lacks reentrancy protection.\n-- The attacker changes the counterparty of the swap to another address they control (0x01de...). This is a critical state change and manipulates the intended flow of the swap.\n\nVulnerable code snippet:\n\n[https://www.oklink.com/es-la/eth/address/0xc310e760778ecbca4c65b6c559874757a4c4ece0/contract](https://www.oklink.com/es-la/eth/address/0xc310e760778ecbca4c65b6c559874757a4c4ece0/contract)\n\n```jsx\n    function editCounterPart(uint256 _swapId, address payable _counterPart) public {\n        require(msg.sender == swapList[msg.sender][swapMatch[_swapId]].addressOne, \"Message sender must be the swap creator\");\n        swapList[msg.sender][swapMatch[_swapId]].addressTwo = _counterPart;\n    }\n\n```\n\nAttack tx:\n\n[https://www.oklink.com/es-la/eth/tx/0xec7523660f8b66d9e4a5931d97ad8b30acc679c973b20038ba4c15d4336b393d](https://www.oklink.com/es-la/eth/tx/0xec7523660f8b66d9e4a5931d97ad8b30acc679c973b20038ba4c15d4336b393d)\n\nAttacker : 0xb1EdF2a0BA8Bc789cBc3DFbe519737cAdA034D2D\n\nAnalysis:\n\n[https://x.com/SlowMist_Team/status/1736005523550646535](https://x.com/SlowMist_Team/status/1736005523550646535)\n\n[https://x.com/0xArhat/status/1736038250190651467](https://x.com/0xArhat/status/1736038250190651467)\n\n\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Reentrancy_Screenshot_2024-06-21_at_1.53.59_PM.png"
    ],
    "Lost": "$3M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/NFTTrader_exp.sol"
  },
  "HYPR": {
    "type": "Business Logic Flaw",
    "date": "2023-12-13",
    "rootCause": "The root cause was that the attacker managed to circumvent the 'finalizeERC20Withdrawal' function check by reinitializing the contract, due to the existence of the 'clearLegacySlot' modifier.\n\nVulnerable code snippet:\n\n[https://www.oklink.com/es-la/eth/address/0x40c31236b228935b0329eff066b1ad96e319595e/contract](https://www.oklink.com/es-la/eth/address/0x40c31236b228935b0329eff066b1ad96e319595e/contract)\n\n\n\n\u200d\n\n\u00a0The\u00a0`clearLegacySlot`\u00a0modifier here will reset the value of the storage slot 0. This action, in turn, resets the value of storage slot 0 of the\u00a0`Initializable`\u00a0contract (to verify this, we can inspect the inheritance chain of the\u00a0`L1StandardBridge`\u00a0contract). If we read the comments carefully, we\u2019ll know that the current version of this code is not ready for production. So, that\u2019s the reason why this function can be called multiple times.\n\n\n\nAttack tx:\n\n[https://www.oklink.com/es-la/eth/tx/0x51ce3d9cfc85c1f6a532b908bb2debb16c7569eb8b76effe614016aac6635f65](https://www.oklink.com/es-la/eth/tx/0x51ce3d9cfc85c1f6a532b908bb2debb16c7569eb8b76effe614016aac6635f65)\n\n[https://explorer.phalcon.xyz/tx/eth/0x51ce3d9cfc85c1f6a532b908bb2debb16c7569eb8b76effe614016aac6635f65](https://explorer.phalcon.xyz/tx/eth/0x51ce3d9cfc85c1f6a532b908bb2debb16c7569eb8b76effe614016aac6635f65)\n\nAnalysis:\n\n[https://x.com/BlockSecTeam/status/1735197818883588574](https://x.com/BlockSecTeam/status/1735197818883588574)\n\n[https://blog.verichains.io/p/hypers-op-stack-bridge-exploit-analysis](https://blog.verichains.io/p/hypers-op-stack-bridge-exploit-analysis)\n\n\n\n\n\nREF Link:\n\n[https://www.hypr.network/articles/incident-postmortem-bridge-exploit](https://www.hypr.network/articles/incident-postmortem-bridge-exploit)",
    "images": [
      "images/6579ee561048a501aecd030c_iKcTKppb0Jaaq-9jqE8yi_87dMKppww2Qg1llquCmoLUGkRyykBapTP3lbSc6CaaaIAXtJIRqp4bNUHnqKacA2CKnFTH07HpV36Ub2R_OtwhvTlSu860aR12ndughpfFT-AaFnPIeIWkWt8JezEwFZw.jpeg",
      "images/6579ee56b307f2e239586310_6Y3BJUjm61mEaE_LVVc_dU2OeVkC-TpfEixhwrqK5VORGnJqQ0XP_MrJKUK8tHXg0KB3aGYavlpXPy8UaHtyvhhycLEIUb6Q-wr0Q2P7L7o9AaLir_BjpIz_F1RkiAoafvQ0CpCC8zIuUbetgBel1tk.jpeg",
      "images/Signature_Untitled.png",
      "images/Business_Screenshot_2024-06-21_at_12.56.49_PM.png"
    ],
    "Lost": "$200k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/HYPR_exp.sol"
  },
  "TIME": {
    "type": "Arbitrary call",
    "date": "2023-12-06",
    "rootCause": "The root cause of this incident was that the arbitrary external call function of the forwarder contract was maliciously used by the hacker.\n\nExecution using \u201cexecute()\u201d and \u201ccall()\u201d:\u00a0The \u201cexecute()\u201d function then called the \u201ccall()\u201d function, packaging \u2018req.data\u2019 and \u2018req.from\u2019 as parameters for the \u201ccall()\u201d function. The \u2018req.to\u2019 was specified as 0x4b0e9a7da8bab813efae92a6651019b8bd6c0a29 (TIME contract), and the selector of the multicall(bytes[]) function was 0xac9650d8.\n\nVulnerable code snippet:\n\n[https://www.oklink.com/es-la/eth/address/0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81/contract](https://www.oklink.com/es-la/eth/address/0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81/contract)\n\n```jsx\n  function execute(ForwardRequest calldata req, bytes calldata signature)\n        public\n        payable\n        returns (bool, bytes memory)\n    {\n        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n        _nonces[req.from] = req.nonce + 1;\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = req.to.call{ gas: req.gas, value: req.value }(\n            abi.encodePacked(req.data, req.from) <-- **vulnerable point, req.data**\n        );\n\n        if (!success) {\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n            if (result.length < 68) revert(\"Transaction reverted silently\");\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n        // Check gas: https://ronan.eth.link/blog/ethereum-gas-dangers/\n        assert(gasleft() > req.gas / 63);\n        return (success, result);\n    }\n}\n```\n\nAttack tx:\n\n[https://www.oklink.com/es-la/eth/tx/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6](https://www.oklink.com/es-la/eth/tx/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6)\n\n[https://explorer.phalcon.xyz/tx/eth/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6](https://explorer.phalcon.xyz/tx/eth/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6)\n\nAnalysis:\n\n[https://www.immunebytes.com/blog/time-token-hack-dec-7-2023-detailed-analysis-report/](https://www.immunebytes.com/blog/time-token-hack-dec-7-2023-detailed-analysis-report/)\n\n",
    "images": [
      "images/IT_Screenshot_2024-06-21_at_12.39.35_PM.png"
    ],
    "Lost": "84.59 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/TIME_exp.sol"
  },
  "ElephantStatus": {
    "type": "Price Manipulation",
    "date": "2023-12-06",
    "rootCause": "The unprotected sweep() function was exploited. \n\nVulnerable code snippet:\n\n[https://www.oklink.com/es-la/bsc/address/0x8cf0a553ab3896e4832ebcc519a7a60828ab5740/contract](https://www.oklink.com/es-la/bsc/address/0x8cf0a553ab3896e4832ebcc519a7a60828ab5740/contract)\n\nAttack tx:\n\n[https://www.oklink.com/es-la/bsc/tx/0xd423ae0e95e9d6c8a89dcfed243573867e4aad29ee99a9055728cbbe0a523439](https://www.oklink.com/es-la/bsc/tx/0xd423ae0e95e9d6c8a89dcfed243573867e4aad29ee99a9055728cbbe0a523439)\n\n[https://explorer.phalcon.xyz/tx/bsc/0xd423ae0e95e9d6c8a89dcfed243573867e4aad29ee99a9055728cbbe0a523439](https://explorer.phalcon.xyz/tx/bsc/0xd423ae0e95e9d6c8a89dcfed243573867e4aad29ee99a9055728cbbe0a523439)\n\n[https://app.blocksec.com/explorer/tx/bsc/0x7ccb189c78376bdc35294f1779e7156233bcbc65f8681b3d6a7f512c1c2d5218](https://app.blocksec.com/explorer/tx/bsc/0x7ccb189c78376bdc35294f1779e7156233bcbc65f8681b3d6a7f512c1c2d5218)\n\nAnalysis:\n\n// Unprotected function here. Call to sweep will rise WBNB price\nElephant.sweep(); \n\n[https://x.com/Phalcon_xyz/status/1732354930529435940](https://x.com/Phalcon_xyz/status/1732354930529435940)\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$165k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/ElephantStatus_exp.sol"
  },
  "UnverifiedContr_0x431abb": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2023-12-01",
    "rootCause": "The root cause is a logic flaw in reward calculation. The victim contract is unverified, and after decompilation by Blocksec team, we obtained the following results:\n\n\n\nv4 is the token amount to be distributed, which can be increased through a flash loan, reducing the token balance of v0.\n\nThe attacker first staked some tokens and executed a flash loan of BSC-USD from the pair, then claimed the reward within the flash loan callback. Since the BSC-USD amount in the pair decreases, the reward token amount is calculated incorrectly, allowing the attacker to take an excessive amount of tokens as a reward.\n\nVulnerable code snippet:\n\n[](https://bscscan.com/address/0x431abb27dab05f4e7cdeaa18390fe39364197500)\n\nAttack tx:\n\n- Claim Transaction\n    \n    [](https://bscscan.com/tx/0xbeea4ff215b15870e22ed0e4d36ccd595974ffd55c3d75dad2230196cc379a52)\n    \n- Stake Transaction\n\nAnalysis:\n\n[BlockSec Phalcon on Twitter / X](https://x.com/Phalcon_xyz/status/1730625352953901123)",
    "images": [
      "images/Flash_GARV53RbIAAhtbU.jpeg"
    ],
    "Lost": "$500k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-12/UnverifiedContr_0x431abb_exp.sol"
  },
  "CAROLProtocol": {
    "type": "Price Manipulation, Reentrancy",
    "date": "2023-11-30",
    "rootCause": "The `Carol::sell` function can be re-entered due to the lack of a reentrancy guard, allowing the attacker to swap more CAROL for WETH in each recursive call. The `getTokenLiquidity()` function will then return a disproportionate result, leading to the manipulation of `ethReserved`.\n\nVulnerable code snippet:\n\n```solidity\nfunction sell(uint256 tokensAmount) external {\n    require(userBalance(msg.sender) >= tokensAmount, \"Sell: insufficient balance\");\n\n    collect(msg.sender);\n    Models.User storage user = users[msg.sender];\n    require(user.balance >= tokensAmount, \"Sell: insufficient balance\");\n\n    user.balance-= tokensAmount;\n    user.lastActionTime = block.timestamp;\n\n    address[] memory path = new address[](2);\n    path[0] = TOKEN_ADDRESS;\n    path[1] = Constants.WRAPPED_ETH;\n\n    CAROLToken(TOKEN_ADDRESS).mint(address(this), tokensAmount);\n    CAROLToken(TOKEN_ADDRESS).increaseAllowance(UNISWAP_ROUTER_ADDRESS, tokensAmount);\n\t\t\n\t\t// Vulnerable Code Section\n    uint256[] memory amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactTokensForETH(\n      tokensAmount,\n      0,\n      path,\n      msg.sender,\n      block.timestamp + 5 minutes\n    );\n    uint256 ethAmount = amounts[1];\n    \n\n    (uint256 ethReserved, ) = getTokenLiquidity();\n    uint256 liquidity = ERC20(LP_TOKEN_ADDRESS).totalSupply()\n      * ethAmount\n      * (Constants.PERCENTS_DIVIDER + PRICE_BALANCER_PERCENT)\n      / Constants.PERCENTS_DIVIDER\n      / ethReserved;\n\n    ERC20(LP_TOKEN_ADDRESS).approve(\n      UNISWAP_ROUTER_ADDRESS,\n      liquidity\n    );\n\n    (, uint256 amountETH) = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).removeLiquidityETH(\n      TOKEN_ADDRESS,\n      liquidity, \n      0, \n      0, \n      address(this),\n      block.timestamp + 5 minutes\n    );\n\n    path[0] = Constants.WRAPPED_ETH;\n    path[1] = TOKEN_ADDRESS;\n    amounts = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).swapExactETHForTokens {value: amountETH} (\n      0,\n      path,\n      address(this),\n      block.timestamp + 5 minutes\n    );\n\n    emit Events.Sell(\n      msg.sender, tokensAmount, ethAmount, block.timestamp\n    );\n  }\n```\n\nAttack tx:\n\n- Preparation Transaction\n    \n    [0x6462f5e358eb2c7769 | Phalcon Explorer](https://app.blocksec.com/explorer/tx/base/0x6462f5e358eb2c7769e6aa59ce43277be4799b297bc4c9503610443b9d56cc24)\n    \n- Attack Transaction\n    \n    [0xd962d397a7f8b3aadc | Phalcon Explorer](https://app.blocksec.com/explorer/tx/base/0xd962d397a7f8b3aadce1622e705b9e33b430e86e0d306d6fb8ccbc5957b4185c)\n    \n\nAnalysis:\n\n[MetaSec on Twitter / X](https://x.com/MetaSec_xyz/status/1730496513359647167)",
    "images": [],
    "Lost": "$53k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/CAROLProtocol_exp.sol"
  },
  "AIS": {
    "type": "Insufficient validation",
    "date": "2023-11-29",
    "rootCause": "There is no access control in `AIS::setSwapPairs`, allowing the attacker to set pairs to arbitrary addresses. The attacker sets Pancakeswap as a valid pair and transfers tokens to the pair through `AIS::transfer`, subsequently executing the `Pancakeswap::skim` operation to profit.\n\n\n\nVulnerable code snippet:\n\n```solidity\n  function setSwapPairs(address _address) public { //onlyOwner {\n      Pairs[_address] = true;\n  }\n```\n\nAttack tx:\n\n[](https://bscscan.com/tx/0x0be817b6a522a111e06293435c233dab6576d7437d0e148b45efcf7ab8a10de0)\n\nAnalysis:\n\n[BlockSec Phalcon on Twitter / X](https://x.com/Phalcon_xyz/status/1729861048004391306/photo/1)",
    "images": [
      "images/Access_Screenshot_2024-07-18_at_10.05.26_AM.png"
    ],
    "Lost": "$61k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/AIS_exp.sol"
  },
  "TheNFTV2": {
    "type": "Business Logic Flaw, Incorrect logic",
    "date": "2023-11-25",
    "rootCause": "The attackers keep approving NFT token ID 1071 to themselves and burn the token. After the burn operation, they can retrieve the token through transferFrom and re-burn it repeatedly. During each operation, the attacker receives some $THEDAO tokens as a reward.\n\n\n\nVulnerable code snippet:\n\n- transferFrom\n\n```solidity\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external regulated(_to) {\n    require (_tokenId < max, \"index out of range\");\n    address o = ownership[_tokenId];\n    require (o == _from, \"_from must be owner\");\n    address a = approval[_tokenId];\n    require (o == msg.sender|| (a == msg.sender) || (approvalAll[o][msg.sender]), \"not permitted\");\n    _transfer(_from, _to, _tokenId);\n    if (a != address(0)) {\n        approval[_tokenId] = address(0); // clear previous approval\n        emit Approval(msg.sender, address(0), _tokenId);\n    }\n}\n```\n\n- Burn\n\n```solidity\nfunction burn(uint256 id) external {\n    require (msg.sender == ownership[id], \"only owner can burn\");\n    if (theDAO.transfer(msg.sender, oneDao)) {   // send theDAO token back to sender\n        _transfer(msg.sender, DEAD_ADDRESS, id); // burn the NFT token\n        emit Burn(msg.sender, id);\n    }\n}\n```\n\nAttack tx:\n\n[](https://etherscan.io/tx/0xd5b4d68432cbbd912130bbb5b93399031ddbb400d8f723c78050574de7533106)\n\nAnalysis:\n\n[MetaTrustAlert on Twitter / X](https://x.com/MetaTrustAlert/status/1728616715825848377?s=20)",
    "images": [
      "images/Logic_Screenshot_2024-07-18_at_10.18.25_AM.png"
    ],
    "Lost": "$19K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/TheNFTV2_exp.sol"
  },
  "KyberSwap": {
    "type": "Precision, Price Manipulation",
    "date": "2023-11-22",
    "rootCause": "- In the first swap, when calculating Ticks, there is ***incorrect rounding direction during the reinvestment process***. Thus the tick could be manipulated, and `_updateLiquidityAndCrossTick` 0could be bypassed.\n- In the second swap, the `_updateLiquidityAndCrossTick` is being triggered to increase liquidity. However, since there is precision loss in the first swap, the liquidity is then double counted.\n\nVulnerable code snippet:\n\nBy `blocksec` team:\n\n\n\nAttack tx:\n\n<aside>\n\ud83d\udca1 [https://phalcon.blocksec.com/explorer/tx/eth/0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3](https://phalcon.blocksec.com/explorer/tx/eth/0x485e08dc2b6a4b3aeadcb89c3d18a37666dc7d9424961a2091d6b3696792f0f3)\n\n</aside>\n\nAnalysis\n\n<aside>\n\ud83d\udca1 [https://blocksec.com/blog/yet-another-tragedy-of-precision-loss-an-in-depth-analysis-of-the-kyber-swap-incident-1](https://blocksec.com/blog/yet-another-tragedy-of-precision-loss-an-in-depth-analysis-of-the-kyber-swap-incident-1)\n\n</aside>",
    "images": [
      "images/KyberSwap_Untitled.png"
    ],
    "Lost": "$48M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/KyberSwap_exp.eth.1.sol"
  },
  "Token8633_9419": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2023-11-17",
    "rootCause": "The attacker first borrows tokens through a flash loan and deposits them through `autoAddLp()` 130 times. After several swap operations, the attacker triggers `autoSwapAndAddToMarketing()` 900 times, swaps the tokens back, and returns the flash loan.\n\nVulnerable code snippet:\n\n[](https://bscscan.com/address/0x11cd2168fc420ae1375626655ab8f355f0075bd6#code)\n\nAttack tx:\n\n[0xf6ec3c22b718c3da17 | Phalcon Explorer](https://explorer.phalcon.xyz/tx/bsc/0xf6ec3c22b718c3da17746416992bac7b65a4ef42ccf5b43cf0716c82bffc2844)\n\nAnalysis:\n\nNone",
    "images": [],
    "Lost": "$52K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/Token8633_9419_exp.sol"
  },
  "ShibaToken": {
    "type": "ERC20",
    "date": "2023-11-17",
    "rootCause": "- The `balanceOf` function of `Shiba` is not changed, so it will return all balances(including the `locked` amount). This is not a best practice.\n- User could `transferLockToken` or `batchTransferLockToken` to the pair address. And the pair itself could not identify if the token is locked or not. As a result, the swap would still succeed. And the user could sell the `locked` token.\n\nVulnerable code snippet:\n\n```solidity\nfunction transferLockToken(address _wallet, uint256 _amount) public {\n    users[_wallet].lockedBalance   = users[_wallet].lockedBalance.add(_amount);\n    users[_wallet].unlockPerSecond = users[_wallet].lockedBalance.mul(unlockPercent).div(100).div(duration);\n\n    super.transfer(_wallet, _amount);\n}\n\nfunction batchTransferLockToken(Airdrop[] memory _airdrops) public {\n    for (uint256 i = 0; i < _airdrops.length; i++) {\n        // don't use this.transferTokenLock because payer modifier\n        address wallet = _airdrops[i].wallet;\n        uint256 amount = _airdrops[i].amount;\n\n        users[wallet].lockedBalance = users[wallet].lockedBalance.add(amount);\n        users[wallet].unlockPerSecond = users[wallet].lockedBalance.mul(unlockPercent).div(100).div(duration);\n\n        super.transfer(wallet, amount);\n    }\n}\n\nfunction transfer(address _to, uint256 _amount) public override returns (bool) {\n    uint256 availableAmount = getAvailableBalance(_msgSender());\n    require(availableAmount >= _amount, \"Not Enough Available Token\");\n\n    return super.transfer(_to, _amount);\n}\n```\n\nAttack tx:\n\nhttps://explorer.phalcon.xyz/tx/bsc/0x75a26224da9faf37c2b3a4a634a096af7fec561f631a02c93e11e4a19d159477\n\nAnalysis:\n\nhttps://app.blocksec.com/explorer/tx/bsc/0x75a26224da9faf37c2b3a4a634a096af7fec561f631a02c93e11e4a19d159477",
    "images": [],
    "Lost": "$31K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/ShibaToken_exp.sol"
  },
  "LinkDAO": {
    "type": "Dex/AMM, Incorrect logic",
    "date": "2023-11-15",
    "rootCause": "This project is similar to Uniswap V2 and has a swap function. At the end of the function, there should be a correct `K` verification. In Uniswap V2, which takes a 0.3% protocol fee, the verification is as follows:\n\n```solidity\nuint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\nuint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\nrequire(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n```\n\nIt seems the victim contract takes a 0.03% protocol fee, but the verification is incorrect; it should multiply by (10000**2) instead of (1000**2).\n\nVulnerable code snippet:\n\n[](https://bscscan.com/address/0x6524a5fd3fec179db3b3c1d21f700da7abe6b0de)\n\nAttack tx:\n\n[0x4ed59e3013215c2725 | Phalcon Explorer](https://explorer.phalcon.xyz/tx/bsc/0x4ed59e3013215c272536775a966f4365112997a6eec534d38325be014f2e15ee)\n\nAnalysis:\n\n[BlockSec Phalcon on Twitter / X](https://x.com/phalcon_xyz/status/1725058908144746992)",
    "images": [],
    "Lost": "$30K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/LinkDao_exp.sol"
  },
  "OKC Project": {
    "type": "Flashloans, Reward",
    "date": "2023-11-14",
    "rootCause": "- The victim contract `MinerPool` requires `extcodesize!=0`(EOA check) before adding an address to `lpRewardProcessor` array to be eligible for rewards.\n- The victim contract `MinerPool` will distribute the rewards regardless of the LP holding time.\n\nThe attacker leveraged substantial flash loans to borrow a significant amount of USDT and exchanged it for a large quantity of OKC tokens to add liquidity. Additionally, due to the **absence of lock-up requirements for LP reward distribution** in the OKC project, the hacker promptly withdrew liquidity after receiving rewards, thereby claiming the incentives intended for liquidity providers from the project.\n\nVulnerable code snippet:\n\n(Screenshot from the detailed analysis)\n\n1. The check of EOA could be bypassed during the initialization of the contract.\n\n\n\n1. The reward is distributed regardless of the LP holding time.\n\n\n\nAttack tx:\n\nhttps://bscscan.com/tx/0xd85c603f71bb84437bc69b21d785f982f7630355573566fa365dbee4cd236f08\n\nAnalysis:\n\nhttps://lunaray.medium.com/okc-project-hack-analysis-0907312f519b",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$6268",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/OKC_exp.sol"
  },
  "MEVBot_0x8c2d": {
    "type": "Access Control",
    "date": "2023-11-12",
    "rootCause": "- Due to the Lack of Access Control, anyone could designate himself with the privileged role of the MEV bot. Thus the privileged operation could be performed to harvest the assets.\n\nAttack Path:\n\n(from blocksec team)\n\n\n\nAttack tx:\n\n[https://explorer.phalcon.xyz/tx/bsc/0x3dcb26a1f49eb4d02ca29960b4833bfb2e83d7b5d9591aed1204168944c8c9b3](https://explorer.phalcon.xyz/tx/bsc/0x3dcb26a1f49eb4d02ca29960b4833bfb2e83d7b5d9591aed1204168944c8c9b3)\n\nAnalysis\n\n[https://twitter.com/Phalcon_xyz/status/1723897569661657553](https://twitter.com/Phalcon_xyz/status/1723897569661657553)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$365K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/MEV_0x8c2d_exp.sol"
  },
  "MEVBot_0xa247": {
    "type": "Access Control, Insufficient validation",
    "date": "2023-11-12",
    "rootCause": "The attack on unverified contracts is created by 0x3904ef. The flaw was in function 0xe7d25975, which lacked access control and allowed the attacker to set `_removeAdmin` and withdraw tokens. For example, in contract 0xa24734, the attacker used this flaw to withdraw RAIL tokens and convert them to ETH.\n\nVulnerable code snippet:\n\nBy blocksec team\n\n\n\nAttack tx:\n\n- transaction 1\n\n[0x53eeab4447db331dbb | Phalcon Explorer](https://app.blocksec.com/explorer/tx/eth/0x53eeab4447db331dbb47f93fd58a95d6faa230d559acde0687f8b5f5829e7a45)\n\n- transaction 2\n\n[0x573199feba92ab6577 | Phalcon Explorer](https://t.co/6KcL5OMqoJ)\n\n- transaction 3\n\n[0xb56e984a866afed36c | Phalcon Explorer](https://t.co/2nnjKSbIOJ)\n\n- transaction 4\n\n[0xdfbfb0387129541c65 | Phalcon Explorer](https://t.co/85ueRdaNSZ)\n\nAnalysis:\n\n[BlockSec Phalcon on Twitter / X](https://x.com/Phalcon_xyz/status/1723591214262632562)\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:",
    "images": [
      "images/Access_F-ti3_vaMAAdkF0.jpeg"
    ],
    "Lost": "$150K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/MEV_0xa247_exp.sol"
  },
  "MahaLend": {
    "type": "Precision",
    "date": "2023-11-11",
    "rootCause": "- This is a common vulnerability which also affects `RDNT` and other protocols, which involves precision expansion and rounding.\n- The `rayDiv` function is known to have rounding issues, and the attacker could try to manipulate the input `b` to  to cause the rounded value to increase to a similar magnitude. In such case, during operations like withdrawing, the actual value would be much smaller than expected due to rounding issues.\n\nVulnerable code snippet:\n\n```jsx\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/eth/0x2881e839d4d562fad5356183e4f6a9d427ba6f475614ce8ef64dbfe557a4a2cc](https://app.blocksec.com/explorer/tx/eth/0x2881e839d4d562fad5356183e4f6a9d427ba6f475614ce8ef64dbfe557a4a2cc)\n\nAnalysis\n\nhttps://x.com/Phalcon_xyz/status/1723223766350832071\n\n[https://beosin.com/resources/how-radiant-capital-was-exploited-by-hackers-for-a-45-million\u00a0heist?lang=zh-HK](https://beosin.com/resources/how-radiant-capital-was-exploited-by-hackers-for-a-45-million%C2%A0heist?lang=zh-HK)",
    "images": [],
    "Lost": "$20 K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/MahaLend_exp.sol"
  },
  "Raft_fi": {
    "type": "Precision",
    "date": "2023-11-10",
    "rootCause": "- Through `donation` and `self-liquidation`, the variable `collateralIndex` could be manipulated, thus the calculation for minted share amount could be manipulated via precision loss.\n- The minting in `rcbETH-c` uses rounding-up, which could mint `1` share instead of `0` when dust of amount collateral is added.\n- With shares of `cbETH`,  attacker could redeem the shares for profits.\n\nAttack Path:\n\n(from blocksec)\n\n\n\nAttack tx:\n\nhttps://etherscan.io/tx/0xfeedbf51b4e2338e38171f6e19501327294ab1907ab44cfd2d7e7336c975ace7\n\nAnalysis:\n\nhttps://x.com/BlockSecTeam/status/1723229393529835972",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$3.2 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/Raft_exp.sol"
  },
  "grok": {
    "type": "Insufficient validation, Slippage",
    "date": "2023-11-10",
    "rootCause": "The protocol lost 26 ETH due to insufficient slippage control. The attacker exploited the `_transfer` function in the GROK contract to trigger `swapTokensForEth` when the balance surpassed `_taxSwapThreshold`, allowing them to harvest and convert extra GROK tokens into ETH. As shown in the Vulnerable Code Snippet section, there is no slippage check in the interaction with the Uniswap V2 router.\n\nVulnerable code snippet:\n\n```solidity\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n        tokenAmount,\n        0, // No Slippage Check\n        path,\n        address(this),\n        block.timestamp\n    );\n}\n```\n\nAttack tx:\n\n[0x3e9bcee951cdad8480 | Phalcon Explorer](https://explorer.phalcon.xyz/tx/eth/0x3e9bcee951cdad84805e0c82d2a1e982e71f2ec301a1cbd344c832e0acaee813?line=136)\n\nAnalysis:\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:\n\n[BlockSec Phalcon on Twitter / X](https://twitter.com/Phalcon_xyz/status/1722841076120130020)",
    "images": [],
    "Lost": "26 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/grok_exp.sol"
  },
  "TrustPad": {
    "type": "Access Control, Reward",
    "date": "2023-11-06",
    "rootCause": "- The function `receiveUpPool` has no access control or `msg.sender` validation, as a result, it could be called by anyone to manipulate the `newlockstartTime`.\n- By repeatedly calling `receiveUpPool` and `withdraw` , the attacker could keep claiming rewards.\n\nVulnerable code snippet:\n\n- Function `receiveUpPool`: Here `msg.sender` could be different from `account`\n\n```solidity\n    function receiveUpPool(address account, uint256 amount) external {\n        require(account != address(0), 'Must specify valid account');\n        require(amount > 0, 'Must specify non-zero amount');\n\n        UserInfo storage user = userInfo[account];\n\n        // Re-lock (using old date if already locked)\n        // With lock start == block.timestamp, rewardDebt will be reset to 0 - marking the new locking period rewards countup.\n        uint256 newLockStartTime;\n        if (isLocked(account)) {\n            newLockStartTime = depositLockStart[account];\n        } else {\n            newLockStartTime = LaunchpadLockableStaking(msg.sender).isLocked(account)\n                ? LaunchpadLockableStaking(msg.sender).depositLockStart(account)\n                : block.timestamp;\n        }\n        updateDepositLockStart(account, newLockStartTime);\n        emit Locked(account, amount, lockPeriod, 0);\n        ...\n    }\n```\n\nAttack tx:\n\n[https://explorer.phalcon.xyz/tx/bsc/0x191a34e6c0780c3d1ab5c9bc04948e231d742b7d88e0e4f85568d57fcdc03182](https://explorer.phalcon.xyz/tx/bsc/0x191a34e6c0780c3d1ab5c9bc04948e231d742b7d88e0e4f85568d57fcdc03182)\n\nAnalysis:\n\n[https://twitter.com/BeosinAlert/status/1721800306101793188](https://twitter.com/BeosinAlert/status/1721800306101793188)",
    "images": [],
    "Lost": "$155K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/TrustPad_exp.sol"
  },
  "TheStandard_io": {
    "type": "Slippage",
    "date": "2023-11-06",
    "rootCause": "- There is no slippage protection when swapping out collateral.\n- There is no protection against bad debt.\n- There is no whitelist of tokens to trade.\n\nAs a result, the attacker could force the vault contract to swap in a low-liquidity pool which is manipulated. As a result, all collaterals are lost.\n\nVulnerable code snippet:\n\n```solidity\n    function swap(bytes32 _inToken, bytes32 _outToken, uint256 _amount) external onlyOwner {\n        uint256 swapFee = _amount * ISmartVaultManagerV2(manager).swapFeeRate() / ISmartVaultManager(manager).HUNDRED_PC();\n        address inToken = getSwapAddressFor(_inToken);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n                tokenIn: inToken,\n                tokenOut: getSwapAddressFor(_outToken),\n                fee: 3000,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: _amount - swapFee,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n        inToken == ISmartVaultManagerV2(manager).weth() ?\n            executeNativeSwapAndFee(params, swapFee) :\n            executeERC20SwapAndFee(params, swapFee);\n    }\n```\n\nAttack tx:\n\nhttps://explorer.phalcon.xyz/tx/arbitrum/0x51293c1155a1d33d8fc9389721362044c3a67e0ac732b3a6ec7661d47b03df9f\n\nAnalysis:\n\nhttps://twitter.com/Phalcon_xyz/status/1721807569222549518",
    "images": [],
    "Lost": "$290K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/TheStandard_io_exp.sol"
  },
  "BRA": {
    "type": "ERC20, skim",
    "date": "2023-01-10",
    "rootCause": " \n\nThe root cause is due to a logic flaw of the BRA contract, which doubles reward the tax fee to the pancake pair without invoking the sync() function after transferring.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction _transfer(address sender, address recipient, uint amount) internal {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n\n        bool recipientAllow = ConfigBRA(BRA).isAllow(recipient);\n        bool senderAllowSell = ConfigBRA(BRA).isAllowSell(sender);\n\n        uint BuyPer = ConfigBRA(BRA).BuyPer();\n        uint SellPer = ConfigBRA(BRA).SellPer();\n\n        address BuyTaxTo_ = address(0);\n        address SellTaxTo_ = address(0);\n\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n\n        uint256 finalAmount = amount;\n        uint256 taxAmount = 0;\n  \n        if(sender==uniswapV2Pair&&!recipientAllow){\n            taxAmount = amount.div(10000).mul(BuyPer);\n            BuyTaxTo_ = ConfigBRA(BRA).BuyTaxTo();\n        }\n\n        if(recipient==uniswapV2Pair&&!senderAllowSell){\n            taxAmount = amount.div(10000).mul(SellPer);\n            SellTaxTo_ = ConfigBRA(BRA).SellTaxTo();\n        }\n\n        finalAmount = finalAmount - taxAmount;\n\n        if(BuyTaxTo_ != address(0)){\n            _balances[BuyTaxTo_] = _balances[BuyTaxTo_].add(taxAmount);\n            emit Transfer(sender, BuyTaxTo_, taxAmount);\n        }\n\n        if(SellTaxTo_ != address(0)){\n            _balances[SellTaxTo_] = _balances[SellTaxTo_].add(taxAmount);\n            emit Transfer(sender, SellTaxTo_, taxAmount);\n        }\n        \n        _balances[recipient] = _balances[recipient].add(finalAmount);\n        \n        if (recipient == address(0) ) {\n            totalBurn = totalBurn.add(amount);\n            _totalSupply = _totalSupply.sub(amount);\n            emit Burn(sender, address(0), amount);\n        }\n        emit Transfer(sender, recipient, finalAmount);\n  \n    }\n\n```\n\n**Attack tx:** \n\n0x6759db55a4edec4f6bedb5691fc42cf024be3a1a534ddcc7edd471ef205d4047 (profit 675 WBNB)\n0x4e5b2efa90c62f2b62925ebd7c10c953dc73c710ef06695eac3f36fe0f6b9348 (profit 144 WBNB)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1612701106982862849](https://twitter.com/BlockSecTeam/status/1612701106982862849)",
    "images": [],
    "Lost": "$224K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BRA.exp.sol"
  },
  "3913Token": {
    "type": "ERC20, Flashloans, Reward",
    "date": "2023-11-02",
    "rootCause": "- The token uses `pair.reserves()` and `token.balanceOf(pair)` to determine if the current transaction is purchase or sell. However, this could be **manipulated** via sending tokens to the `pair` address and call `skim`\n- The token will distribute `inviteBonus`  to the `to` address without setting a upper limit for the reward.\n\nVulnerable code snippet:\n\n```solidity\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal returns (bool) {\n\t    require(!_robots[from], \"is robot\");\n\t    require(from != address(0), \"BEP20: transfer from the zero address\");\n\t    require(to != address(0), \"BEP20: transfer to the zero address\");\n\t    require(amount > 0, \"BEP20: transfer amount must be greater than zero\");\n\t\n\t    (bool isAdd, bool isDel) = _isLiquidity(from, to);\n\t    updateTime();\n\t    _burnToken(from);\n\t    _burnToken(to);\n\t    if (_v2Pairs[to] && !isAdd && from != address(this)) {\n\t      burnPairs();\n\t    }\n\t\n\t    if (_v2Pairs[from] && !isDel) {\n\t      _inviteBonus(to, amount);\n\t    }\n\t    ...\n\t }\n\t \n\t function _inviteBonus(address to, uint256 amount) private {\n\t    if (_users[to].pid != address(0)) {\n\t      uint256 balance_t = _balances[address(_smartVault_invite)];\n\t      if (balance_t == 0) return;\n\t\n\t      uint256 bunusAmount = amount.mul(_inviteRate).div(RBASE);\n\t      bunusAmount = bunusAmount > balance_t ? balance_t : bunusAmount;\n\t\n\t      _smartVault_invite.transfer(address(this), _users[to].pid, bunusAmount);\n\t    }\n  }\n```\n\nAttack tx:\n\n[https://bscscan.com/tx/0x8163738d6610ca32f048ee9d30f4aa1ffdb3ca1eddf95c0eba086c3e936199ed](https://bscscan.com/tx/0x8163738d6610ca32f048ee9d30f4aa1ffdb3ca1eddf95c0eba086c3e936199ed)\n\nAnalysis:\n\nhttps://defimon.xyz/attack/bsc/0x8163738d6610ca32f048ee9d30f4aa1ffdb3ca1eddf95c0eba086c3e936199ed\n\nhttps://www.immunebytes.com/blog/list-of-crypto-hacks-in-the-month-of-november/#Nov_",
    "images": [],
    "Lost": "$31354 USD$",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/3913_exp.sol"
  },
  "OnyxProtocol": {
    "type": "Precision, Price Manipulation",
    "date": "2023-11-01",
    "rootCause": "",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-11/OnyxProtocol_exp.sol"
  },
  "UniBotRouter": {
    "type": "Arbitrary call",
    "date": "2023-10-31",
    "rootCause": "The function `0xb2bd16ab` in the `UniBot` does not properly check input parameters. Thus anyone can use this function to arbitrarily call the external token contract and execute the transferFrom() method. Thus anyone who approves the `UniBot` contract may suffer from the attack.\n\nVulnerable code snippet:\n\n(from odaily.news)\n\n\n\nAttack tx:\n\nhttps://etherscan.io/tx/0xcbe521aea28911fe9983030748028e12541e347b8b6b974d026fa5065c22f0cf\n\nAnalysis:\n\nhttps://twitter.com/PeckShieldAlert/status/1719251390319796477",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$83,944 USD$",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/UniBot_exp.sol"
  },
  "AstridProtocol": {
    "type": "Insufficient validation",
    "date": "2023-10-28",
    "rootCause": "- The exploit is due to a vulnerability in the `withdraw`function which doesn\u2019t have enough check on the input token address and input amount.\n\nAs a result, attackers can manipulate the arguments for the withdraw function with counterfeit tokens.\n\nVulnerable code snippet:\n\n```solidity\n    function withdraw(address _restakedTokenAddress, uint256 amount) public nonReentrant whenNotPaused {\n        require(Utils.contractExists(_restakedTokenAddress), \"AstridProtocol: Contract does not exist\");\n        require(amount > 0, \"AstridProtocol: Amount must be greater than 0\");\n        require(IERC20(_restakedTokenAddress).balanceOf(msg.sender) >= amount, \"AstridProtocol: Insufficient balance of restaked token\");\n        require(IERC20(_restakedTokenAddress).allowance(msg.sender, address(this)) >= amount, \"AstridProtocol: Insufficient allowance of restaked token\");\n\n        uint256 sharesBefore = IRestakedETH(_restakedTokenAddress).scaledBalanceOf(address(this));\n\n        // receive restaked token from user to \"lock\" it\n@=>     bool amountSent = Utils.payMe(msg.sender, amount, _restakedTokenAddress);\n        require(amountSent, \"AstridProtocol: Failed to send restaked token\");\n\n        uint256 sharesAfter = IRestakedETH(_restakedTokenAddress).scaledBalanceOf(address(this));\n        uint256 shares = sharesAfter.sub(sharesBefore); // we store shares of restakedETH to ensure that it is still subject to rebase when locked\n\n        WithdrawalRequest memory request = WithdrawalRequest({\n            withdrawer: msg.sender,\n            restakedTokenAddress: _restakedTokenAddress,\n            amount: amount,\n            requestedRestakedTokenShares: shares,\n            claimableStakedTokenAmount: 0, // placeholder\n            status: WithdrawalStatus.REQUESTED,\n            withdrawalStartBlock: uint32(block.number),\n            withdrawRequestedAt: block.timestamp,\n            withdrawProcessedAt: 0,\n            withdrawClaimedAt: 0,\n            withdrawalRequestsIndex: withdrawalRequests.length,\n            withdrawalRequestsByUserIndex: withdrawalRequestsByUser[msg.sender].length\n        });\n\n        totalWithdrawalRequests[_restakedTokenAddress] += shares;\n        withdrawalRequests.push(request);\n        withdrawalRequestsByUser[msg.sender].push(request);\n\n        emit WithdrawalRequested(msg.sender, _restakedTokenAddress, amount, shares);\n\n        if (processWithdrawalsOnWithdraw) {\n@=>        _processWithdrawals();\n        }\n    }\n\nfunction _processWithdrawals() internal whenNotPaused {\n        uint256 _withdrawalRequestsLength = withdrawalRequests.length;\n        while(withdrawalProcessingCurrentIndex < _withdrawalRequestsLength) {\n            WithdrawalRequest memory request = withdrawalRequests[withdrawalProcessingCurrentIndex];\n            require(request.status == WithdrawalStatus.REQUESTED, \"AstridProtocol: Withdrawal status mismatch\");\n\n            address _restakedTokenAddress = request.restakedTokenAddress;\n@=>         address _stakedTokenAddress = IRestakedETH(_restakedTokenAddress).stakedTokenAddress();\n            uint256 requestedAmount = IRestakedETH(_restakedTokenAddress).scaledBalanceToBalance(request.requestedRestakedTokenShares);\n            if (requestedAmount > IERC20(_stakedTokenAddress).balanceOf(address(this)) - totalClaimableWithdrawals[_stakedTokenAddress]) {\n                break;\n            }\n\n            totalWithdrawalRequests[_restakedTokenAddress] -= request.requestedRestakedTokenShares;\n            IRestakedETH(_restakedTokenAddress).burn(address(this), requestedAmount);\n            totalClaimableWithdrawals[_stakedTokenAddress] += requestedAmount;\n\n            withdrawalRequests[withdrawalProcessingCurrentIndex].claimableStakedTokenAmount = requestedAmount;\n            withdrawalRequests[withdrawalProcessingCurrentIndex].status = WithdrawalStatus.PROCESSED;\n            withdrawalRequests[withdrawalProcessingCurrentIndex].withdrawProcessedAt = block.timestamp;\n\n            uint256 withdrawerIndex = request.withdrawalRequestsByUserIndex;\n            withdrawalRequestsByUser[request.withdrawer][withdrawerIndex].claimableStakedTokenAmount = requestedAmount;\n            withdrawalRequestsByUser[request.withdrawer][withdrawerIndex].status = WithdrawalStatus.PROCESSED;\n            withdrawalRequestsByUser[request.withdrawer][withdrawerIndex].withdrawProcessedAt = block.timestamp;\n\n            emit WithdrawalProcessed(withdrawalProcessingCurrentIndex);\n\n            withdrawalProcessingCurrentIndex += 1;\n        }\n    }\n```\n\nAttack tx:\n\nhttps://etherscan.io/tx/0x8af9b5fb3e2e3df8659ffb2e0f0c1f4c90d5a80f4f6fccef143b823ce673fb60\n\nAnalysis:\n\nhttps://twitter.com/Phalcon_xyz/status/1718454835966775325",
    "images": [],
    "Lost": "$127ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/Astrid_exp.sol"
  },
  "MaestroRouter2": {
    "type": "Arbitrary call",
    "date": "2023-10-24",
    "rootCause": "The `0x9239127f` function in the Maestro Router 2 contract has an external call vulnerability. Attackers can pass in a token address and use the `transferFrom` function with the victim's and their own addresses to transfer the victim's tokens.\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\n- transaction 1\n\n[](https://etherscan.io/tx/0xc087fbd68b9349b71838982e789e204454bfd00eebf9c8e101574376eb990d92)\n\n- transaction 2\n\n[](https://etherscan.io/tx/0xede874f9a4333a26e97d3be9d1951e6a3c2a8861e4e301787093cfb1293d4756)\n\n- transaction 3\n\n[](https://etherscan.io/tx/0xe60c5a3154094828065049121e244dfd362606c2a5390d40715ba54699ba9da6)\n\n- transaction 4\n\n[](https://etherscan.io/tx/0xf4ae22177c3abbb0f21defe51dd14eff68eb1b0c52ac4104186220138e8e5bb2)\n\n- transaction 5\n\n[](https://etherscan.io/tx/0x6cba3a67d6b8de664d860b096c8c558a1d65e5fa9735c657ddc98f67969561a2)\n\n- transaction 6\n\n[](https://etherscan.io/tx/0xddd1048fe3f2df1fb98e534a97173b32a9fca662dbd257a72725482431d3f25e)\n\n- transaction 7\n\n[](https://etherscan.io/tx/0xffb4bd29825bdd41adf344028f759692021cbadc2d4cb5b587e68fd8285c5eb1)\n\n- transaction 8\n\n[Ethereum Transaction Hash (Txhash) Details | Etherscan](https://etherscan.io/tx/0xa9948c8f0500a867091a090d12125f88868ac29e52af6391569094e82d416904)\n\n- transaction 9\n\n[](https://etherscan.io/tx/0xc49499325cb5ad3bf4391ae95855ce2ee2b0222f9282c524daa1c4586a8fcd8b)\n\n- transaction 10\n\n[](https://etherscan.io/tx/0xcfe1d2b333e1b9da5e2d5f1d7697b628c818cc41f9f3020187d4ce2c2610a05c)\n\n- transaction 11\n\n[Ethereum Transaction Hash (Txhash) Details | Etherscan](https://etherscan.io/tx/0x33f6adf410bbd0ae08b0cd44410de1e5b28e516434567113982fcac36ed9e1a4)\n\n- transaction 12\n\n[](https://etherscan.io/tx/0x4f4d6909a442b4d86f79a9044dcada6a128ddd9f62c26f410134a72d2fc31389)\n\nAnalysis:\n\n[BlockSec Phalcon on Twitter / X](https://twitter.com/Phalcon_xyz/status/1717014871836098663)\n\n[Beosin Alert on Twitter / X](https://twitter.com/BeosinAlert/status/1717013965203804457)",
    "images": [
      "images/IT_F9QOgxPaEAAdVW9.png"
    ],
    "Lost": "$280ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/MaestroRouter2_exp.sol"
  },
  "OpenLeverage2": {
    "type": "Logic Flaw",
    "date": "2024-04-01",
    "rootCause": "The attacker exploited a logic flaw in the liquidation process. By creating a margin trade with a small borrow and collateral, they triggered liquidation via the liquidate function, which incorrectly included margin-borrowed amounts in its calculations. Using the repayBorrowEndByOpenLev function, the attacker was able to liquidate the position with minimal repayment, resulting in a zero borrow balance. In a second transaction, they used the payoffTrade function to withdraw tokens without repaying the borrowed amount, as the borrow balance was already cleared. This exploit required two transactions due to a block time check.\n\nAttack tx:\n- https://app.blocksec.com/explorer/tx/bsc/0xf78a85eb32a193e3ed2e708803b57ea8ea22a7f25792851e3de2d7945e6d02d5\n- https://app.blocksec.com/explorer/tx/bsc/0x210071108f3e5cd24f49ef4b8bcdc11804984b0c0334e18a9a2cdb4cd5186067",
    "images": [],
    "Lost": "$234K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/OpenLeverage2_exp.sol"
  },
  "OpenLeverage": {
    "type": "Access Control, Insufficient validation",
    "date": "2023-10-22",
    "rootCause": "The initialize function in the upgradeable proxy lacks access control, allowing an attacker to re-initialize the proxy, become the owner of the contract, and withdraw all the tokens as a reward.\n\nVulnerable code snippet:\n\n```solidity\nfunction initialize(address payable _admin, address _distributor, uint64 _defaultExpireDuration) public {\n    require(_defaultExpireDuration > 0, \"Incorrect inputs\");\n    admin = _admin;\n    distributor = _distributor;\n    defaultExpireDuration = _defaultExpireDuration;\n}\n```\n\nAttack tx:\n\n[](https://bscscan.com/tx/0xd88f26f2f9145fa413db0cfd5d3eb121e3a50a3fdcee16c9bd4731e68332ce4b)\n\nAnalysis:\n\n[Exploit Contract: 0x5366c6ba729d9cf8d472500afc1a2976ac2fe9ff on bsc](https://defimon.xyz/exploit/bsc/0x5366c6ba729d9cf8d472500afc1a2976ac2fe9ff)",
    "images": [],
    "Lost": "$8K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/OpenLeverage_exp.sol"
  },
  "kTAF": {
    "type": "Precision",
    "date": "2023-10-19",
    "rootCause": "kTAF is a Compound fork project and was exploited due to the empty market issue in Compound v2. This rounding issue leads to the inflation of the exchange rate. Similar problems can be found in the following projects:\n\n[GitHub - YAcademy-Residents/defi-fork-bugs: Bugs in commonly forked DeFi protocols](https://github.com/YAcademy-Residents/defi-fork-bugs?tab=readme-ov-file)\n\nVulnerable code snippet:\n\n[](https://etherscan.io/address/0xf5140fc35c6f94d02d7466f793feb0216082d7e5)\n\nAttack tx:\n\n[](https://etherscan.io/tx/0x325999373f1aae98db2d89662ff1afbe0c842736f7564d16a7b52bf5c777d3a4)\n\nAnalysis:\n\n[Attack Transaction: 0x325999373f1aae98db2d89662ff1afbe0c842736f7564d16a7b52bf5c777d3a4 on mainnet](https://defimon.xyz/attack/mainnet/0x325999373f1aae98db2d89662ff1afbe0c842736f7564d16a7b52bf5c777d3a4)",
    "images": [],
    "Lost": "$8K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/kTAF_exp.sol"
  },
  "Hopelend": {
    "type": "Flashloans, Precision",
    "date": "2023-10-18",
    "rootCause": "In the first step, the attacker exploited the liquidity imbalance in the pool of the target asset, manipulating the liquidity index of the related hToken to control its value. By leveraging minimal hToken collateral, the attacker borrowed all other underlying assets. The attacker then repeatedly deposited and withdrew to drain the underlying assets due to a precision loss vulnerability. This process ultimately drained all assets from Hopelend.\n\nVulnerable code snippet:\n\n```solidity\nfunction rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n  // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n  assembly {\n    if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n      revert(0, 0)\n    }\n\n    c := div(add(mul(a, RAY), div(b, 2)), b)\n  }\n}\n```\n\nAttack tx:\n\n[](https://etherscan.io/tx/0x1a7ee0a7efc70ed7429edef069a1dd001fbff378748d91f17ab1876dc6d10392)\n\nAnalysis:\n\n[Deep dive into HopeLend Hack](https://lunaray.medium.com/deep-dive-into-hopelend-hack-5962e8b55d3f)",
    "images": [],
    "Lost": "$825K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/Hopelend_exp.sol"
  },
  "MicDao": {
    "type": "Price Manipulation",
    "date": "2023-10-18",
    "rootCause": "The MicDao exploit occurred due to a vulnerability in the private `_transfer()` function. This function burned MicDao tokens whenever triggered, allowing the attacker to artificially reduce the total supply and inflate the token price.\"\n\nVulnerable code snippet:\n\n```solidity\nfunction _transfer(address sender, address recipient, uint256 amount) internal override {\n    if(pairList[recipient] && !isDelivers[sender]){\n        uint256 toBurn = amount.mul(45).div(100);\n        super._transfer(sender, address(1), toBurn);\n        amount = amount.sub(toBurn);\n    }\n    super._transfer(sender, recipient, amount);\n}\n```\n\nAttack tx:\n\n[](https://bscscan.com/tx/0x24a2fbb27d433d91372525954f0d7d1af7509547b9ada29cc6c078e732c6d075)\n\nAnalysis:\n\n[CertiK Alert on Twitter / X](https://twitter.com/CertiKAlert/status/1714677875427684544)\n\n[ChainAegis on Twitter / X](https://twitter.com/ChainAegis/status/1714837519488205276)",
    "images": [],
    "Lost": "$13K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/MicDao_exp.sol"
  },
  "BelugaDex": {
    "type": "Price Manipulation",
    "date": "2023-10-13",
    "rootCause": "- In the `_withdrawFrom` function, the value `liabilityToBurn` is determined by the `asset.liability` and `asset.totalSupply`. However, the actual exchange/swap process is using the oracle as price feed. This introduces inconsistency for arbitrage.\n- Attacker could deposit `USDT` token, swap them to `USDCE` using oracle price(however the `liability` is influenced), but during the withdraw process which uses asset liability, the attacker could get back more assets than the original deposit tokens.\n\nVulnerable code snippet:\n\n```solidity\nfunction _withdrawFrom(Asset asset, uint256 liquidity)\n    private\n    view\n    returns (\n        uint256 amount,\n        uint256 liabilityToBurn,\n        uint256 fee,\n        bool enoughCash\n    )\n{\n@=> liabilityToBurn = (asset.liability() * liquidity) / asset.totalSupply();\n    require(liabilityToBurn > 0, 'INSUFFICIENT_LIQ_BURN');\n    ...\n}\n\n```\n\nAttack tx:\n\nhttps://arbiscan.io/tx/0x57c96e320a3b885fabd95dd476d43c0d0fb10500d940d9594d4a458471a87abe\n\nAnalysis:\n\nhttps://twitter.com/AnciliaInc/status/1712676040471105870\n\nhttps://twitter.com/CertiKAlert/status/1712707006979613097",
    "images": [],
    "Lost": "$175K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/BelugaDex_exp.sol"
  },
  "WiseLending": {
    "type": "Precision",
    "date": "2024-01-12",
    "rootCause": "Wise Lending's system was exploited due to a rounding issue in the _calculateShares function and manipulation of donation safeguards. The attacker bypassed donation limits and exploited rounding errors through strategic deposits and withdrawals, gaining a disproportionately large share of donations.\n\nVulnerable code snippet:\n\n```solidity\nfunction _calculateShares(\n        uint256 _product,\n        uint256 _pseudo,\n        bool _maxSharePrice\n    )\n        private\n        pure\n        returns (uint256)\n    {\n        return _maxSharePrice == true\n            ? _product % _pseudo == 0\n                ? _product / _pseudo\n                : _product / _pseudo + 1\n            : _product / _pseudo;\n    }\n\n```\n\nAttack transaction:\n\n[https://etherscan.io/tx/0x04e16a79ff928db2fa88619cdd045cdfc7979a61d836c9c9e585b3d6f6d8bc31](https://etherscan.io/tx/0x04e16a79ff928db2fa88619cdd045cdfc7979a61d836c9c9e585b3d6f6d8bc31)\n\nAnalysis:\n\n[https://twitter.com/EXVULSEC/status/1746138811862577515](https://twitter.com/EXVULSEC/status/1746138811862577515)",
    "images": [],
    "Lost": "464K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/WiseLending02_exp.sol"
  },
  "Platypus": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2023-10-12",
    "rootCause": "The `MasterPlatypusV4::emergencyWithdraw` function checks solvency before updating LP tokens, allowing users to withdraw funds even if they are used as collateral for a debt. In contrast, the `MasterPlatypusV4::withdraw` function checks solvency after updating the LP tokens, preventing this issue. To fix the `emergencyWithdraw` function, the solvency check should be reordered to occur after setting the user's amount to 0 or use the debt amount from `PlatypusTreasure::isSolvent` to ensure no active debt.\n\nThe attack originated from incorrect integration of `MasterPlatypusV4` with `PlatypusTreasure`, where the solvency check order allowed collateral to be withdrawn with active debt, creating 'bad debt' and resulting in the exchange of USP tokens for stable coins.\n\nVulnerable code snippet:\n\nSource: By Certik\n\n\n\nAttack tx:\n\n[Transaction Details](https://snowtrace.io/tx/0x4425f757715e23d392cda666bc0492d9e5d5848ff89851a1821eab5ed12bb867)\n\nAnalysis:\n\n[BlockSec on Twitter / X](https://twitter.com/BlockSecTeam/status/1712445197538468298)\n\n[PeckShield Inc. on Twitter / X](https://twitter.com/peckshield/status/1712354198246035562)",
    "images": [
      "images/ADC_e9XQjXS3BIGVXQSGotcRPrBkaZa350PQR515tTpiI79-SLGuuZoTrT_9lRQiRWUZbWoIuHtn4XJyj9Az0WfgQpVodLOQ2hv6LC9QB1TOgmw_orTR4USQYRFhhEGV-uIX.png"
    ],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/Platypus03_exp.sol"
  },
  "BH": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-10-11",
    "rootCause": "The attacker used a flashloan to manipulate the BH/USDT trading pair on PancakeSwap, creating significant slippage. They added liquidity, swapped a large amount of USDT for BH tokens, and then burned BH tokens to remove liquidity, altering the ratio to withdraw more USDT than initially provided. The attacker repaid the flash loan, profited substantially, and laundered the funds through Tornado Cash. \n\nVulnerable code snippet:\n\n[](https://bscscan.com/address/0xcc61cc9f2632314c9d452aca79104ddf680952b5)\n\nAttack tx:\n\n[](https://bscscan.com/tx/0xc11e4020c0830bcf84bfa197696d7bfad9ff503166337cb92ea3fade04007662)\n\nAnalysis:\n\n[Beosin Alert on Twitter / X](https://twitter.com/BeosinAlert/status/1712139760813375973)\n\n[Decurity on Twitter / X](https://twitter.com/DecurityHQ/status/1712118881425203350)",
    "images": [],
    "Lost": "$1.27M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/BH_exp.sol"
  },
  "pSeudoEth": {
    "type": "Flashloans",
    "date": "2023-10-08",
    "rootCause": "It is a flash loan exploit on pSeudoEth, where an attacker took ~$2.3k by causing an imbalance in the pETH/WETH pair and calling `skim()` to gain 1.43 WETH.\n\nVulnerable code snippet:\n\n[](https://etherscan.io/address/0x2033b54b6789a963a02bfcbd40a46816770f1161)\n\nAttack tx:\n\n[Ethereum Transaction Hash (Txhash) Details | Etherscan](https://etherscan.io/tx/0x4ab68b21799828a57ea99c1288036889b39bf85785240576e697ebff524b3930)\n\nAnalysis:\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:\n\n[CertiK Alert on Twitter / X](https://twitter.com/CertiKAlert/status/1710979615164944729)",
    "images": [],
    "Lost": "$2.3K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/pSeudoEth_exp.sol"
  },
  "StarsArena": {
    "type": "Business Logic Flaw, Reentrancy",
    "date": "2023-10-07",
    "rootCause": "Analysis from [Peckshield](https://x.com/peckshield/status/1710555944269292009)\n\n\n\nVulnerable code snippet:\n\n[Stars Arena: Shares | Address 0xa481b139a1a654ca19d2074f174f17d7534e8cec Details - Snowtrace](https://snowtrace.io/address/0xa481b139a1a654ca19d2074f174f17d7534e8cec)\n\nAttack tx:\n\n[Transaction Details](https://snowtrace.io/tx/0x4f37ffecdad598f53b8d5a2d9df98e3c00fbda4328585eb9947a412b5fe17ac5)\n\nAnalysis:\n\n[BlockSec on Twitter / X](https://twitter.com/BlockSecTeam/status/1710556926986342911)\n\n[BlockSec Phalcon on Twitter / X](https://twitter.com/Phalcon_xyz/status/1710554341466395065)\n\n[PeckShield Inc. on Twitter / X](https://twitter.com/peckshield/status/1710555944269292009)",
    "images": [
      "images/ADC_F70dgwdb0AAhIaX.jpeg"
    ],
    "Lost": "$3M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/StarsArena_exp.sol"
  },
  "DePayRouter": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2023-10-05",
    "rootCause": "A flash loan attack on the DePay platform resulted in the theft of 827 USDC. The exploiter took advantage of a security issue in the DePay router to execute the theft.\n\nVulnerable code snippet:\n\n```solidity\n// The main function to route transactions.\n  function route(\n    // The path of the token conversion.\n    address[] calldata path,\n    // Amounts passed to proccessors:\n    // e.g. [amountIn, amountOut, deadline]\n    uint[] calldata amounts,\n    // Addresses passed to plugins:\n    // e.g. [receiver]\n    address[] calldata addresses,\n    // List and order of plugins to be executed for this payment:\n    // e.g. [Uniswap,paymentPlugin] to swap and pay\n    address[] calldata plugins,\n    // Data passed to plugins:\n    // e.g. [\"signatureOfSmartContractFunction(address,uint)\"] receiving the payment\n    string[] calldata data\n  ) external payable returns(bool) {\n    uint balanceBefore = _balanceBefore(path[path.length-1]);\n    _ensureTransferIn(path[0], amounts[0]);\n    _execute(path, amounts, addresses, plugins, data);\n    _ensureBalance(path[path.length-1], balanceBefore);\n    return true;\n  }\n```\n\nAttack tx:\n\n[0x9a036058afb58169bf | Phalcon Explorer](https://app.blocksec.com/explorer/tx/eth/0x9a036058afb58169bfa91a826f5fcf4c0a376e650960669361d61bef99205f35?line=41)\n\nAnalysis:\n\n[CertiK Alert on Twitter / X](https://x.com/CertiKAlert/status/1709764146324009268)",
    "images": [],
    "Lost": "$ 827 USDC",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-10/DePayRouter_exp.sol"
  },
  "FireBirdPair": {
    "type": "Slippage",
    "date": "2023-09-30",
    "rootCause": "sink incorrect slippage protection\n\nVulnerable code snippet:\n\n[](https://polygonscan.com/address/0x5e9cd0861f927adeccfeb2c0124879b277dd66ac)\n\nAttack tx:\n\n[](https://polygonscan.com/tx/0x96d80c609f7a39b45f2bb581c6ba23402c20c2b6cd528317692c31b8d3948328)\n\nAnalysis:",
    "images": [],
    "Lost": "$3.2K MATIC",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/FireBirdPair_exp.sol"
  },
  "DEXRouter": {
    "type": "Arbitrary call",
    "date": "2023-09-29",
    "rootCause": "The attacker exploited 20 BNB from an unverified contract on the BSC network by making arbitrary calls via `functionCallWithValue`.\n\n\n\nVulnerable code snippet:\n\n[](https://bscscan.com/address/0x1f7cf218b46e613d1ba54cac11dc1b5368d94fb7)\n\nAttack tx:\n\n[](https://bscscan.com/tx/0xf77c5904da98d3d4a6e651d0846d35545ef5ca0b969132ae81a9c63e1efc2113)\n\nAnalysis:",
    "images": [
      "images/Access_Screenshot_2024-07-20_at_3.22.15_PM.png"
    ],
    "Lost": "$4K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/DEXRouter_exp.sol"
  },
  "XSDWETHpool": {
    "type": "Reentrancy",
    "date": "2023-09-26",
    "rootCause": "The attacker executed a flash loan, borrowing a large amount of WETH. They swapped WETH to XSD and then swapped XSD back to WETH, transferring the required WETH back to the flash loan provider.\n\nVulnerable code snippet:\n\n```solidity\nfunction swapXSDForETH(uint amountOut, uint amountInMax)\n      external\n      override\n  {\n      require(!swap_paused, \"Swaps have been paused\");\n      (uint reserveA, uint reserveB, ) = IXSDWETHpool(XSDWETH_pool_address).getReserves();\n      uint amounts = BankXLibrary.quote(amountOut, reserveB, reserveA);\n      require(amounts <= amountInMax, 'BankXRouter: EXCESSIVE_INPUT_AMOUNT');\n      TransferHelper.safeTransferFrom(\n          xsd_address, msg.sender, XSDWETH_pool_address, amountInMax\n      );\n      XSDWETHpool(XSDWETH_pool_address).swap(0, amountOut, address(this));\n      //function will fail if conditions are not met\n      //XSDWETHpool(XSDWETH_pool_address).flush();\n      IWBNB(WETH).withdraw(amountOut);\n      TransferHelper.safeTransferETH(msg.sender, amountOut);\n      //burn xsd here \n      //value of xsd liquidity pool has to be greater than 20% of the total xsd value\n      if(XSD.totalSupply()-CollateralPool(payable(collateral_pool_address)).collat_XSD()>amountOut/10 && !pid_controller.bucket1()){\n          XSD.burnpoolXSD(amountInMax/10);\n      }\n      refreshPID();\n  }\n```\n\n[](https://bscscan.com/address/0xfadda925e10d07430f5d7461689fd90d3d81bb48)\n\nAttack tx:\n\n[0xbdf76f22c41fe212f0 | Phalcon Explorer](https://app.blocksec.com/explorer/tx/bsc/0xbdf76f22c41fe212f07e24ca7266d436ef4517dc1395077fabf8125ebe304442)\n\nAnalysis:\n\n[CertiK Alert on Twitter / X](https://x.com/CertiKAlert/status/1706765042916450781)",
    "images": [],
    "Lost": "$56.9BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/XSDWETHpool_exp.sol"
  },
  "KubSplit": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-09-24",
    "rootCause": "Kub/Kub-split experienced a flash loan exploit, allowing the attacker to gain approximately $78.4k through pool manipulation.\n\nVulnerable code snippet:\n\n[](https://bscscan.com/address/0xc98e183d2e975f0567115cb13af893f0e3c0d0bd#code)\n\nAttack tx:\n\n[](https://bscscan.com/tx/0x2b0877b5495065e90d956e44ffde6aaee5e0fcf99dd3c86f5ff53e33774ea52d)\n\nAnalysis:\n\n[CertiK Alert on Twitter / X](https://twitter.com/CertiKAlert/status/1705966214319612092)",
    "images": [],
    "Lost": "$78K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/Kub_Split_exp.sol"
  },
  "CEXISWAP": {
    "type": "Access Control, Lack of permission control",
    "date": "2023-09-21",
    "rootCause": "The `initialize` function is not protected, allowing the attacker to take over the proxy contract and become the owner through the `upgradeToAndCall` method, subsequently stealing all the funds in the contract, transferring all the USDT out of the treasury.\n\nVulnerable code snippet:\n\n[](https://etherscan.io/address/0xb8a5890d53df78dee6182a6c0968696e827e3305#code)\n\nAttack tx:\n\n[Ethereum Transaction Hash (Txhash) Details | Etherscan](https://etherscan.io/tx/0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e)\n\nAnalysis:\n\n[Decurity on Twitter / X](https://twitter.com/DecurityHQ/status/1704759560614126030)",
    "images": [],
    "Lost": "$30K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/CEXISWAP_exp.sol"
  },
  "uniclyNFT": {
    "type": "Business Logic Flaw, Reentrancy",
    "date": "2023-09-16",
    "rootCause": "For the first step, the attacker deployed a malicious contract, swapped 0.5 ETH for 3528 uJENNY tokens, and deposited them to `PointFarm` to accumulate initial rewards. Two days later, the attacker launched the actual attack exploiting two bugs:\n\n1. The deposit function allows a 0 `_amount` for minting new tokens.\n2. `user.rewardDebt` is updated only after the external call to ERC1155 callback.\n\nDuring withdrawal, the attacker could only retrieve their initial deposit since `user.amount` wasn't updated during the reentrancy. Instead, they used their inflated balance in PointFarm to redeem a LootRealms NFT in the PointShop contract. This is a classic reentrancy vulnerability that does not follow the check-effect-interaction pattern.\n\nVulnerable code snippet:\n\n```solidity\nfunction deposit(uint256 _pid, uint256 _amount) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n    updatePool(_pid);\n    if (user.amount > 0) {\n        uint256 pending = user.amount.mul(pool.accPointsPerShare).div(1e18).sub(user.rewardDebt);\n        if(pending > 0) {\n            bytes memory data;\n            _mint(msg.sender, _pid, pending, data);\n        }\n    }\n    if(_amount > 0) {\n        pool.uToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n    }\n    user.rewardDebt = user.amount.mul(pool.accPointsPerShare).div(1e18);\n    emit Deposit(msg.sender, _pid, _amount);\n}\n```\n\nAttack tx:\n\n[](https://etherscan.io/tx/0xc42fe1ce2516e125a386d198703b2422aa0190b25ef6a7b0a1d3c6f5d199ffad)\n\nAnalysis:\n\n[Decurity on Twitter / X](https://twitter.com/DecurityHQ/status/1703096116047421863)",
    "images": [],
    "Lost": "1 NFT",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/uniclyNFT_exp.sol"
  },
  "0x0DEX": {
    "type": "Business Logic Flaw",
    "date": "2023-09-11",
    "rootCause": "The 0x0DEX contract was exploited through parameter manipulation. It allows private fund transfers (ETH) via `deposit` and `withdraw` functions and added a `swapOnWithdrawal` function for private swaps of deposited funds. The `swapOnWithdrawal` function was exploited. The amount withdrawn, after fees, is set as `_lastWithdrawal` only when `withdrawalData.wType` is `WithdrawalType.Swap`. For normal withdrawals (`withdrawalType.Direct`), `_lastWithdrawal` isn't set. This oversight allowed exploitation: if Alice swaps 10 ETH (`withdrawalType.Swap`) and Bob swaps 0.1 ETH (`withdrawalType.Direct`), the `_lastWithdrawal` remains 10 ETH. Thus, Bob could receive 10 ETH worth of tokens instead of his intended 0.1 ETH.\n\nVulnerable code snippet:\n\n```solidity\nfunction swapOnWithdrawal(\n        address tokenOut,\n        address payable recipient,\n        uint256 relayerGasCharge, \n        uint256 amountOut,\n        uint256 deadline,\n        WithdrawalData memory withdrawalData\n    ) external {\n        require(recipient != address(0), \"ZERO_ADDRESS\");\n        \n        withdrawalData.wType = Types.WithdrawalType.Swap;\n        withdraw(\n            recipient, \n            withdrawalData,\n            relayerGasCharge\n        );\n\n        uint amountIn = _lastWithdrawal;\n        uint relayerFee = getRelayerFeeForAmount(amountIn);\n\n        address payable relayerAddress = IOxODexFactory(factory).relayerAddress();\n        (bool sent, ) = relayerAddress.call{value: relayerFee}(\"\");\n        require(sent, \"FAILED_TO_SEND_RELAYER_FEE\");\n\n        amountIn -= relayerFee;\n\n        IUniswapV2Router router = IUniswapV2Router(UNISWAP_V2_ROUTER);\n        address[] memory path = new address[](2);\n        path[0] = WETH;\n        path[1] = tokenOut;\n\n        router.swapExactETHForTokens{value: amountIn}(\n            amountOut, \n            path, \n            recipient, \n            deadline\n        );\n        _lastWithdrawal = 0;\n        emit Swap(tokenOut, withdrawalData.amount, amountIn);\n    }\n```\n\nAttack tx:\n\n[0x00b375f8e90fc54c13 | Phalcon Explorer](https://explorer.phalcon.xyz/tx/eth/0x00b375f8e90fc54c1345b33c686977ebec26877e2c8cac165429927a6c9bdbec)\n\nAnalysis:\n\n[0x0 Privacy DEX Exploit | Notion](https://0x0ai.notion.site/0x0-Privacy-DEX-Exploit-25373263928b4f18b31c438b2a040e33)",
    "images": [],
    "Lost": "$61K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/0x0DEX_exp.sol"
  },
  "BFCToken": {
    "type": "Price Manipulation",
    "date": "2023-09-09",
    "rootCause": "by reducing of total supply of BFC token the attacker burned tokens, skimmed the pair to artificially inflate the token price\n\nVulnerable Code Snippet:\n\n```solidity\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(from != to, \"ERC20: transfer to the same address\");\n\n        if (swapping) {\n            super._transfer(from, to, amount);\n            return;\n        }\n\n        bool isAddLdx;\n        bool isDelLdx;\n\n        if (\n            !ammPairs[from] &&\n            !ammPairs[to] &&\n            toFather[to] == address(0) &&\n            toFather[from] != to\n        ) {\n            toFather[to] = from;\n            sonAddress[from].push(to);\n        }\n\n        if (ammPairs[from]) {\n            _distributeRewards(to);\n        } else if (ammPairs[to]) {\n            _distributeRewards(from);\n        } else {\n            _distributeRewards(from);\n            _distributeRewards(to);\n        }\n\n        if (ammPairs[from]) {\n            updateUserAmountMint(to);\n            updateUserAmountBurn(to);\n        } else if (ammPairs[to]) {\n            updateUserAmountMint(from);\n            updateUserAmountBurn(from);\n        } else {\n            updateUserAmountMint(from);\n            updateUserAmountMint(to);\n            updateUserAmountBurn(from);\n            updateUserAmountBurn(to);\n        }\n\n        if (lastAddress == address(0)) {\n            address[] memory addrs = new address[](2);\n            addrs[0] = from;\n            addrs[1] = to;\n            lpDividendProc(addrs);\n        } else {\n            address[] memory addrs = new address[](3);\n            addrs[0] = from;\n            addrs[1] = to;\n            addrs[2] = lastAddress;\n            lastAddress = address(0);\n            lpDividendProc(addrs);\n        }\n\n        if (ammPairs[to]) {\n            lastAddress = from;\n        }\n\n        uint256 usdtAmount;\n        if (ammPairs[to]) {\n            (isAddLdx, usdtAmount) = _isAddLiquidityV2();\n            if (isAddLdx) {\n                if (isExcludedFromFeesVip[from] && !flags) {\n                    super._transfer(from, to, amount);\n                    flags = true;\n                    return;\n                }\n                _setLpDividend(from);\n                (uint256 lpAddAmount, ) = getLpBalanceByUsdt(usdtAmount);\n                if (isParter[from]) {\n                    addLiqudityInfo[from].push(\n                        AddLiqudity({\n                            amount: lpAddAmount,\n                            time: block.timestamp\n                        })\n                    );\n                } else {\n                    haveLpAmount[from] = haveLpAmount[from].add(lpAddAmount);\n                }\n                totalLPAmount = totalLPAmount + lpAddAmount;\n            }\n        } else if (ammPairs[from]) {\n            (isDelLdx, , usdtAmount) = _isDelLiquidityV2();\n            if (isDelLdx) {\n                uint256 lpDelAmount = getLpBalanceByToken(usdtAmount);\n                uint256 totalLpAmounts;\n                AddLiqudity[] memory info = addLiqudityInfo[to];\n                for (uint256 i = 0; i < info.length; i++) {\n                    totalLpAmounts = totalLpAmounts + info[i].amount;\n                }\n                totalLpAmounts = totalLpAmounts + validLpAmount[to];\n\n                if (isParter[to]) {\n                    if (totalLpAmounts == 0) {\n                        super._transfer(from, DESTROY, amount);\n                        _totalSupply = _totalSupply - amount;\n                    } else {\n                        if (totalLpAmounts >= lpDelAmount) {\n                            _delLP(from, to, amount, lpDelAmount);\n                        } else {\n                            uint256 otherLpAmount = lpDelAmount -\n                                totalLpAmounts;\n                            uint256 tokenAmount = getTokenAmountByLp2(\n                                otherLpAmount\n                            );\n                            amount = amount - tokenAmount;\n                            super._transfer(from, DESTROY, tokenAmount);\n                            _totalSupply = _totalSupply - tokenAmount;\n                            uint256 selfLpAmount = lpDelAmount - otherLpAmount;\n\n                            if (validLpAmount[to] >= selfLpAmount) {\n                                validLpAmount[to] =\n                                    validLpAmount[to] -\n                                    selfLpAmount;\n                                super._transfer(from, to, amount);\n                            } else {\n                                uint256 lpValidAmount;\n                                AddLiqudity[]\n                                    memory information = addLiqudityInfo[to];\n                                for (\n                                    uint256 i = 0;\n                                    i < information.length;\n                                    i++\n                                ) {\n                                    if (\n                                        block.timestamp - information[i].time >\n                                        DEL_TIME\n                                    ) {\n                                        lpValidAmount =\n                                            lpValidAmount +\n                                            information[i].amount;\n                                        delete information[i];\n                                    }\n                                }\n                                validLpAmount[to] =\n                                    validLpAmount[to] +\n                                    lpValidAmount;\n                                if (validLpAmount[to] >= selfLpAmount) {\n                                    validLpAmount[to] =\n                                        validLpAmount[to] -\n                                        selfLpAmount;\n                                    super._transfer(from, to, amount);\n                                } else {\n                                    _setLpAmount(selfLpAmount, from, to);\n                                }\n                            }\n                        }\n                    }\n                    return;\n                } else {\n                    if (haveLpAmount[to] == 0) {\n                        super._transfer(from, DESTROY, amount);\n                        _totalSupply = _totalSupply - amount;\n                    } else {\n                        if (haveLpAmount[to] >= lpDelAmount) {\n                            haveLpAmount[to] = haveLpAmount[to] - lpDelAmount;\n                            super._transfer(from, to, amount);\n                        } else {\n                            uint256 extraLpAmount = lpDelAmount -\n                                haveLpAmount[to];\n                            uint256 tokenAmount = getTokenAmountByLp2(\n                                extraLpAmount\n                            );\n                            amount = amount - tokenAmount;\n\n                            super._transfer(from, DESTROY, tokenAmount);\n                            _totalSupply = _totalSupply - tokenAmount;\n                            super._transfer(from, to, amount);\n                            haveLpAmount[to] = 0;\n                        }\n                    }\n                    return;\n                }\n            }\n        }\n\n        uint256 balance = balanceOf(address(this));\n        uint256 balancePair = balanceOf(address(uniswapV2PairUSDT));\n        if (balance > 0 && balancePair > balance) {\n            if (\n                !swapping &&\n                (ammPairs[to] || (!ammPairs[from] && !ammPairs[to])) &&\n                !isAddLdx\n            ) {\n                swapping = true;\n                swap(balance);\n                swapping = false;\n            }\n        }\n\n        if (!isAddLdx && !isDelLdx) {\n            if (isExcludedFromFees[from] || isExcludedFromFees[to]) {} else {\n                if (ammPairs[to] || ammPairs[from]) {\n                    if(ammPairs[to]){                \n                        if(lastTx != 0){\n                            super._transfer(address(uniswapV2PairUSDT), DESTROY, lastTx);\n                            _totalSupply = _totalSupply - lastTx;\n                            IUniswapPair(uniswapV2PairUSDT).sync();\n                            lastTx = 0;\n                        }\n                        uint256 subAmount = amount.div(100).mul(2);\n                        lastTx = lastTx + subAmount;\n\n                    }\n                    uint256 burnAmount = amount.mul(burnFee).div(1000);\n                    uint256 toUsdtAmount = amount.mul(toUsdtFee).div(1000);\n                    super._transfer(from, DESTROY, burnAmount);\n                    _totalSupply = _totalSupply - burnAmount;\n                    super._transfer(from, address(this), toUsdtAmount);\n                    amount = amount.sub(burnAmount).sub(toUsdtAmount);\n                }\n            }\n        }\n        super._transfer(from, to, amount);\n    }\n```\n\nAttack Transaction:\n\n[https://bscscan.com/tx/0x8ee76291c1b46d267431d2a528fa7f3ea7035629500bba4f87a69b88fcaf6e23](https://bscscan.com/tx/0x8ee76291c1b46d267431d2a528fa7f3ea7035629500bba4f87a69b88fcaf6e23)\n\nAnalysis:\n\n[https://twitter.com/CertiKAlert/status/1700621314246017133](https://twitter.com/CertiKAlert/status/1700621314246017133)",
    "images": [],
    "Lost": "$38K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/BFCToken_exp.sol"
  },
  "APIG": {
    "type": "Price Manipulation",
    "date": "2023-09-08",
    "rootCause": "By taking advantage of a miscalculation on the token contract , the attacker was able to manipulate the price of the token across multiple different pairs of the token\n\nVulnerable Code Snippet:\n\nAttack Transaction:\n\n[https://bscscan.com/tx/0x66dee84591aeeba6e5f31e12fe728f2ddc79a06426036793487a980c3b952947](https://bscscan.com/tx/0x66dee84591aeeba6e5f31e12fe728f2ddc79a06426036793487a980c3b952947)\n\nAnalysis:\n\n[https://twitter.com/CertiKAlert/status/1700128158647734745](https://twitter.com/CertiKAlert/status/1700128158647734745)",
    "images": [],
    "Lost": "$169K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/APIG_exp.sol"
  },
  "HCT": {
    "type": "Access Control, Lack of permission control",
    "date": "2023-09-07",
    "rootCause": "the burn function which was left as an external function. here is called repeatedly to burn portions of the HCT tokens held by the contract to reduce the supply , then the sync function is called on the router to inflate the price based  tokens available, then sell at that inflated price\n\nVulnerable Code Snippet:\n\n```solidity\nfunction burn(uint256 _value) public{\n\t\t_burn(msg.sender, _value);\n\t}\n```\n\n```solidity\nfunction _burn(address _who, uint256 _value) internal {\n\t\trequire(_value <= _rOwned[_who]);\n\t\t_rOwned[_who] = _rOwned[_who].sub(_value);\n\t\t_tTotal = _tTotal.sub(_value);\n\t\temit Transfer(_who, address(0), _value);\n\t}\n```\n\nAttack Transaction:\n\n[https://bscscan.com/tx/0x84bd77f25cc0db493c339a187c920f104a69f89053ab2deabb93c35220e6dfc0](https://bscscan.com/tx/0x84bd77f25cc0db493c339a187c920f104a69f89053ab2deabb93c35220e6dfc0)\n\nAnalysis:\n\n[https://twitter.com/leovctech/status/1699775506785198499](https://twitter.com/leovctech/status/1699775506785198499)",
    "images": [],
    "Lost": "$30.5BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/HCT_exp.sol"
  },
  "JumpFarm": {
    "type": "Incorrect logic",
    "date": "2023-09-05",
    "rootCause": "The problem originated from the `stake()` function in the FloorDAO contract. This function sends funds to the caller before triggering a rebase. As a result, instead of distributing an amount of sJUMP equal to the newly minted JUMP in the next rebase, it includes the user's stake. This causes a mismatch between the contract's JUMP balance and the circulating sJUMP. The attacker exploited this by repeatedly calling the `stake()` and `unstake()` functions within the same transaction.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction stake(address _to, uint256 _amount) external {\n        rebase();\n        TOKEN.transferFrom(msg.sender, address(this), _amount);\n        sTOKEN.transfer(_to, _amount);\n    }\n```\n\n```solidity\nfunction rebase() public {\n        if (epoch.end <= block.timestamp) {\n            sTOKEN.rebase(epoch.distribute, epoch.number);\n\n            epoch.end = epoch.end + epoch.length;\n            epoch.number++;\n\n            if (address(distributor) != address(0)) {\n                distributor.distribute();\n            }\n\n            uint256 balance = TOKEN.balanceOf(address(this));\n            uint256 staked = sTOKEN.circulatingSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked;\n            }\n        }\n    }\n```\n\n```solidity\nfunction unstake(address _to, uint256 _amount, bool _rebase) external {\n        if (_rebase) rebase();\n        sTOKEN.transferFrom(msg.sender, address(this), _amount);\n        require(\n            _amount <= TOKEN.balanceOf(address(this)),\n            \"Insufficient TOKEN balance in contract\"\n        );\n        TOKEN.transfer(_to, _amount);\n    }\n```\n\nAttack Transaction:\n\n[https://explorer.phalcon.xyz/tx/eth/0x6189ad07894507d15c5dff83f547294e72f18561dc5662a8113f7eb932a5b079](https://explorer.phalcon.xyz/tx/eth/0x6189ad07894507d15c5dff83f547294e72f18561dc5662a8113f7eb932a5b079)\n\nAnalysis:\n\n[https://twitter.com/DecurityHQ/status/1699384904218202618](https://twitter.com/DecurityHQ/status/1699384904218202618)",
    "images": [],
    "Lost": "$2.4ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/JumpFarm_exp.sol"
  },
  "HeavensGate": {
    "type": "Incorrect logic",
    "date": "2023-09-05",
    "rootCause": "The problem originated from the `stake()` function in the HeavensGate contract. This function sends funds to the caller before triggering a rebase. As a result, instead of distributing an amount of sHATE equal to the newly minted HATE in the next rebase, it includes the user's stake. This causes a mismatch between the contract's HATE balance and the circulating sHATE. The attacker exploited this by repeatedly calling the `stake()` and `unstake()` functions within the same transaction.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction stake(address _to, uint256 _amount) external {\n        HATE.transferFrom(msg.sender, address(this), _amount);\n        rebase();\n        sHATE.transfer(_to, _amount);\n    }\n```\n\n```solidity\nfunction rebase() public {\n        if (epoch.end <= block.timestamp) {\n            sHATE.rebase(epoch.distribute, epoch.number);\n\n            epoch.end = epoch.end + epoch.length;\n            epoch.number++;\n\n            if (address(distributor) != address(0)) {\n                distributor.distribute();\n            }\n\n            uint256 balance = HATE.balanceOf(address(this));\n            uint256 staked = sHATE.circulatingSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked;\n            }\n        }\n    }\n```\n\n```solidity\nfunction unstake(address _to, uint256 _amount, bool _rebase) external {\n        if (_rebase) rebase();\n        sHATE.transferFrom(msg.sender, address(this), _amount);\n        require(_amount <= HATE.balanceOf(address(this)), \"Insufficient HATE balance in contract\");\n        HATE.transfer(_to, _amount);\n    }\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0xe28ca1f43036f4768776805fb50906f8172f75eba3bf1d9866bcd64361fda834](https://etherscan.io/tx/0xe28ca1f43036f4768776805fb50906f8172f75eba3bf1d9866bcd64361fda834)\n\n[https://etherscan.io/tx/0x8e1b0ab098c4cc5f632e00b0842b5f825bbd15ded796d4a59880bb724f6c5372](https://etherscan.io/tx/0x8e1b0ab098c4cc5f632e00b0842b5f825bbd15ded796d4a59880bb724f6c5372)\n\nAnalysis:\n\n[https://twitter.com/hexagate_/status/1699003711937216905](https://twitter.com/hexagate_/status/1699003711937216905)",
    "images": [],
    "Lost": "$8ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/HeavensGate_exp.sol"
  },
  "FloorDAO": {
    "type": "Incorrect logic",
    "date": "2023-09-05",
    "rootCause": "The problem originated from the `stake()` function in the FloorDAO contract. This function sends funds to the caller before triggering a rebase. As a result, instead of distributing an amount of sFLOOR equal to the newly minted FLOOR in the next rebase, it includes the user's stake. This causes a mismatch between the contract's FLOOR balance and the circulating sFLOOR. The attacker exploited this by repeatedly calling the `stake()` and `unstake()` functions within the same transaction\n\nVulnerable Code Snippet:\n\n```solidity\nfunction stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256) {\n        FLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = _amount.add(rebase()); // add bounty if rebase occurred\n        if (_claim && warmupPeriod == 0) {\n            return _send(_to, _amount, _rebasing);\n        } else {\n            Claim memory info = warmupInfo[_to];\n            if (!info.lock) {\n                require(_to == msg.sender, \"External deposits for account are locked\");\n            }\n\n            warmupInfo[_to] = Claim({\n                deposit: info.deposit.add(_amount),\n                gons: info.gons.add(sFLOOR.gonsForBalance(_amount)),\n                expiry: epoch.number.add(warmupPeriod),\n                lock: info.lock\n            });\n\n            gonsInWarmup = gonsInWarmup.add(sFLOOR.gonsForBalance(_amount));\n\n            return _amount;\n        }\n    }\n```\n\nAttack Transaction:\n\n[https://explorer.phalcon.xyz/tx/eth/0x1274b32d4dfacd2703ad032e8bd669a83f012dde9d27ed92e4e7da0387adafe4](https://explorer.phalcon.xyz/tx/eth/0x1274b32d4dfacd2703ad032e8bd669a83f012dde9d27ed92e4e7da0387adafe4)\n\nAnalysis:\n\n[https://twitter.com/PeckShieldAlert/status/169896210505836132](https://twitter.com/PeckShieldAlert/status/1698962105058361392)\n\n[https://medium.com/floordao/floor-post-mortem-incident-summary-september-5-2023-e054a2d5afa4](https://medium.com/floordao/floor-post-mortem-incident-summary-september-5-2023-e054a2d5afa4)",
    "images": [],
    "Lost": "$40ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/FloorDAO_exp.sol"
  },
  "DAppSocial": {
    "type": "Business Logic Flaw",
    "date": "2023-09-02",
    "rootCause": "The withdrawTokensWithAlt() function determined the withdrawal amount by subtracting a user-controlled balance from the msg.sender's balance. This vulnerability allowed the attacker to manipulate the user-controlled balance and profit from the exploit.\n\nVulnerable Code Snippet:\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0xbd72bccec6dd824f8cac5d9a3a2364794c9272d7f7348d074b580e3c6e44312e](https://etherscan.io/tx/0xbd72bccec6dd824f8cac5d9a3a2364794c9272d7f7348d074b580e3c6e44312e)\n\nAnalysis:\n\n[https://twitter.com/DecurityHQ/status/1698064511230464310](https://twitter.com/DecurityHQ/status/1698064511230464310)",
    "images": [],
    "Lost": "$16K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-09/DAppSocial_exp.sol"
  },
  "EAC": {
    "type": "Access Control, Price Manipulation",
    "date": "2023-08-29",
    "rootCause": "The attacker was able to manipulate the price of EAC on pancake swap, allowing them to trade from pair token to EAC for a profit\n\nVulnerable Code Snippet:\n\nAttack Transaction:\n\n[https://bscscan.com/tx/0x477f9ee698ac8ae800ffa012ab52fd8de39b58996245c5e39a4233c1ae5f1baa](https://bscscan.com/tx/0x477f9ee698ac8ae800ffa012ab52fd8de39b58996245c5e39a4233c1ae5f1baa)\n\nAnalysis:\n\n[https://lunaray.medium.com/eac-hack-analysis-8c66d4237f11](https://lunaray.medium.com/eac-hack-analysis-8c66d4237f11)",
    "images": [],
    "Lost": "$29BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/EAC_exp.sol"
  },
  "SVT": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2023-08-26",
    "rootCause": "The exploit starts out by loaning BUSD from dodo private pool, half of which is then used to buy SVT repeatedly, the second time a much smaller amount than the first. its all then sold leaving the attacker with more than SVT than was originally bought \n\nVulnerable Code Snippet:\n\nAttack Transaction:\n\n[https://twitter.com/Phalcon_xyz/status/1695285435671392504?s=20](https://twitter.com/Phalcon_xyz/status/1695285435671392504?s=20)\n\nAnalysis:\n\n[https://twitter.com/Phalcon_xyz/status/1695285435671392504?s=20](https://twitter.com/Phalcon_xyz/status/1695285435671392504?s=20)",
    "images": [],
    "Lost": "$400K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/SVT_exp.sol"
  },
  "GSS": {
    "type": "Price Manipulation, skim",
    "date": "2023-08-24",
    "rootCause": "The attack began with a loan of USDT. By manipulating the price-to-total supply relationship on PancakeSwap, the attacker unbalanced the GSS pool and distorted the GSS price. This allowed the final swap from GSS to USDT to yield more USDT for the attacker.\n\nVulnerable Code Snippet:\n\nAttack Transaction:\n\n[https://bscscan.com/tx/0x4f8cb9efb3cc9930bd38af5f5d34d15ce683111599a80df7ae50b003e746e336](https://bscscan.com/tx/0x4f8cb9efb3cc9930bd38af5f5d34d15ce683111599a80df7ae50b003e746e336)\n\nAnalysis:\n\n[https://twitter.com/bbbb/status/1694571228185723099](https://twitter.com/bbbb/status/1694571228185723099)",
    "images": [],
    "Lost": "$25K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/GSS_exp.sol"
  },
  "EHIVE": {
    "type": "Insufficient validation",
    "date": "2023-08-21",
    "rootCause": "The attacker exploited a validation flaw between the stake and unstake functions. They created a position by staking nothing, waited 38 days, then took a WETH loan, swapped it to EHIVE, and sent it to initial contracts. By unstaking across all contracts, they received more WETH despite not having staked anything initially.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction stake(uint256 stakeAmount, uint256 validator) external isStakingEnabled {\n        require(totalSupply() <= maxSupply, \"There are no more rewards left to be claimed.\");\n\n        // Check user is registered as staker\n        if (isStaking(msg.sender, validator)) {\n            _stakers[msg.sender][validator].staked += stakeAmount;\n            _stakers[msg.sender][validator].earned += _userEarned(msg.sender, validator);\n            _stakers[msg.sender][validator].start = block.timestamp;\n        } else {\n            _stakers[msg.sender][validator] = Staker(msg.sender, block.timestamp, stakeAmount, 0);\n        }\n\n        validators[validator].staked += stakeAmount;\n        totalStaked += stakeAmount;\n        _burn(msg.sender, stakeAmount);\n    }\n```\n\n```solidity\nfunction unstake(uint256 validator) external {\n        require(isStaking(msg.sender, validator), \"You are not staking!?\");\n\n        uint256 reward = userEarned(msg.sender, validator);\n\n        if (totalSupply().add(reward) < maxSupply && stakingEnabled) {\n            _claimHistory[msg.sender].dates.push(block.timestamp);\n            _claimHistory[msg.sender].amounts.push(reward);\n            totalClaimed += reward;\n\n            _mint(msg.sender, _stakers[msg.sender][validator].staked.add(reward));\n        } else {\n            _mint(msg.sender, _stakers[msg.sender][validator].staked);\n        }\n\n        validators[validator].staked -= _stakers[msg.sender][validator].staked;\n        totalStaked -= _stakers[msg.sender][validator].staked;\n\n        delete _stakers[msg.sender][validator];\n    }\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0xad818ec910def08c70ac519ab0fffa084b4178014a91cd8aa2f882d972a511c1](https://etherscan.io/tx/0xad818ec910def08c70ac519ab0fffa084b4178014a91cd8aa2f882d972a511c1)\n\nAnalysis:\n\n[https://twitter.com/bulu4477/status/1693636187485872583](https://twitter.com/bulu4477/status/1693636187485872583)",
    "images": [],
    "Lost": "$15K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/EHIVE_exp.sol"
  },
  "BTC20": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-08-19",
    "rootCause": "The vulnerable fetchPrice function calls getAmountsIn on the Uniswap router using the WETH-BTC20 pair, which relies on the pair's reserves. The attacker bought a large amount of BTC20 in the WETH-BTC20 pair to manipulate the price\n\nVulnerable Code Snippet:\n\n```solidity\nfunction fetchPrice(uint256 amountOut) public view returns (uint256) {\n    address[] memory path = new address[](2);\n    path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    path[1] = 0xE86DF1970055e9CaEe93Dae9B7D5fD71595d0e18\n    uint256[] memory amounts = router.getAmountsIn(amountOut, path);\n    return amount[0] + ((amounts[0] * percent) / 100);\n  }\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0xcdd93e37ba2991ce02d8ca07bf6563bf5cd5ae801cbbce3dd0babb22e30b2dbe](https://etherscan.io/tx/0xcdd93e37ba2991ce02d8ca07bf6563bf5cd5ae801cbbce3dd0babb22e30b2dbe)\n\nAnalysis:\n\n[https://twitter.com/DecurityHQ/status/1692924369662513472](https://twitter.com/DecurityHQ/status/1692924369662513472)",
    "images": [],
    "Lost": "$18ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/BTC20_exp.sol"
  },
  "ExactlyProtocol": {
    "type": "Insufficient validation",
    "date": "2023-08-18",
    "rootCause": "The root cause was the public leverage() function in the DebtManager contract of Exactly Protocol. This function was missing proper input validation. The attacker exploited this vulnerability by passing in an invalid market address when using the leverage() function and created a UniswapV3 liquidity position with WETH and a fake token. Due to the lack of input validation, the attacker could manipulate the _msgSender parameter to target victim addresses and drain their funds.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction leverage(\n    Market market,\n    uint256 deposit,\n    uint256 ratio,\n    uint256 borrowAssets,\n    Permit calldata marketPermit,\n    Permit calldata assetPermit\n  ) external permit(market, borrowAssets, marketPermit) permit(market.asset(), deposit, assetPermit) {\n    leverage(market, deposit, ratio);\n  }\n```\n\nAttack Transaction:\n\n[https://optimistic.etherscan.io/tx/0x3d6367de5c191204b44b8a5cf975f257472087a9aadc59b5d744ffdef33a520e](https://optimistic.etherscan.io/tx/0x3d6367de5c191204b44b8a5cf975f257472087a9aadc59b5d744ffdef33a520e)\n\nAnalysis:\n\n[https://medium.com/@exactly_protocol/exactly-protocol-incident-post-mortem-b4293d97e3ed](https://medium.com/@exactly_protocol/exactly-protocol-incident-post-mortem-b4293d97e3ed)\n\n[https://twitter.com/BlockSecTeam/status/1692533280971936059](https://twitter.com/BlockSecTeam/status/1692533280971936059)",
    "images": [],
    "Lost": "$7M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Exactly_exp.sol"
  },
  "ZunamiProtocol": {
    "type": "Price Manipulation",
    "date": "2023-08-14",
    "rootCause": "Zunami Protocol's contract calculates account balances using the cacheAssetPrice() value, which depends on totalHoldings. The attacker manipulated totalHoldings by flash loaning in funds from multiple sources, then swapping these funds for 4.8M UZD on Curve.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction cacheAssetPrice() public virtual {\n        _blockCached = block.number;\n        uint256 currentAssetPrice = assetPrice();\n        if (_assetPriceCached < currentAssetPrice) {\n            _assetPriceCached = currentAssetPrice;\n            emit CachedAssetPrice(_blockCached, _assetPriceCached);\n        }\n    }\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0x0788ba222970c7c68a738b0e08fb197e669e61f9b226ceec4cab9b85abe8cceb](https://etherscan.io/tx/0x0788ba222970c7c68a738b0e08fb197e669e61f9b226ceec4cab9b85abe8cceb)\n\nAnalysis:\n\n[https://twitter.com/peckshield/status/1690877589005778945](https://twitter.com/peckshield/status/1690877589005778945)\n\n[https://twitter.com/BlockSecTeam/status/1690931111776358400](https://twitter.com/BlockSecTeam/status/1690931111776358400)",
    "images": [],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Zunami_exp.sol"
  },
  "EarningFram": {
    "type": "Reentrancy",
    "date": "2023-08-09",
    "rootCause": "The attack exploited both reentrancy and a flawed business logic in the share burning process, where withdrawals were processed before shares were burnt.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction withdraw(uint256 assets, address receiver) public virtual nonReentrant unPaused returns (uint256 shares) {\n        require(assets != 0, \"ZERO_ASSETS\");\n        require(assets <= maxWithdraw, \"EXCEED_ONE_TIME_MAX_WITHDRAW\");\n\n        // Total Assets amount until now\n        uint256 totalDeposit = convertToAssets(balanceOf(msg.sender));\n\n        require(assets <= totalDeposit, \"EXCEED_TOTAL_DEPOSIT\");\n\n        // Calculate share amount to be burnt\n        shares = (totalSupply() * assets) / totalAssets();\n\n        // Calls Withdraw function on controller\n        (uint256 withdrawn, uint256 fee) = IController(controller).withdraw(assets, receiver);\n\n        require(withdrawn > 0, \"INVALID_WITHDRAWN_SHARES\");\n\n        // Shares could exceed balance of caller\n        if (balanceOf(msg.sender) < shares) shares = balanceOf(msg.sender);\n\n        _burn(msg.sender, shares);\n\n        emit Withdraw(address(asset), msg.sender, receiver, assets, shares, fee);\n    }\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0x6e6e556a5685980317cb2afdb628ed4a845b3cbd1c98bdaffd0561cb2c4790fa](https://etherscan.io/tx/0x6e6e556a5685980317cb2afdb628ed4a845b3cbd1c98bdaffd0561cb2c4790fa)\n\nAnalysis:\n\n[https://twitter.com/Phalcon_xyz/status/1689182459269644288](https://twitter.com/Phalcon_xyz/status/1689182459269644288)",
    "images": [],
    "Lost": "$286k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/EarningFram_exp.sol"
  },
  "CurveBurner": {
    "type": "Price Manipulation, Sandwich",
    "date": "2023-08-02",
    "rootCause": "This attack was made possible by maliciously calling the\u00a0`execute()`function of the\u00a0`UnderlyingBurner`\u00a0contract(which is slippage tolerant), the attacker uses the execute function to further imbalance the 3pool allowing the attacker to buy tokens (like DAI and USDC) low, and sell them at a high prices\n\nVulnerable Code Snippet:\n\n```solidity\n@external\ndef execute() -> bool:\n    \"\"\"\n    @notice Add liquidity to 3pool and transfer 3CRV to the fee distributor\n    @return bool success\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    amounts: uint256[3] = [\n        ERC20(TRIPOOL_COINS[0]).balanceOf(self),\n        ERC20(TRIPOOL_COINS[1]).balanceOf(self),\n        ERC20(TRIPOOL_COINS[2]).balanceOf(self),\n    ]\n    if amounts[0] != 0 and amounts[1] != 0 and amounts[2] != 0:\n        StableSwap(TRIPOOL).add_liquidity(amounts, 0)\n\n    amount: uint256 = ERC20(TRIPOOL_LP).balanceOf(self)\n    if amount != 0:\n        ERC20(TRIPOOL_LP).transfer(self.receiver, amount)\n\n    return True\n```\n\n```solidity\n@payable\n@external\ndef burn(_coin: address) -> bool:\n    \"\"\"\n    @notice Receive `_coin` and swap for USDC if not a 3pool asset\n    @param _coin Address of the coin being received\n    @return bool success\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    # transfer coins from caller\n    amount: uint256 = ERC20(_coin).balanceOf(msg.sender)\n    if amount != 0:\n        response: Bytes[32] = raw_call(\n            _coin,\n            concat(\n                method_id(\"transferFrom(address,address,uint256)\"),\n                convert(msg.sender, bytes32),\n                convert(self, bytes32),\n                convert(amount, bytes32),\n            ),\n            max_outsize=32,\n        )\n        if len(response) != 0:\n            assert convert(response, bool)\n\n    # if coin is not in 3pool, swap it for USDC\n    if not _coin in TRIPOOL_COINS:\n        registry_swap: address = AddressProvider(ADDRESS_PROVIDER).get_address(2)\n\n        if not self.is_approved[registry_swap][_coin]:\n            response: Bytes[32] = raw_call(\n                _coin,\n                concat(\n                    method_id(\"approve(address,uint256)\"),\n                    convert(registry_swap, bytes32),\n                    convert(MAX_UINT256, bytes32),\n                ),\n                max_outsize=32,\n            )\n            if len(response) != 0:\n                assert convert(response, bool)\n            self.is_approved[registry_swap][_coin] = True\n\n        if _coin == SUSD:\n            # if the coin is sUSD, settle prior to exchanging\n            Synthetix(SNX).settle(SUSD_CURRENCY_KEY)\n\n        # get actual balance in case of transfer fee or pre-existing balance\n        amount = ERC20(_coin).balanceOf(self)\n        if amount != 0:\n            RegistrySwap(registry_swap).exchange_with_best_rate(_coin, USDC, amount, 0)\n\n    return True\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0xd493c73397952049644c531309df3dd4134bf3db1e64eb6f0b68b016ee0bffde](https://etherscan.io/tx/0xd493c73397952049644c531309df3dd4134bf3db1e64eb6f0b68b016ee0bffde)\n\nAnalysis:\n\n[https://medium.com/@Hypernative/exotic-culinary-hypernative-systems-caught-a-unique-sandwich-attack-against-curve-finance-6d58c32e436b](https://medium.com/@Hypernative/exotic-culinary-hypernative-systems-caught-a-unique-sandwich-attack-against-curve-finance-6d58c32e436b)",
    "images": [],
    "Lost": "$36K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/CurveBurner_exp.sol"
  },
  "Uwerx": {
    "type": "Price Manipulation",
    "date": "2023-08-02",
    "rootCause": "The attacker exploited the ability to burn UWERX tokens, decreasing the total supply and raising the token price artificially. They borrowed 20,000 ETH via flash loans, exchanged it for 5,053,637 UWERX tokens, and used the private _transfer() function to burn 1% of transferred tokens. This reduction in supply allowed them to sell UWERX tokens at a higher price, resulting in a profit.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n        if (to == uniswapPoolAddress) {\n            uint256 userTransferAmount = (amount * 97) / 100;\n            uint256 marketingAmount = (amount * 2) / 100;\n            uint256 burnAmount = amount - userTransferAmount - marketingAmount;\n\n            emit Transfer(from, to, userTransferAmount);\n            emit Transfer(from, marketingWalletAddress, marketingAmount);\n            _burn(from, burnAmount);\n\n        } else {\n            emit Transfer(from, to, amount);\n        }\n        \n        _afterTokenTransfer(from, to, amount);\n    }\n```\n\nAttack Transaction:\n\n[https://etherscan.io/tx/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8](https://etherscan.io/tx/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8)\n\n[https://explorer.phalcon.xyz/tx/eth/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8](https://explorer.phalcon.xyz/tx/eth/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8)\n\nAnalysis:\n\n[https://twitter.com/deeberiroz/status/1686683788795846657](https://twitter.com/deeberiroz/status/1686683788795846657)",
    "images": [],
    "Lost": "$176ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Uwerx_exp.sol"
  },
  "NeutraFinance": {
    "type": "Price Manipulation",
    "date": "2023-08-01",
    "rootCause": "The root cause of the attack lay in the spot price utilized within the conversion function. This stemmed from the existence of two pools sharing the same LP token name (CMLT-LP), allowing conversion between them\u2014specifically, from one pool (CMLT-LP-65eb) to another (CMLT-LP-2ea3) via the conversion function.\n\nVulnerable Code Snippet:\n\nAttack Transaction:\n\n[https://explorer.phalcon.xyz/tx/arbitrum/0x6301d4c9f7ac1c96a65e83be6ea2fff5000f0b1939ad24955e40890bd9fe6122](https://explorer.phalcon.xyz/tx/arbitrum/0x6301d4c9f7ac1c96a65e83be6ea2fff5000f0b1939ad24955e40890bd9fe6122)\n\nAnalysis:\n\n[https://twitter.com/phalcon_xyz/status/1686654241111429120?s=46&t=Oc_WAGUoXqc9c0LidD-zww](https://twitter.com/phalcon_xyz/status/1686654241111429120?s=46&t=Oc_WAGUoXqc9c0LidD-zww)",
    "images": [],
    "Lost": "$23ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/NeutraFinance_exp.sol"
  },
  "LeetSwap": {
    "type": "Access Control, Price Manipulation",
    "date": "2023-08-01",
    "rootCause": "This exploit was a result of incorrect access control, where the _transferFeesSupportingTaxTokens() function  was incorrectly marked as public. This enabled the attacker to misuse the function to transfer tokens to LeetSwap's fee collection address, reducing axlUSD token liquidity and artificially inflating its price for their own gain.\n\nVulnerable Code Snippet:\n\n```solidity\nfunction _transferFeesSupportingTaxTokens(address token, uint256 amount)\n        public\n        returns (uint256)\n    {\n        if (amount == 0) {\n            return 0;\n        }\n\n        uint256 balanceBefore = IERC20(token).balanceOf(fees);\n        _safeTransfer(token, fees, amount);\n        uint256 balanceAfter = IERC20(token).balanceOf(fees);\n\n        return balanceAfter - balanceBefore;\n    }\n```\n\nAttack Transaction:\n\n[https://basescan.org/tx/0xbb837d417b76dd237b4418e1695a50941a69259a1c4dee561ea57d982b9f10ec](https://basescan.org/tx/0xbb837d417b76dd237b4418e1695a50941a69259a1c4dee561ea57d982b9f10ec)\n\nAnalysis:\n\n[https://twitter.com/BlockSecTeam/status/1686217464051539968](https://twitter.com/BlockSecTeam/status/1686217464051539968)\n\n[https://twitter.com/peckshield/status/1686209024587710464](https://twitter.com/peckshield/status/1686209024587710464)",
    "images": [],
    "Lost": "$630K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-08/Leetswap_exp.sol"
  },
  "GYMNET": {
    "type": "Incorrect logic",
    "date": "2023-07-31",
    "rootCause": "\n\nThe root Cause is the wrong implement of `swapExactTokensForTokensSupportingFeeOnTransferTokens()`\n\nThe `from` should be `msg.sender`\n\n**Vulnerable code snippet:**\n\n\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x7fe96c00880b329aa0fcb00f0ef3a0766c54e13965becf9cc5e0df6fbd0deca6](https://bscscan.com/tx/0x7fe96c00880b329aa0fcb00f0ef3a0766c54e13965becf9cc5e0df6fbd0deca6)\n\n**Analysis:**\n\n[https://twitter.com/AnciliaInc/status/1686605510655811584](https://twitter.com/AnciliaInc/status/1686605510655811584)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "Unclear",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/GYMNET_exp.sol"
  },
  "Curve": {
    "type": "Reentrancy",
    "date": "2023-07-30",
    "rootCause": "\n\nThe root cause is A bug within older versions of the `Vyper` compiler. it could cause a failure in a security feature used by a limited set of Curve pools \n\n**Attack TX:**\n\n[https://etherscan.io/tx/0xa84aa065ce61dbb1eb50ab6ae67fc31a9da50dd2c74eefd561661bfce2f1620c](https://etherscan.io/tx/0xa84aa065ce61dbb1eb50ab6ae67fc31a9da50dd2c74eefd561661bfce2f1620c)\n\n**Analysis:**\n\n[https://hackmd.io/@LlamaRisk/BJzSKHNjn](https://hackmd.io/@LlamaRisk/BJzSKHNjn)",
    "images": [],
    "Lost": "$41M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Curve_exp01.sol"
  },
  "Carson": {
    "type": "Flashloans",
    "date": "2023-07-26",
    "rootCause": "\n\nThe root cause was the attacker repeatedly called the `swapExactTokensForTokensSupportingFeeOnTransferTokens` function in the `0x2bdf...341a` contract (not open-source) through flash loans, swapped for [$BUSD](https://twitter.com/search?q=%24BUSD&src=cashtag_click) and burned [$Carson](https://twitter.com/search?q=%24Carson&src=cashtag_click) in the pair, then repeatedly inflated the price of [$Carson](https://twitter.com/search?q=%24Carson&src=cashtag_click) for profit.\n\n\n\n**Attack TX:**\n\n[https://bscscan.com/tx/0x37d921a6bb0ecdd8f1ec918d795f9c354727a3ff6b0dba98a512fceb9662a3ac](https://bscscan.com/tx/0x37d921a6bb0ecdd8f1ec918d795f9c354727a3ff6b0dba98a512fceb9662a3ac)\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1684503154023448583](https://twitter.com/Phalcon_xyz/status/1684503154023448583)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$150K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Carson_exp.sol"
  },
  "Palmswap": {
    "type": "Price Manipulation",
    "date": "2023-07-24",
    "rootCause": "\n\nThe root cause is that the price of `$PLP`  is determined by the number of `$USDT` in the\u00a0Vault contract\u00a0and the $USDP supply.\nThe attacker was able to manipulate the amount of `$USDT` in the Vault by calling the `buyUSDP`function.\n\n**Code Snippet:**\n\n%206b65d8d5661447daacea002107cfec94/Untitled.png)\n\n%206b65d8d5661447daacea002107cfec94/Untitled%201.png)\n\n%206b65d8d5661447daacea002107cfec94/Untitled%202.png)\n\n**Attack TX:**\n\n[https://app.blocksec.com/explorer/tx/bsc/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9](https://app.blocksec.com/explorer/tx/bsc/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1683680026766737408](https://twitter.com/BlockSecTeam/status/1683680026766737408)",
    "images": [
      "images/Manipulate%20price%20by%20butUSDP(",
      "images/Manipulate%20price%20by%20butUSDP(",
      "images/Manipulate%20price%20by%20butUSDP("
    ],
    "Lost": "$900K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Palmswap_exp.sol"
  },
  "MintoFinance": {
    "type": "Unchecked User Input",
    "date": "2023-07-23",
    "rootCause": "\n\nThe root cause is the design of the contract, which was set up to accept payment using a token address provided by the user, which in this case gave the attacker room to exploit.\n\nThe attacker targeted the vulnerable buyTokens() function, which accepts two structs as arguments: LinkParameters and PurchaseParameters.\n\nThe PurchaseParameters struct handles important transaction details such as the amount of tokens the user is purchasing and the payment token used.\n\nOnce the _buy() function was invoked by the buyTokens() function, the contract address for the paymentToken was sourced from the user-provided purchaseParams data, allowing the attacker to set it to their own malicious contract which imitates a legitimate ERC20 token.\n\nWhen the Minto contract sought to facilitate the repayment, it was misled into trading genuine BTCMT tokens for worthless imitation tokens created by the attacker, completing the attack.\n\n**Attack TX:**\n\nhttps://explorer.phalcon.xyz/tx/bsc/0x53be95dc8ffbc80060215133f76f48df35deef3cd7e1803e24b1e2f8aa53440b\n\n**Analysis:**\n\nhttps://twitter.com/bbbb/status/1683180340548890631?s=20",
    "images": [],
    "Lost": "$9K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/MintoFinance_exp.sol"
  },
  "Conic Finance 02": {
    "type": "Reentrancy",
    "date": "2023-07-22",
    "rootCause": "\n\nIncorrect assumption about the address returned by the Curve element registry for ETH as the underlying for the Curve v2 pool.\n\nSpecifically, the Conic ETH Omnipool uses the `CurveHandlerV3` to check whether we are currently in a reentrant call. This check was only executed if the pool being interacted with contains ETH, which was checked by calling the `_isETH` method. Our assumption was that Curve v2 pools using ETH have the ETH address (`0xeee\u2026eee`) as one of their coins. However, they instead have the WETH address. This led to `_isETH` returning false, and in turn, to the reentrancy guard of the rETH pool being bypassed.\n\nAfter bypass the check, attacker can manipulate the price of rETH Curve LP Token.\n\n**Attack TX:**\n\n[https://etherscan.io/tx/0x37acd17a80a5f95728459bfea85cb2e1f64b4c75cf4a4c8dcb61964e26860882](https://etherscan.io/tx/0x37acd17a80a5f95728459bfea85cb2e1f64b4c75cf4a4c8dcb61964e26860882)\n\n**Analysis:**\n\n[https://twitter.com/spreekaway/status/1682467603518726144](https://twitter.com/spreekaway/status/1682467603518726144)",
    "images": [],
    "Lost": "$934K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Conic02_exp.sol"
  },
  "Conic Finance": {
    "type": "Reentrancy",
    "date": "2023-07-21",
    "rootCause": "\n\nIncorrect assumption about the address returned by the Curve element registry for ETH as the underlying for the Curve v2 pool.\n\nSpecifically, the Conic ETH Omnipool uses the `CurveHandlerV3` to check whether we are currently in a reentrant call. This check was only executed if the pool being interacted with contains ETH, which was checked by calling the `_isETH` method. Our assumption was that Curve v2 pools using ETH have the ETH address (`0xeee\u2026eee`) as one of their coins. However, they instead have the WETH address. This led to `_isETH` returning false, and in turn, to the reentrancy guard of the rETH pool being bypassed.\n\nAfter bypass the check, attacker can manipulate the price of rETH Curve LP Token.\n\n\n\n**Attack TX:**\n\n[https://etherscan.io/tx/0x8b74995d1d61d3d7547575649136b8765acb22882960f0636941c44ec7bbe146](https://etherscan.io/tx/0x8b74995d1d61d3d7547575649136b8765acb22882960f0636941c44ec7bbe146)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1682356244299010049](https://twitter.com/BlockSecTeam/status/1682356244299010049)\n\n[https://medium.com/@ConicFinance/post-mortem-eth-and-crvusd-omnipool-exploits-c9c7fa213a3d](https://medium.com/@ConicFinance/post-mortem-eth-and-crvusd-omnipool-exploits-c9c7fa213a3d)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$3.25M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Conic_exp.sol"
  },
  "SUT": {
    "type": "Arbitrage",
    "date": "2023-07-21",
    "rootCause": "\n\nThe Root cause  is that the tokenPrice in the tokenPrice() function in the `0xF075c5C7BA59208c0B9c41afcCd1f60da9EC9c37` contract is much smaller than the token price in the pool.\n\n**Code Snippet\uff1a**\n\n\n\n\n\n**Attack TX:**\n\n[https://bscscan.com/tx/0xfa1ece5381b9e2b2b83cb10faefde7632ca411bb38dd6bafe1f1140b1360f6ae](https://bscscan.com/tx/0xfa1ece5381b9e2b2b83cb10faefde7632ca411bb38dd6bafe1f1140b1360f6ae)\n\n**Analysis:**\n\n[https://twitter.com/bulu4477/status/1682983956080377857](https://twitter.com/bulu4477/status/1682983956080377857)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$8k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/SUT_exp.sol"
  },
  "Utopia": {
    "type": "Bad randomness",
    "date": "2023-07-20",
    "rootCause": "\n\nThe root Cause is that the balance of the address can be set in the _airdrop() function, but the airdropAddress is not random, and the attacker can set the balance of the pair to 1 by calculating the receiver's address.\n\n**Vulnerable Code Snippet:**\n\n```solidity\n\n    function _airdrop(address from, address to, uint256 tAmount) private {\n        uint256 seed = (uint160(lastAirdropAddress) | block.number) ^ (uint160(from) ^ uint160(to));\n        address airdropAddress;\n        uint256 num = 1;\n        uint256 airdropAmount = 1;\n        for (uint256 i; i < num;) {\n            airdropAddress = address(uint160(seed | tAmount));\n            _balances[airdropAddress] = airdropAmount;\n            emit Transfer(airdropAddress, airdropAddress, airdropAmount);\n        unchecked{\n            ++i;\n            seed = seed >> 1;\n        }\n        }\n        lastAirdropAddress = airdropAddress;\n    }\n```\n\n**Attack TX:**\n\n[https://bscscan.com/tx/0xeb4eb487f58d39c05778fed30cd001b986d3c52279e44f46b2de2773e7ee1d5e](https://bscscan.com/tx/0xeb4eb487f58d39c05778fed30cd001b986d3c52279e44f46b2de2773e7ee1d5e)\n\n**Analysis:**\n\n[https://twitter.com/DeDotFiSecurity/status/1681923729645871104](https://twitter.com/DeDotFiSecurity/status/1681923729645871104)",
    "images": [],
    "Lost": "$119k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Utopia_exp.sol"
  },
  "FFIST": {
    "type": "Bad randomness",
    "date": "2023-07-20",
    "rootCause": "\n\nThe root cause is in `_airdrop()` function, the airdrop address can be calculated and it could overwrite any balance of an address to a specific number.\n\nAttacker can overwrote the balance of the swap, causing the K change thus a big gain on the swap.  The random seed is not randomized which is  easy to construct 'to' and 'tAmount' here to get an arbitrary airdropAddress address and that address will be used for balance overwritten.\n\n**Code Snippet\uff1a**\n\n```solidity\nfunction _airdrop(address from, address to, uint256 tAmount) private {\n        uint256 num = 4;\n        uint256 seed = (uint160(lastAirdropAddress) | block.number) ^ (uint160(from) ^ uint160(to));\n        uint256 airdropAmount = 1;\n        address airdropAddress;\n        for (uint256 i; i < num;) {\n            airdropAddress = address(uint160(seed | tAmount));\n            _balances[airdropAddress] = airdropAmount;\n            emit Transfer(airdropAddress, airdropAddress, airdropAmount);\n        unchecked{\n            ++i;\n            seed = seed >> 1;\n        }\n        }\n        lastAirdropAddress = airdropAddress;\n    }\n```\n\n**Attack TX:**\n\n[https://app.blocksec.com/explorer/tx/bsc/0x199c4b88cab6b4b495b9d91af98e746811dd8f82f43117c48205e6332db9f0e0?line=45&debugLine=45](https://app.blocksec.com/explorer/tx/bsc/0x199c4b88cab6b4b495b9d91af98e746811dd8f82f43117c48205e6332db9f0e0?line=45&debugLine=45)\n\n**Analysis:**\n\n[https://x.com/Phalcon_xyz/status/1681869807698984961](https://x.com/Phalcon_xyz/status/1681869807698984961)",
    "images": [],
    "Lost": "$110k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/FFIST_exp.sol"
  },
  "APEDAO": {
    "type": "Business Logic Flaw",
    "date": "2023-07-18",
    "rootCause": "\n\n`$APEDAO` contract mistook the attacker's behavior transfer as a sell operation and gradually added up a value called \"amountToDead\".Then the attacker repeatedly transfer in `$APEDAO` .Eventually, the attacker \n\ncalls godead function to burn the `$APEDAO` held in the pair contract, causing the token price to rise.\n\n**Code Snippet:**\n\n```solidity\n if (_transferType == 1){ // 1: buy\n            if ( openTime < block.timestamp && block.timestamp < limitTime  ){\n                require(_balances[_to] <= limitUserHave , \"current limit\");\n            }\n        }\n\n        setShareAndProcess(_from,_to,isSwap);\n\n        if (_transferType == 2){ \n            if (isOpenToDead){\n                amountToDead += amountx * 20 /100;\n            }\n            \n        }\n        \n function goDead() public{\n        if (amountToDead > 0){\n            _rawTransfer(address(pair), address(0xdEaD), amountToDead);\n            pair.sync();\n            amountToDead = 0;\n        }\n    }\n```\n\n**Attack TX:**\n\n[https://bscscan.com/tx/0x8d35dfd9968ce61fb969ffe8dcc29eeeae864e466d2cb0b7d26ce63644691994](https://bscscan.com/tx/0x8d35dfd9968ce61fb969ffe8dcc29eeeae864e466d2cb0b7d26ce63644691994)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1681316257034035201](https://twitter.com/BeosinAlert/status/1681316257034035201)",
    "images": [],
    "Lost": "$7K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/ApeDAO_exp.sol"
  },
  "BNO": {
    "type": "Business Logic Flaw",
    "date": "2023-07-18",
    "rootCause": "\n\nEmergency withdrawals were made without withdrawing the staked NFTs, and the rewardDebt ledger is set to 0, resulting in them still being claimable when the stake was canceled.\nThe attacker repeats this process and obtains a large reward.\n\n\n\n**Attack TX:**\n\n[https://bscscan.com/tx/0x33fed54de490797b99b2fc7a159e43af57e9e6bdefc2c2d052dc814cfe0096b9](https://bscscan.com/tx/0x33fed54de490797b99b2fc7a159e43af57e9e6bdefc2c2d052dc814cfe0096b9)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1681116206663876610](https://twitter.com/BeosinAlert/status/1681116206663876610)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$505K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/BNO_exp.sol"
  },
  "NewFi": {
    "type": "Slippage",
    "date": "2023-07-17",
    "rootCause": "\n\nThe root cause is the lack of slippage check. Specifically, the pool's slippage check for token swaps relied solely on a spot price, which allowed the attacker to manipulate the price, make the pool to execute a one-directional token swap, and then profit by sandwiching the swap.\n\n**Attack TX:**\n\nhttps://bscscan.com/tx/0x557628123d137ea49564e4dccff5f5d1e508607e96dd20fe99a670519b679cb5\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1680961588323557376](https://twitter.com/Phalcon_xyz/status/1680961588323557376)",
    "images": [],
    "Lost": "$31K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/NewFi_exp.sol"
  },
  "WGPT": {
    "type": "Flashloans",
    "date": "2023-07-12",
    "rootCause": "\n\nIn `transferFrom()`, the victim\u00a0contract will swap `$USDT` in the contract for `$WGPT`, thereby raising the price of `$WGPT`.\nThe attacker calls transferFrom multiple times to deposit into the pair and withdraws\u00a0it through the skim function, repeatedly increasing the price of `$WGPT`.\nFinally, the attacker profits by swapping\u00a0the held `$WGPT` \u2192 `$USDT`.\n\n**Attack TX**\n\nhttps://bscscan.com/tx/0x258e53526e5a48feb1e4beadbf7ee53e07e816681ea297332533371032446bfd\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1679042549946933248](https://twitter.com/Phalcon_xyz/status/1679042549946933248)",
    "images": [],
    "Lost": "$80k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/WGPT_exp.sol"
  },
  "RodeoFinance": {
    "type": "Price Manipulation",
    "date": "2023-07-11",
    "rootCause": "\n\nThe root cause is the Protocol utilized the faulty price oracle for LP pricing, so the attacker can use Sandwich attack to manipulate the price. And the Investor.earn() routine has a flaw that can be forced to swap `$USDC` \u2192 `$WETH` \u2192 `$unshETH`, so attacker can bypass slippage control.\n\n**Attack TX:**\n\n[https://arbiscan.io/tx/0xb1be5dee3852c818af742f5dd44def285b497ffc5c2eda0d893af542a09fb25a](https://arbiscan.io/tx/0xb1be5dee3852c818af742f5dd44def285b497ffc5c2eda0d893af542a09fb25a)\n\n**Analysis:**\n\nhttps://twitter.com/Phalcon_xyz/status/1678765773396008967\n\nhttps://twitter.com/peckshield/status/1678700465587130368\n\nhttps://medium.com/@Rodeo_Finance/rodeo-post-mortem-overview-f35635c14101",
    "images": [],
    "Lost": "$888k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/RodeoFinance_exp.sol"
  },
  "Libertify": {
    "type": "Reentrancy",
    "date": "2023-07-11",
    "rootCause": "\n\n`Deposit()` function lack of reentrancy protection, which allows the hacker to mint more shares via re-entering deposit() routine.\n\n**Code Snippet:**\n\n%206fb3d54ea5bd4f28935db54211f844c4/Untitled.png)\n\n**Attack TX:**\n\nhttps://polygonscan.com/tx/0x7320accea0ef1d7abca8100c82223533b624c82d3e8d445954731495d4388483\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1678688731908411393](https://twitter.com/peckshield/status/1678688731908411393)\n\n[https://twitter.com/Phalcon_xyz/status/1678694679767031809](https://twitter.com/Phalcon_xyz/status/1678694679767031809)",
    "images": [
      "images/deposit("
    ],
    "Lost": "$452k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Libertify_exp.sol"
  },
  "ArcadiaFi": {
    "type": "Reentrancy, Unchecked User Input",
    "date": "2023-07-10",
    "rootCause": "\n\nIn the function `vaultManagementAction()`, an attacker can first transfer all assets to a contract he controls, and then re-enter the function `liquidateVault()`to liquidate the vault. In this case, the global variable \"`isTrustedCreditorSet`\" will be set to `false` and the collateral check can be bypassed.\n\n**Vulnerable Code Snippet:**\n\n```jsx\nfunction liquidateVault(uint256 openDebt)\n        external\n        returns (address originalOwner, address baseCurrency_, address trustedCreditor_)\n    {\n        require(msg.sender == liquidator, \"V_LV: Only Liquidator\");\n\n        //Cache trustedCreditor.\n        trustedCreditor_ = trustedCreditor;\n\n        //Close margin account.\n        isTrustedCreditorSet = false;\n        trustedCreditor = address(0);\n        liquidator = address(0);\n\n        //If getLiquidationValue (total value discounted with liquidation factor to account for slippage)\n        //is smaller than the Used Margin: sum of the liabilities of the Vault (openDebt)\n        //and the max gas cost to liquidate the vault (fixedLiquidationCost),\n        //then the Vault can be successfully liquidated.\n        //Liquidations are triggered by the trustedCreditor (via Liquidator), the openDebt is\n        //passed as input to avoid the need of another contract call back to trustedCreditor.\n        require(getLiquidationValue() < openDebt + fixedLiquidationCost, \"V_LV: liqValue above usedMargin\");\n\n        //Set fixedLiquidationCost to 0 since margin account is closed.\n        fixedLiquidationCost = 0;\n\n        //Transfer ownership of the ERC721 in Factory of the Vault to the Liquidator.\n        IFactory(IMainRegistry(registry).factory()).liquidate(msg.sender);\n\n        //Transfer ownership of the Vault itself to the Liquidator.\n        originalOwner = owner;\n        _transferOwnership(msg.sender);\n\n        emit TrustedMarginAccountChanged(address(0), address(0));\n\n        return (originalOwner, baseCurrency, trustedCreditor_);\n    }\n```\n\n```solidity\nfunction vaultManagementAction(address actionHandler, bytes calldata actionData)\n        external\n        onlyAssetManager\n        returns (address, uint256)\n    {\n        require(IMainRegistry(registry).isActionAllowed(actionHandler), \"V_VMA: Action not allowed\");\n\n        (ActionData memory outgoing,,,) = abi.decode(actionData, (ActionData, ActionData, address[], bytes[]));\n\n        // Withdraw assets to actionHandler.\n        _withdraw(outgoing.assets, outgoing.assetIds, outgoing.assetAmounts, actionHandler);\n\n        // Execute Action(s).\n        ActionData memory incoming = IActionBase(actionHandler).executeAction(actionData);\n\n        // Deposit assets from actionHandler into vault.\n        _deposit(incoming.assets, incoming.assetIds, incoming.assetAmounts, actionHandler);\n\n        //If usedMargin is equal to fixedLiquidationCost, the open liabilities are 0 and the Vault is always in a healthy state.\n        uint256 usedMargin = getUsedMargin();\n        if (usedMargin > fixedLiquidationCost) {\n            //Vault must be healthy after actions are executed.\n            require(getCollateralValue() >= usedMargin, \"V_VMA: Vault Unhealthy\");\n        }\n\n        return (trustedCreditor, vaultVersion);\n    }\n```\n\n**Attack Tx:**\n\nhttps://optimistic.etherscan.io/tx/0xca7c1a0fde444e1a68a8c2b8ae3fb76ec384d1f7ae9a50d26f8bfdd37c7a0afe\n\nhttps://etherscan.io/tx/0xefc4ac015069fdf9946997be0459db44c0491221159220be782454c32ec2d651\n\n**Analysis:**\n\n[https://arcadiafinance.medium.com/post-mortem-72e9d24a79b0](https://arcadiafinance.medium.com/post-mortem-72e9d24a79b0)",
    "images": [],
    "Lost": "$400k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/ArcadiaFi_exp.sol"
  },
  "CIVNFT": {
    "type": "Access Control",
    "date": "2023-07-08",
    "rootCause": "\n\nBecause of a lack of Access control over specific functions `0x7ca06d68` , Attacker can manipulate the\u00a0`_uniswapV3MintCallback`\u00a0value and execute the attack contract directly.\n\n**Code Snippet:**\n\n\n\n\n\n**Attack Tx:**\n\nhttps://etherscan.io/tx/0x93a033917fcdbd5fe8ae24e9fe22f002949cba2f621a1c43a54f6519479caceb\n\nhttps://app.blocksec.com/explorer/tx/eth/0x93a033917fcdbd5fe8ae24e9fe22f002949cba2f621a1c43a54f6519479caceb\n\n**Analysis:**\n\n[https://blog.solidityscan.com/civnft-hack-analysis-4ee79b8c33d1](https://blog.solidityscan.com/civnft-hack-analysis-4ee79b8c33d1)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$180k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/CIVNFT_exp.sol"
  },
  "Civfund": {
    "type": "Access Control",
    "date": "2023-07-08",
    "rootCause": "\n\nThe root cause is that `uniswapV3MintCallback`  lack of access control so the attacker can call `uniswapV3MintCallback` to transfer the funds approved by other users.\n\n**Code Snippet:**\n\n%20lack%20of%20Access%20control%20322736af06834171b2d67a0a99303b33/Untitled.png)\n\n**Attack Tx:**\n\n[https://etherscan.io/tx/0xc42fc0e22a0f60cc299be80eb0c0ddce83c21c14a3dddd8430628011c3e20d6b](https://etherscan.io/tx/0xc42fc0e22a0f60cc299be80eb0c0ddce83c21c14a3dddd8430628011c3e20d6b)\n\n**Analysis**\n\n[https://twitter.com/HypernativeLabs/status/1677529544062803969](https://twitter.com/HypernativeLabs/status/1677529544062803969)\n\n[https://twitter.com/BeosinAlert/status/1677548773269213184](https://twitter.com/BeosinAlert/status/1677548773269213184)",
    "images": [
      "images/uniswapV3MintCallback("
    ],
    "Lost": "$165k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Civfund_exp.sol"
  },
  "LUSD": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-07-07",
    "rootCause": "the loan contract use getAmountsOut to calculate how many lusd should be mint,and the hacker manipulate the BTCB-BSC-USD pool, borrow 1BTC and return 800k BSC-USD,so the loan contract will mint extra lusd\n\nVulnerable code snippet:\n\n```solidity\nfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n```\n\nAttack tx:\n\nhttps://explorer.phalcon.xyz/tx/bsc/0x1eeef7b9a12b13f82ba04a7951c163eb566aa048050d6e9318b725d7bcec6bfa\n\nAnalysis:",
    "images": [],
    "Lost": "9464USDT",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main//src/test/2023-07/LUSD_exp.sol"
  },
  "BambooIA": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-07-04",
    "rootCause": "when the private updatePool function is invoked in the _transfer function, the resulting token transfer will burn the balance of the $BAMBOO token in the pair, causing a rise in the token price.\n\nVulnerable code snippet:\n\n```jsx\nfunction updatePool(uint256 amount) private {\n        if (amount > 10000 && balanceOf(uniswapPair) > amount) {\n            uint256 fA = amount / 100;\n            _balances[uniswapPair] = _balances[uniswapPair].sub(fA);\n            _balances[Factory] = _balances[Factory].add(fA);\n            try IUniswapV2Pair(uniswapPair).sync() {} catch {}\n        }\n    }\n```\n\n\n\nAttack tx:\n\nhttps://explorer.phalcon.xyz/tx/bsc/0x88a6c2c3ce86d4e0b1356861b749175884293f4302dbfdbfb16a5e373ab58a10\n\nAnalysis:\n\nPost-mortem : [https://twitter.com/Phalcon_xyz/status/1676220090142916611](https://twitter.com/Phalcon_xyz/status/1676220090142916611)",
    "images": [
      "images/BambooIA_Untitled.jpeg"
    ],
    "Lost": "200BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Bamboo_exp.sol"
  },
  "BaoCommunity": {
    "type": "Flashloans",
    "date": "2023-07-04",
    "rootCause": "precision loss issue(**Round error) in compound V2\n\nThe attacker manipulated the exchange rate, borrowed a significant amount of baoETH, depleted the liquidity pool on Balancer, and converted it into wETH.\n\nVulnerable code snippet:\n\n```solidity\n(vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n```\n\nAttack tx:\n\n[https://etherscan.io/tx/0xdd7dd68cd879d07cfc2cb74606baa2a5bf18df0e3bda9f6b43f904f4f7bbdfc1](https://etherscan.io/tx/0xdd7dd68cd879d07cfc2cb74606baa2a5bf18df0e3bda9f6b43f904f4f7bbdfc1)\n\nAnalysis:\n\nhttps://twitter.com/PeckShieldAlert/status/1676224397248454657\n\nhttps://medium.com/baomunity/analysis-and-response-to-the-july-4th-baoeth-exploit-3d60b886fcce",
    "images": [],
    "Lost": "$46k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/Bao_exp.sol"
  },
  "AzukiDAO": {
    "type": "Access Control",
    "date": "2023-07-03",
    "rootCause": "The contract recorded the extracted signature, but did not verify the signature. As long as the passed parameters remain unchanged, multiple extractions can be achieved before the signature time limit expires, causing the attacker to use one signature to perform multiple token extraction operations.\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\nhttps://etherscan.io/tx/0x6233c9315dd3b6a6fcc7d653f4dca6c263e684a76b4ad3d93595e3b8e8714d34\n\nAnalysis:\n\nhttps://twitter.com/sharkteamorg/status/1676892088930271232",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$69k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-07/AzukiDAO_exp.sol"
  },
  "Biswap": {
    "type": "Access Control",
    "date": "2023-06-30",
    "rootCause": "Biswap's V3Migrator contract lacks parameter check, which allows the attacker to steal tokens from the users who approved LP tokens to the V3Migrator contract.\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\n[https://bscscan.com/tx/0xebe5248820241d8de80bcf66f4f1bfaaca62962824efaaa662db84bd27f5e47e](https://bscscan.com/tx/0xebe5248820241d8de80bcf66f4f1bfaaca62962824efaaa662db84bd27f5e47e), [https://bscscan.com/address/0xa1e31b29f94296fc85fac8739511360f279b1976](https://bscscan.com/address/0xa1e31b29f94296fc85fac8739511360f279b1976)\n\nAnalysis:\n\nhttps://twitter.com/MetaTrustAlert/status/1674814217122349056?s=20",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$72k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Biswap_exp.sol"
  },
  "Themis": {
    "type": "Price Manipulation",
    "date": "2023-06-28",
    "rootCause": "The LP token price is determined by aggregating the total value of all tokens in the pool. In this case, the attacker managed to manipulate the oracle by exchanging tokens within the Balancer pool, leading to the hack.\n\nVulnerable code snippet:\n\n\n\n(source code not available)\n\nAttack tx:\n\nhttps://arbiscan.io/tx/0xff368294ccb3cd6e7e263526b5c820b22dea2b2fd8617119ba5c3ab8417403d8\n\nAnalysis:\n\n[https://twitter.com/BeosinAlert/status/1673930979348717570](https://twitter.com/BeosinAlert/status/1673930979348717570)\n[https://twitter.com/BlockSecTeam/status/1673897088617426946](https://twitter.com/BlockSecTeam/status/1673897088617426946)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$370k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Themis_exp.sol"
  },
  "SHIDO": {
    "type": "Flashloans",
    "date": "2023-06-23",
    "rootCause": "The attacker took advantage of the lock and claim mechanism, as well as the price difference between the two pools.\n\nVulnerable code snippet:\n\nAttack tx:\n\nhttps://bscscan.com/tx/0x72f8dd2bcfe2c9fbf0d933678170417802ac8a0d8995ff9a56bfbabe3aa712d6\n\nAnalysis:\n\nhttps://x.com/Phalcon_xyz/status/1672473343734480896",
    "images": [],
    "Lost": "997 WBNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/SHIDO_exp.sol"
  },
  "BabyDogeCoin02": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-06-21",
    "rootCause": "In the process between `swapTokensForEth` and `addLiquidity`, there exists a time window that attackers can exploit to manipulate the market price.\n\nVulnerable code snippet:\n\n```solidity\nfunction swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n        // split the contract balance into halves\n        uint256 half = contractTokenBalance.div(2);\n        uint256 otherHalf = contractTokenBalance.sub(half);\n\n        // capture the contract's current ETH balance.\n        // this is so that we can capture exactly the amount of ETH that the\n        // swap creates, and not make the liquidity event include any ETH that\n        // has been manually sent to the contract\n        uint256 initialBalance = address(this).balance;\n\n        // swap tokens for ETH\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n\n        // how much ETH did we just swap into?\n        uint256 newBalance = address(this).balance.sub(initialBalance);\n\n        // add liquidity to uniswap\n        addLiquidity(otherHalf, newBalance);\n        \n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    }\n```\n\nAttack tx:\n\nhttps://bscscan.com/tx/0xbaf3e4841614eca5480c63662b41cd058ee5c85dc69198b29e7ab63b84bc866c\n\nAnalysis:\n\nhttps://x.com/hexagate_/status/1671517819840745475",
    "images": [],
    "Lost": "441 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/BabyDogeCoin02_exp.sol"
  },
  "BUNN": {
    "type": "Price Manipulation",
    "date": "2023-06-21",
    "rootCause": "Attacker called `deliver` function to shrink `_rTotal` value which increased the BUNN token balance of the Pancake pair and allowed them to perform the swap with 52 BNB profit.\n\nVulnerable code snippet:\n\n```solidity\n   function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n```\n\nAttack tx:\n\nhttps://bscscan.com/tx/0x24a68d2a4bbb02f398d3601acfd87b09f543d935fc24862c314aaf64c295acdb\n\nAnalysis:\n\nhttps://twitter.com/DecurityHQ/status/1671803688996806656",
    "images": [],
    "Lost": "52BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06//BUNN_exp.sol"
  },
  "MIMSpell": {
    "type": "Flashloans",
    "date": "2024-01-30",
    "rootCause": "The attack exploited an accuracy issue in calculating loan variables, allowing manipulation of key variables elastic and base. This imbalance led to errors in collateral and loan amount calculations, resulting in excessive lending of MIM tokens.\n\nVulnerable code snippet:\n\n```solidity\nfunction _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\n\n        BorrowCap memory cap =  borrowLimit;\n\n        require(totalBorrow.elastic <= cap.total, \"Borrow Limit reached\");\n\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));\n        \n        uint256 newBorrowPart = userBorrowPart[msg.sender].add(part);\n        require(newBorrowPart <= cap.borrowPartPerAddress, \"Borrow Limit reached\");\n        _preBorrowAction(to, amount, newBorrowPart, part);\n\n        userBorrowPart[msg.sender] = newBorrowPart;\n\n        // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows\n        share = bentoBox.toShare(magicInternetMoney, amount, false);\n        bentoBox.transfer(magicInternetMoney, address(this), to, share);\n\n        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);\n    }\n```\n\n```solidity\nfunction _repay(\n        address to,\n        bool skim,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n        userBorrowPart[to] = userBorrowPart[to].sub(part);\n\n        uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);\n        bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);\n        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);\n    }\n```\n\n```solidity\nfunction add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return (total, base);\n    }\n```\n\n```solidity\nfunction sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return (total, elastic);\n    }\n\n```\n\n```solidity\nfunction toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n```\n\n```solidity\nfunction toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n```\n\nAttack transaction:\n\n[https://phalcon.blocksec.com/explorer/tx/eth/0x26a83db7e28838dd9fee6fb7314ae58dcc6aee9a20bf224c386ff5e80f7e4cf2](https://phalcon.blocksec.com/explorer/tx/eth/0x26a83db7e28838dd9fee6fb7314ae58dcc6aee9a20bf224c386ff5e80f7e4cf2)\n\nAnalysis:\n\n[https://twitter.com/kankodu/status/1752581744803680680](https://twitter.com/kankodu/status/1752581744803680680)",
    "images": [],
    "Lost": "6,5M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/MIMSpell2_exp.sol"
  },
  "ARA": {
    "type": "Lack of permission control",
    "date": "2023-06-18",
    "rootCause": "A bug in the contract's handling of permissions, the approved token does not limit the funds transferred from the caller for swap purposes.\n\nVulnerable code snippet:\n\nAttack tx:\n\nhttps://bscscan.com/tx/0xd87cdecd5320301bf9a985cc17f6944e7e7c1fbb471c80076ef2d031cc3023b2\n\nAnalysis:",
    "images": [],
    "Lost": "$125k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/ARA_exp.sol"
  },
  "Pawnfi": {
    "type": "Access Control, Incorrect logic",
    "date": "2023-06-17",
    "rootCause": "A failure of the protocol to verify whether the NFT had actually been transferred when users used a specified NFT as collateral for borrowing.\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\nhttps://etherscan.io/tx/0x8d3036371ccf27579d3cb3d4b4b71e99334cae8d7e8088247517ec640c7a59a5\n\nAnalysis:\n\nhttps://blog.solidityscan.com/pawnfi-hack-analysis-38ac9160cbb4",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$820K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Pawnfi_exp.sol"
  },
  "CFC": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-06-15",
    "rootCause": "Attacker could initiate transferFrom from the DEX contract that allowed him to transfer users that gave an approval for that contract.\n\nVulnerable code snippet:\n\n%20241501e1d4d2496a8c9e0984c15d0507/Untitled.png)\n\nAttack tx:\n\nhttps://explorer.phalcon.xyz/tx/bsc/0xa3c130ed8348919f73cbefce0f22d46fa381c8def93654e391ddc95553240c1e\n\nAnalysis:\n\nhttps://twitter.com/hexagate_/status/1669280632738906113\n\nhttps://x.com/Phalcon_xyz/status/1669262923758456833",
    "images": [
      "images/CFC_Untitled.png"
    ],
    "Lost": "$16k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/CFC_exp.sol"
  },
  "DEPUSDT_LEVUSDC": {
    "type": "Access Control",
    "date": "2023-06-15",
    "rootCause": "A public function that enabled the attacker to obtain approval as a spender for $DEPUSDT and $LEVUSDC tokens.\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\nAttack Tx DEPUSDT : [https://etherscan.io/tx/0xf0a13b445674094c455de9e947a25bade75cac9f5176695fca418898ea25742f](https://etherscan.io/tx/0xf0a13b445674094c455de9e947a25bade75cac9f5176695fca418898ea25742f)\nAttack Tx LEVUSDC : [https://etherscan.io/tx/0x800a5b3178f680feebb81af69bd3dff791b886d4ce31615e601f2bb1f543bb2e](https://etherscan.io/tx/0x800a5b3178f680feebb81af69bd3dff791b886d4ce31615e601f2bb1f543bb2e)\n\nAnalysis:\n\nhttps://blog.solidityscan.com/depusdt-and-levusdc-hack-analysis-d27032d8f2cd",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$105k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/DEPUSDT_LEVUSDC_exp.sol"
  },
  "Sturdy Finance": {
    "type": "Reentrancy",
    "date": "2023-06-12",
    "rootCause": "`setUserUseReserveAsCollateral()` enables users to toggle whether or not an asset is used as collateral.\n\nVulnerable code snippet:\n\nAttack tx:\n\nhttps://etherscan.io/tx/0xeb87ebc0a18aca7d2a9ffcabf61aa69c9e8d3c6efade9e2303f8857717fb9eb7\n\nAnalysis:\n\nhttps://sturdyfinance.medium.com/exploit-post-mortem-49261493307a",
    "images": [],
    "Lost": "$800k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/Sturdy_exp.sol"
  },
  "SellToken04": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-06-11",
    "rootCause": "The price in the USDT-SELLC pool was manipulated, and the sendMiner function relied on the price from that pool.\n\nVulnerable code snippet:\n\n\n\n\n\nAttack tx:\n\nhttps://bscscan.com/tx/0xe968e648b2353cea06fc3da39714fb964b9354a1ee05750a3c5cc118da23444b\n\nAnalysis:",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$109k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/SELLC03_exp.sol"
  },
  "CompounderFinance": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-06-07",
    "rootCause": "Fluctuations in the amount of funds available for exchange due to changes in the proportions of the liquidity pool.\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\n[https://etherscan.io/tx/0xcff84cc137c92e427f720ca1f2b36fbad793f34ec5117eed127060686e6797b1](https://etherscan.io/tx/0xcff84cc137c92e427f720ca1f2b36fbad793f34ec5117eed127060686e6797b1)\n\nAnalysis:\n\nhttps://twitter.com/numencyber/status/1666346419702362112",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$27,174",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/CompounderFinance_exp.sol"
  },
  "VINU": {
    "type": "Insufficient validation",
    "date": "2023-06-06",
    "rootCause": "The exploiter passes an existing Uniswap pool as devaddr allowing him to manipulate the price.\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\nhttps://etherscan.io/tx/0xaf46a42fe1ed7193b25c523723dc047c7500e50a00ecb7bbb822d665adb3e1f3\n\nAnalysis:\n\nhttps://x.com/hexagate_/status/1666051854386511873?cxt=HHwWgoC24bPVgJ8uAAAA",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$6k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/VINU_exp.sol"
  },
  "NST Simple Swap": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-06-02",
    "rootCause": "Vulnerable code snippet:\n\nAttack tx:\n\nhttps://polygonscan.com/tx/0xa1f2377fc6c24d7cd9ca084cafec29e5d5c8442a10aae4e7e304a4fbf548be6d\n\nAnalysis:",
    "images": [],
    "Lost": "$40k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2023-06/NST_exp.sol"
  },
  "Jimbo": {
    "type": "Price Manipulation",
    "date": "2023-05-29",
    "rootCause": "\n\nThis attack exploited a vulnerability in the JimboController contract, which allows anyone to use the shift() function to make the contract execute liquidity removal and addition operations. The shift() function takes the funds of the contract to add liquidity, resulting in all the WETH of the JimboController contract being added as liquidity.\n\nSince the prices of WETH and JIMBO in the pool are not balanced, when adding liquidity, the required token quantity will be calculated based on the current price, allowing the attacker to obtain more WETH.\n\n**Vulnerable code snippet:**\n\n[https://arbiscan.io/address/0x271944d9D8CA831F7c0dBCb20C4ee482376d6DE7#code#F1#L308](https://arbiscan.io/address/0x271944d9D8CA831F7c0dBCb20C4ee482376d6DE7#code#F1#L308)\n\n```jsx\nfunction shift() public returns (bool) { **//vulnerable point**\n        if (canShift()) {\n            // Let the token know the protocol is rebalancing\n            jimbo.setIsRebalancing(true);\n\n            // Get the active bin\n            uint24 activeBin = pair.getActiveId();\n\n            // Remove all non-floor bin liquidity (max bin -> anchor bin)\n            _removeNonFloorLiquidity();\n\n            // Remove all floor bin liquidity\n            _removeFloorLiquidity();\n\n            // Count the total JIMBO and ETH in the contract after liquidity removal\n            uint256 totalJimboInPool = jimbo.balanceOf(address(this));\n            uint256 totalEthInContract = weth.balanceOf(address(this));\n\n            // Floor is based on total eth / circulating supply\n            uint256 totalCirculatingJimbo = jimbo.totalSupply() -\n                jimbo.balanceOf(address(0)) -\n                totalJimboInPool;\n\n            // Calculate the new target floor bin\n            uint24 newFloorBin = _calculateNewFloorBin(\n                totalEthInContract,\n                totalCirculatingJimbo\n            );\n\n            // Calculate new anchor bin id\n            // Make sure you use the new floor bin and not the stale one\n            uint24 newAnchorBin = activeBin - newFloorBin > NUM_ANCHOR_BINS\n                ? activeBin - NUM_ANCHOR_BINS\n                : activeBin - 1;\n\n            // Set internal bin state\n            _setBinState({\n                floorBin_: newFloorBin,\n                anchorBin_: newAnchorBin, // this is not always true\n                triggerBin_: activeBin + NUM_ANCHOR_BINS,\n                maxBin_: activeBin + NUM_LIQ_BINS - 1 // decrement because we are adding inclusive of active bin\n            });\n\n            // Deploy all the JIMBO liquidity first\n            _deployJimboLiquidity();  **//vulnerable point**\n\n            // Deploy floor bin liquidity with 90% of all ETH in the contract\n            _deployFloorLiquidity((weth.balanceOf(address(this)) * 90) / 100); **//vulnerable point**\n\n            // Use entire remaining weth balance in the contract to deploy anchors\n            _deployAnchorLiquidity(weth.balanceOf(address(this))); **//vulnerable point**\n\n            // Let the token know we are done rebalancing to apply taxes\n            jimbo.setIsRebalancing(false);\n            return true;\n        } else return false;\n    }\n```\n\n**Attack tx:**\n\n[https://arbiscan.io/tx/0xf9baf8cee8973cf9700ae1b1f41c625d7a2abdbcbc222582d24a8f2f790d0b5a](https://arbiscan.io/tx/0xf9baf8cee8973cf9700ae1b1f41c625d7a2abdbcbc222582d24a8f2f790d0b5a)\n[https://arbiscan.io/tx/0xfda5464e97043a2d0093cbed6d0a64f6a86049f5e9608c014396a7390188670e](https://arbiscan.io/tx/0xfda5464e97043a2d0093cbed6d0a64f6a86049f5e9608c014396a7390188670e)\n[https://arbiscan.io/tx/0x3c6e053faecd331883641c1d23c9d9d37d065e4f9c4086e94a3c34bf8702618a](https://arbiscan.io/tx/0x3c6e053faecd331883641c1d23c9d9d37d065e4f9c4086e94a3c34bf8702618a)\n[https://arbiscan.io/tx/0x44a0f5650a038ab522087c02f734b80e6c748afb207995e757ed67ca037a5eda](https://arbiscan.io/tx/0x44a0f5650a038ab522087c02f734b80e6c748afb207995e757ed67ca037a5eda)\n\n**Analysis:**\n\n[https://twitter.com/cryptofishx/status/1662888991446941697](https://twitter.com/cryptofishx/status/1662888991446941697)\n[https://twitter.com/yicunhui2/status/1663793958781353985](https://twitter.com/yicunhui2/status/1663793958781353985)",
    "images": [],
    "Lost": "$8M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Jimbo_exp.sol"
  },
  "BabyDogeCoin": {
    "type": "Slippage",
    "date": "2023-05-29",
    "rootCause": "\n\nsmhkptking: FarmZAP contract enjoys 0 tax of babydoge buy/sell, attacker manipulated pancake pair price.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x451583b6da479eaa04366443262848e27706f762#code#F1#L184](https://bscscan.com/address/0x451583b6da479eaa04366443262848e27706f762#code#F1#L184)\n\n```jsx\n/*\n     * @notice Swaps input token to ERC20 token and deposits on behalf of msg.sender to specified farm\n     * @param farm Farm address, where tokens should be deposited\n     * @param amountIn Amount of input tokens\n     * @param amountOutMin Minimum amount of tokens to receive\n     * @param path Address path to swap input token\n     * @return Received token amount\n     * @dev Last element of path must be stake token\n     * @dev First element of path must be input token\n     */\n    function buyTokensAndDepositOnBehalf(\n        IFarm farm,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) external payable returns(uint256) {\n        if (msg.value > 0) {\n            require(address(WBNB) == path[0], \"Input token != WBNB\");\n            require(amountIn == msg.value, \"Invalid msg.value\");\n            WBNB.deposit{value: amountIn}();\n        } else {\n            IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n        }\n        address tokenOut = path[path.length - 1];\n        require(tokenOut == farm.stakeToken(), \"Not a stake token\");\n\n        _approveIfRequired(path[0], address(router), amountIn);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            block.timestamp + 1200\n        );\n        uint256 received = IERC20(tokenOut).balanceOf(address(this));\n\n        _approveIfRequired(tokenOut, address(farm), received);\n        farm.depositOnBehalf(received, msg.sender);\n\n        emit TokensBoughtAndDeposited (\n            address(farm),\n            msg.sender,\n            path[0],\n            tokenOut,\n            amountIn,\n            received\n        );\n\n        return received;\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x098e7394a1733320e0887f0de22b18f5c71ee18d48a0f6d30c76890fb5c85375](https://bscscan.com/tx/0x098e7394a1733320e0887f0de22b18f5c71ee18d48a0f6d30c76890fb5c85375)\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1662744426475831298](https://twitter.com/Phalcon_xyz/status/1662744426475831298)",
    "images": [],
    "Lost": "$135k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BabyDogeCoin_exp.sol"
  },
  "FAPEN": {
    "type": "Business Logic Flaw",
    "date": "2023-05-29",
    "rootCause": "\n\nIt does not update the timestamp after the registration. In this case, the attacker can invoke the function register for multiple times.\n\n### Vulnerable code snippet:\n\n[SheepFarm | Address 0x4726010da871f4b57b5031E3EA48Bde961F122aA | BscScan](https://bscscan.com/address/0x4726010da871f4b57b5031E3EA48Bde961F122aA#code#107)\n\nThe `register()` function rewards the double gems token if you statisfy the `if` condition.\n\nThe hacker abuse the `register()` function to get extra GEM bonuse. \n\n```solidity\nfunction register(address neighbor) external initialized {\n\t\taddress user = msg.sender;\n    require(villages[user].timestamp == 0, \"just new users\"); //vulnerable points\n    uint256 gems;\n    totalVillages++;\n    if (villages[neighbor].sheeps[0] > 0 && neighbor != manager) {\n        gems += GEM_BONUS * 2;\n    } else{\n        neighbor = manager;\n        gems += GEM_BONUS;\n    }\n    villages[neighbor].neighbors++;\n    villages[user].neighbor = neighbor;\n    villages[user].gems += gems;\n    emit Newbie(msg.sender, gems);\n}\n```\n\n### Attack tx:\n\n[https://bscscan.com/tx/0x5735026e5de6d1968ab5baef0cc436cc0a3f4de4ab735335c5b1bd31fa60c582](https://bscscan.com/tx/0x5735026e5de6d1968ab5baef0cc436cc0a3f4de4ab735335c5b1bd31fa60c582)\n\n### Analysis:\n\n- [https://twitter.com/AnciliaInc/status/1592658104394473472](https://twitter.com/AnciliaInc/status/1592658104394473472)\n- [https://twitter.com/BlockSecTeam/status/1592734292727455744](https://twitter.com/BlockSecTeam/status/1592734292727455744)",
    "images": [],
    "Lost": "$600",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/FAPEN_exp.sol"
  },
  "NOON (NO)": {
    "type": "Access Control",
    "date": "2023-05-29",
    "rootCause": "Incorrect function visibility\n\n### Vulnerable code snippet\n\n[https://library.dedaub.com/decompile?md5=505e4227fb452bfde125eed91b9f861b](https://library.dedaub.com/decompile?md5=505e4227fb452bfde125eed91b9f861b)\n\nThe `_transfer` function has wrong visibility which does not follow standard ERC20 implentation.\n\n```jsx\nfunction _transfer(address varg0, address varg1, uint256 varg2) public payable {  **//vulnerable point**\n    require(msg.data.length - 4 >= 96);\n    require(varg1);\n    require(varg2 <= _balanceOf[varg0]);\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    _balanceOf[varg1] += varg2;\n    emit Transfer(varg0, varg1, varg2);\n    assert(_balanceOf[varg1] + _balanceOf[varg0] == _balanceOf[varg0] + _balanceOf[varg1]);\n}\n```\n\n### Attack tx:\n\n[0x23fb7f093e827ed061 | Phalcon](https://explorer.phalcon.xyz/tx/eth/0x23fb7f093e827ed061aafb574cfd420eab879621c7f78cb341292e106a3a88c0)\n\n### Analysis:\n\n[https://twitter.com/hexagate_/status/1663501545105702912](https://twitter.com/hexagate_/status/1663501545105702912)",
    "images": [],
    "Lost": "$2K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NOON_exp.sol"
  },
  "GPT Token": {
    "type": "Incorrect logic, skim",
    "date": "2023-05-25",
    "rootCause": " \n\nFee Mechanism issue\n\n**Vulnerable code snippet:**\n\nBlocksec:\n\n\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0xb77cb34cd01204bdad930d8c172af12462eef58dea16199185b77147d6533391](https://explorer.phalcon.xyz/tx/bsc/0xb77cb34cd01204bdad930d8c172af12462eef58dea16199185b77147d6533391)\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1661424685320634368](https://twitter.com/Phalcon_xyz/status/1661424685320634368)",
    "images": [
      "images/GPT_Token_Untitled.jpeg"
    ],
    "Lost": "$42k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/GPT_exp.sol"
  },
  "Local Trade LCT": {
    "type": "Access Control",
    "date": "2023-05-24",
    "rootCause": " \n\nImproper Access Control of Close-source contract, involved modifying certain contract parameters and exploiting vulnerabilities in the getTokenPrice() function.\n\n**Vulnerable code snippet:**\n\n[https://library.dedaub.com/decompile?md5=eac769a0f6ce1325c4c553270fd17362](https://library.dedaub.com/decompile?md5=eac769a0f6ce1325c4c553270fd17362)\n\n\n\n\n\n**Attack tx:**\n\n1. [https://bscscan.com/tx/0x57b589f631f8ff20e2a89a649c4ec2e35be72eaecf155fdfde981c0fec2be5ba](https://bscscan.com/tx/0x57b589f631f8ff20e2a89a649c4ec2e35be72eaecf155fdfde981c0fec2be5ba)\n2. [https://bscscan.com/tx/0xbea605b238c85aabe5edc636219155d8c4879d6b05c48091cf1f7286bd4702ba](https://bscscan.com/tx/0xbea605b238c85aabe5edc636219155d8c4879d6b05c48091cf1f7286bd4702ba)\n3. [https://bscscan.com/tx/0x49a3038622bf6dc3672b1b7366382a2c513d713e06cb7c91ebb8e256ee300dfb](https://bscscan.com/tx/0x49a3038622bf6dc3672b1b7366382a2c513d713e06cb7c91ebb8e256ee300dfb)\n4. [https://bscscan.com/tx/0x042b8dc879fa193acc79f55a02c08f276eaf1c4f7c66a33811fce2a4507cea63](https://bscscan.com/tx/0x042b8dc879fa193acc79f55a02c08f276eaf1c4f7c66a33811fce2a4507cea63)\n\n**Analysis:**\n\n[https://twitter.com/numencyber/status/1661213691893944320](https://twitter.com/numencyber/status/1661213691893944320)",
    "images": [
      "images/Local_Trade_LCT_Untitled.jpeg",
      "images/Untitled%201.jpeg"
    ],
    "Lost": "384 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LocalTrader2_exp.sol"
  },
  "CS Token": {
    "type": "Miscalculation",
    "date": "2023-05-24",
    "rootCause": " \n\nBlocksec: The root cause is that in _transfer(), the burnAmount is calculated from SellAmount, but the issue is that SellAmount is not updated!\n\nNumen: By exploiting the mechanism of burning funds during the transaction, the attacker gradually reduced the quantity of CS tokens in the [BUSD, CS] trading pair.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x8BC6Ce23E5e2c4f0A96429E3C9d482d74171215e#code#L711](https://bscscan.com/address/0x8BC6Ce23E5e2c4f0A96429E3C9d482d74171215e#code#L711)\n\n```jsx\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(!blackList[from], \"black account\");\n        require(!blackList[to], \"black account\");\n        if (!canContract && _isContract(msg.sender) && !exPairs[from]) {\n            require(whiteContractList[msg.sender], \"not allowed contract trade\");\n        }\n\n        if (!canBuy &&  exPairs[from]){\n            require(whiteList[to], \"not allow trade\");\n        }\n        if (!canSell &&  exPairs[to]){\n            require(whiteList[from], \"not allow trade\");\n        }        \n\n        bool takeTransFee = isTransFee && !feeWhiteList[from] && !feeWhiteList[to] && !exPairs[from] && !exPairs[to] && !_isLiquidity(from,to)  ;\n        bool takeSellFee = isSellFee && !feeWhiteList[from] &&  exPairs[to] && !_isLiquidity(from,to);\n        bool takeBuyFee = isBuyFee && !feeWhiteList[to] &&  exPairs[from] && !_isLiquidity(from,to);\n\n        if (_isLiquidity(from,to) && exPairs[to]){\n            updateLiquidityInfo(amount);\n        }\n\n        bool canSell =  sellAmount >= 1;\n        if(canSell &&from != address(this) &&from != uniswapV2Pair &&from != owner() && to != owner() && !_isLiquidity(from,to)){\n            sync();\n        }\n\n        FeeParam memory param;\n        if (takeBuyFee){\n            require(amount <= limitBuy,\"exceeds buying limit!\");\n            uint256 price = getBuyPrice(from);\n            updatePrice(price);              \n            _getBuyParam(amount,param);\n        }\n        if(takeSellFee){\n            require(amount <= limitSell,\"exceeds selling limit!\");\n            uint256 price = getSellPrice(to);\n            updatePrice(price);\n            _getSellParam(amount,param);\n            sellAmount = amount;  **//vulnerable point**\n            uint256 contractTokenBalance = balanceOf(address(this));\n            bool canSwap = contractTokenBalance >= minTokenNumberToSell;\n\n            if (\n                canSwap &&\n                !inSwapAndLiquify &&\n                from != uniswapV2Pair\n            ) {\n                inSwapAndLiquify = true;\n\n                swapAndLiquify(contractTokenBalance);\n\n                inSwapAndLiquify = false;\n            }\n        }\n        if (takeTransFee){\n            _getTransferParam(amount,param);\n        }\n        if (param.tTransferAmount == 0) {\n            param.tTransferAmount = amount;\n        }        \n        _tokenTransfer(from,to,amount,param);\n    }\n\nfunction sync() private lockTheSync{\n        if (totalBurnAmount>=maxBurnAmount){\n            return;\n        }\n        uint256 burnAmount = sellAmount.mul(800).div(1000); **//vulnerable point**\n        sellAmount = 0;\n```\n\n\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0x906394b2ee093720955a7d55bff1666f6cf6239e46bea8af99d6352b9687baa4](https://explorer.phalcon.xyz/tx/bsc/0x906394b2ee093720955a7d55bff1666f6cf6239e46bea8af99d6352b9687baa4)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1661098394130198528](https://twitter.com/BlockSecTeam/status/1661098394130198528)\n[https://twitter.com/numencyber/status/1661207123102167041](https://twitter.com/numencyber/status/1661207123102167041)",
    "images": [
      "images/CS_Token_Untitled.jpeg"
    ],
    "Lost": "714K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/CS_exp.sol"
  },
  "LFI Token": {
    "type": "Business Logic Flaw",
    "date": "2023-05-23",
    "rootCause": "\n\nThere is no time lock for the user 'staking' amount(balance).\n\n**Vulnerable code snippet:**\n\n```solidity\n\nfunction claimRewards(address to) external {\n\n        require(to != address(0), \"HOUSEPOOL:to address can't be zero\");\n\n        cleanUserMapping();\n\n        FarmInfo memory farm = updateFarm();\n\n        UserInfo storage user = userInfo[msg.sender];\n\n        int256 accumulatedReward = int256(   **//vulnerable point: no time lock check**\n\n            (balance0f(msg.sender) * farm.accRewardsPerShare) /\n\n                ACC_REWARD_PRECISION\n\n        );\n\n        uint256_pendingReward =uint256(accumulatedReward - user.rewardDebt\n\n            pendingRewards [msg. sender];\n\n        user. rewardDebt = accumulatedReward;\n\n        pendingRewards [msg.sender] = 0;\n\n        bool success = ILFIToken(STAKED_TOKEN).transfer(to, _pendingReward);\n\n        if (success) [\n\n            emit RewardsClaimed(msg.sender, to, _pendingReward);\n\n        }else {\n\n            revert();\n\n        }\n\n```\n\n**Attack tx:**\n\n[https://polygonscan.com/tx/0xa0480d0f7c8d8bf898cadde954e773ddc3740f1ffa31cdd98fe4c5f5d8266243](https://polygonscan.com/tx/0xa0480d0f7c8d8bf898cadde954e773ddc3740f1ffa31cdd98fe4c5f5d8266243)\n\n**Analysis:**\n\n[https://twitter.com/AnciliaInc/status/1660767088699666433](https://twitter.com/AnciliaInc/status/1660767088699666433)",
    "images": [],
    "Lost": "36K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LFI_exp.sol"
  },
  "landNFT": {
    "type": "Lack of permission control",
    "date": "2023-05-14",
    "rootCause": "\n\nLack of permission control on mint.\n\n**Vulnerable code snippet:**\n\n```solidity\n\nfunction mint(address player,uint256 amount) external whenNotPaused() onlyMiner{\n            uint256 _tokenId = totalSupply();\n            require(_tokenId.add(amount)<=MAX_SUPPLY,\"MAX_SUPPLY err\");\n            _safeMint(player, amount);\n        }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xe4db1550e3aa78a05e93bfd8fbe21b6eba5cce50dc06688949ab479ebed18048](https://bscscan.com/tx/0xe4db1550e3aa78a05e93bfd8fbe21b6eba5cce50dc06688949ab479ebed18048)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1658002030953365505](https://twitter.com/BeosinAlert/status/1658002030953365505)",
    "images": [],
    "Lost": "149,616 $BUSD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/landNFT_exp.sol"
  },
  "SellToken03": {
    "type": "Unchecked User Input",
    "date": "2023-05-14",
    "rootCause": "\n\nStakingRewards contract's Claim() function did not properly validate the input parameters, allowing the attacker to pass a fake token to obtain more rewards.\n\n**Vulnerable code snippet:**\n\n```solidity\n\nfunction claim(address token,address token1) public    { **//vulnerable point: no token validation**\n\n        require(listToken[token]);\n\n        require(users[token][msg.sender].mnu > 0);\n\n        require(block.timestamp > stakedOfTime[token][msg.sender]);\n\n        uint minit=block.timestamp-stakedOfTime[token][msg.sender];\n\n        uint coin;\n\n        for(uint i=0;i< users[token][msg.sender].mnu;i++){\n\n            if(stakedOfTimeSum[token][msg.sender][i+1] > minit && stakedOf[token][msg.sender][i+1] >0){\n\n            uint banOf=stakedOf[token][msg.sender][i+1] / 100;\n\n            uint send=getTokenPrice(token1,token,banOf) / RATE_DAY;\n\n              coin+=minit*send;\n\n              stakedOfTimeSum[token][msg.sender][i+1]-=minit;\n\n            }\n\n        }\n\n        bool isok=IERC20(token).transfer(msg.sender,coin*50/100);\n\n        require(isok);\n\n        stakedOfTime[token][msg.sender]=block.timestamp;\n\n        updateU(token,msg.sender,coin*50/100);\n\n    }\n\n```\n\n**Attack tx:** \n\n[https://explorer.phalcon.xyz/tx/bsc/0xfe80df5d689137810df01e83b4bb51409f13c865e37b23059ecc6b3d32347136](https://explorer.phalcon.xyz/tx/bsc/0xfe80df5d689137810df01e83b4bb51409f13c865e37b23059ecc6b3d32347136)\n\n**Analysis:**\n[https://twitter.com/BlockSecTeam/status/1657715018908180480](https://twitter.com/BlockSecTeam/status/1657715018908180480)",
    "images": [],
    "Lost": "unclear",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SELLC02_exp.sol"
  },
  "Bitpaidio": {
    "type": "Business Logic Flaw",
    "date": "2023-05-13",
    "rootCause": "\n\nLock_Token() did not properly update the lock times.\n\n**Vulnerable code snippet:**\n\n```solidity\n\nif(sixMonth[msg.sender].reinvest == 0) {\n\n          uint256 startTime = block.timestamp;\n\n          uint256 endTime = block.timestamp + 180 days;\n\n          sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender,total,startTime,endTime,1);\n\n          }\n\n          else {\n\n              uint256 startTime = sixMonth[msg.sender].start_time;\n\n              uint256 endTime = sixMonth[msg.sender].end_time;\n\n              sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender,total,startTime,endTime,1);\n\n          }\n\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0x1ae499ccf292a2ee5e550702b81a4a7f65cd03af2c604e2d401d52786f459ba6](https://explorer.phalcon.xyz/tx/bsc/0x1ae499ccf292a2ee5e550702b81a4a7f65cd03af2c604e2d401d52786f459ba6)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1657411284076478465](https://twitter.com/BlockSecTeam/status/1657411284076478465)",
    "images": [],
    "Lost": "$30K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Bitpaidio_exp.sol"
  },
  "SellToken02": {
    "type": "Price Manipulation",
    "date": "2023-05-13",
    "rootCause": "\n\nThe flaw in the token price calculation allowed malicious actors to manipulate the price of the token, leading to significant losses for users and potentially creating an opportunity for the attackers to profit unfairly.\n\nKALOS: This type of vulnerability occurs through the ShortStart() function of SellToken.Router, specifically due to an issue with the getToken2Price() function used internally. This function retrieves the token price from PancakeSwap\u2019s Router and utilizes it. The attacker leveraged a flash loan to borrow a significant amount of funds and executed an Inflation Attack using this method.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x57db19127617b77c8abd9420b5a35502b59870d6#code](https://bscscan.com/address/0x57db19127617b77c8abd9420b5a35502b59870d6#code)\n\n```solidity\nfunction ShortStart(address coin,address addr,uint terrace)payable public {\n        address bnbOrUsdt=mkt.getPair(coin);\n        require(terraces[terrace]!=address(0) && tokenPrice[addr][coin] > 0);\n        require(coin != address(0));\n        require(bnbOrUsdt == _WBNB || bnbOrUsdt==_USDT);\n        require(!getNewTokenPrice(addr,coin,bnbOrUsdt) && block.timestamp > tokenPriceTime[addr][coin]);\n        uint bnb=msg.value;\n        uint tos=getToken2Price(coin,bnbOrUsdt,mkt.balanceOf(coin))/10; **//vulnerable point**\n        require(Short[addr][coin].bnb+bnb <= tos);\n        Short[addr][coin].token=bnbOrUsdt;\n        Short[addr][coin].coin=coin;\n        Short[addr][coin].bnb+=bnb*98/100;\n        tokenPrice[addr][coin]=0;\n        uint newTokenValue=getTokenPrice(coin,bnbOrUsdt,bnb*98/100);\n        Short[addr][coin].tokenPrice+=newTokenValue;\n        Short[addr][coin].time=block.timestamp;\n        address[] memory add=mySells[addr].coin;\n        bool isCoin;\n        for(uint i=0;i<add.length;i++){\n             if(add[i]==coin){\n               isCoin=true;\n            }\n        }\n        if(!isCoin){\n           mySells[addr].mnu++;\n           mySells[addr].coin.push(coin);\n        }\n        sum+=bnb;\n        payable(mkt).transfer(bnb*97/100);\n        if(bnbOrUsdt ==_USDT){\n           uint usdts=IERC20(_USDT).balanceOf(address(mkt));\n           mkt.buy(_WBNB,_USDT,bnb*97/100);\n          if(IERC20(_USDT).balanceOf(address(mkt))>usdts){\n             uint ut=IERC20(_USDT).balanceOf(address(mkt))-usdts;\n             mkt.buy(_USDT,coin,ut);\n           }\n        }else{\n            mkt.buy(bnbOrUsdt,coin,bnb*97/100);\n        }\n        payable (owner()).transfer(bnb*2/100);\n        payable (terraces[terrace]).transfer(bnb/100);\n    }\nfunction getToken2Price(address token,address bnbOrUsdt,uint bnb) view public returns(uint){\n        if(token == address(0) || bnbOrUsdt == address(0)) return 0;\n        address isbnb;\n        if(bnbOrUsdt == _WBNB){\n            isbnb=_WBNB;\n            address[] memory routePath = new address[](2);\n            routePath[0] = token;\n            routePath[1] = isbnb;\n            return IRouter(_router).getAmountsOut(bnb,routePath)[1]; **//vulnerable point**\n        }else {\n            isbnb=_USDT;\n            address[] memory routePath = new address[](3);\n            routePath[0] = token;\n            routePath[1] = isbnb;\n            routePath[2] = _WBNB;\n            return IRouter(_router).getAmountsOut(bnb,routePath)[2]; **//vulnerable point**\n        }\n        \n    }\n\n/*\ngetAmountsOut\nGiven an input asset amount and an array of token addresses, \ncalculates all subsequent maximum output token amounts by calling getReserves \nfor each pair of token addresses in the path in turn, and using these to call getAmountOut.\n*/\n```\n\n**Attack tx:**\n\n[https://explorer.phalcon.xyz/tx/bsc/0x7d04e953dad4c880ad72b655a9f56bc5638bf4908213ee9e74360e56fa8d7c6a](https://explorer.phalcon.xyz/tx/bsc/0x7d04e953dad4c880ad72b655a9f56bc5638bf4908213ee9e74360e56fa8d7c6a)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1657324561577435136](https://twitter.com/BlockSecTeam/status/1657324561577435136)\n\n[https://twitter.com/kalos_security/status/1668092971483561985](https://twitter.com/kalos_security/status/1668092971483561985)",
    "images": [],
    "Lost": "$197k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SellToken_exp.sol"
  },
  "SellToken01": {
    "type": "Access Control",
    "date": "2023-05-11",
    "rootCause": "\n\nAncilia: In the StakingRewards contract, the listToken[] can be set  in the addLiquidity() function. However, this operation *should*  be restricted to 'OwnerOnly'. By exploiting this vulnerability, a hacker can add their self-created token to listToken and subsequently call the sell function.\n\n**Attack tx:**\n\n[https://bscscan.com/address/0x274b3e185c9c8f4ddef79cb9a8dc0d94f73a7675#code](https://bscscan.com/address/0x274b3e185c9c8f4ddef79cb9a8dc0d94f73a7675#code)\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction addLiquidity(address _token, address token1, uint amount1) public {  // @audit: pass in fake _token \n        uint lp=IERC20(_token).totalSupply()*90/100;\n        uint miner=IERC20(_token).totalSupply()*10/100;\n        bool isok=IERC20(_token).transferFrom(msg.sender, address(this), IERC20(_token).totalSupply());\n        isok=IERC20(token1).transferFrom(msg.sender, address(this), amount1);\n        require(isok);\n        IERC20(_token).approve(address(address(IRouters)), 2 ** 256 - 1);\n        IRouters.addLiquidity(_token,token1,lp,amount1,0, 0,address(this),block.timestamp+100);\n        address pair=ISwapFactory(IRouters.factory()).getPair(_token,token1);\n        if(pairs(pair).IRouter()==address(0)){\n         pairs(pair).setIRouter(0xBDDFA43dbBfb5120738C922fa0212ef1E4a0850B);\n        }\n        if(myReward[_token]== address(0)){\n          myReward[_token]=token1;\n        }\n        listToken[_token]=true; **//vulnerable point**\n        users[_token][0x2F98Fa813Ced7Aa9Fd6788aB624b2F3F292B9239].tz+= 100 ether;\n  }\n```\n\n**Analysis:**\n\n[https://twitter.com/AnciliaInc/status/1656341587054702598](https://twitter.com/AnciliaInc/status/1656341587054702598)",
    "images": [],
    "Lost": "$95k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SELLC_exp.sol"
  },
  "SNK": {
    "type": "Flashloans, Reward",
    "date": "2023-05-10",
    "rootCause": "\n\nPhalcon: The attacker exploits the `bindParent` function in contract SNKMiner to amplify his staking rewards. Specifically, this function binds one account as a staking account's child.\n\nSNKMiner depends on SNK balance of staking accounts' children to calculate the amount of reward(SNK) distributing to staking accounts. As a result, the attacker leverages flashloan to increase the SNK balance of children, which can further lift their parents' staking rewards.\n\nKALOS: The vulnerability lies in the bindParent() and getReward() functions. The bindParent() function allows setting the parent and child nodes, while the dynamicEarned() function within the getReward() function calculates rewards based on the balances of those child nodes. As a result, it is possible to receive a much larger amount of rewards than what should actually be obtained.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction getReward() public updateReward(msg.sender) checkStart {\n        uint256 reward = dynamicEarned(msg.sender) + privateEarned(msg.sender); **//vulnerable point**\n        if (reward > 0) {\n            prewards[msg.sender] = 0;\n            drewards[msg.sender] = 0;\n\n            token.safeTransfer(msg.sender, reward);\n\n            totalRewards = totalRewards.add(reward);\n        }\n  }\n\nfunction privateEarned(address account) public view returns (uint256) {\n        if (block.timestamp < starttime) {\n            return 0;\n        }\n\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .mul(35)\n                .div(precision)\n                .div(100)\n                .add(prewards[account]);\n }\n\nfunction dynamicEarned(address account) public view returns (uint256) {\n        if (block.timestamp < starttime) {\n            return 0;\n        }\n\n        if (balanceOf(account) < 10e18) {\n            return 0;\n        }\n        \n        return\n            _getMyChildersBalanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .mul(45)\n                .div(precision)\n                .div(100)\n                .add(drewards[account]);\n }\n\nfunction _getMyChildersBalanceOf(address user) private view returns (uint256) {\n        address[] memory childers = inv.getInviterSuns(user);\n\n        uint256 totalBalances;\n        for (uint256 index = 0; index < childers.length; index++) {\n            totalBalances += balanceOf(childers[index]); **//vulnerable point**\n        }\n\n        return totalBalances;\n }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/address/0xA3f5ea945c4970f48E322f1e70F4CC08e70039ee#code](https://bscscan.com/address/0xA3f5ea945c4970f48E322f1e70F4CC08e70039ee#code)\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1656176776425644032](https://twitter.com/Phalcon_xyz/status/1656176776425644032)\n\n[https://twitter.com/kalos_security/status/1668092691262091265](https://twitter.com/kalos_security/status/1668092691262091265)",
    "images": [],
    "Lost": "$197k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SNK_exp.sol"
  },
  "Melo": {
    "type": "Access Control",
    "date": "2023-05-06",
    "rootCause": "\n\npublic mint bug\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction mint(address account, uint256 amount, string memory txId) public returns (bool) { **//vulnerable point**\n\t  _mint(acccount, amount);  ****\n\t  return true;\n}\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x3f1973fe56de5ecd59a815d3b14741cf48385903b0ccfe248f7f10c2765061f7](https://bscscan.com/tx/0x3f1973fe56de5ecd59a815d3b14741cf48385903b0ccfe248f7f10c2765061f7)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1654667621139349505](https://twitter.com/peckshield/status/1654667621139349505)",
    "images": [],
    "Lost": "$90k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Melo_exp.sol"
  },
  "DEI": {
    "type": "Incorrect logic",
    "date": "2023-05-05",
    "rootCause": "\n\nFetch allowance of msg.sender for account instead of reverse.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction burnFrom(address account, uint256 amount) public virtual {\n\tuint256 currentAllowance = _allowances[_msgSender()][account];  // @audit: shoud be _allowances[account][_msgSender()]\n\t_approve(account, _msgSender(), currentAllowance - amount);\n\t_burn(account, amount);\n}\n```\n\n**Attack tx:**\n\n[https://arbiscan.io/tx/0xb1141785b7b94eb37c39c37f0272744c6e79ca1517529fec3f4af59d4c3c37ef](https://arbiscan.io/tx/0xb1141785b7b94eb37c39c37f0272744c6e79ca1517529fec3f4af59d4c3c37ef)\n\n**Analysis:**\n\n[https://twitter.com/eugenioclrc/status/1654576296507088906](https://twitter.com/eugenioclrc/status/1654576296507088906)",
    "images": [],
    "Lost": "$5.4M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DEI_exp.sol"
  },
  "NeverFall": {
    "type": "Sandwich",
    "date": "2023-05-03",
    "rootCause": "\n\nKALOS: The root cause lies in the logic that evaluates the price of the token, which is based on the Pair from PancakeSwap. If you examine the sell() function of the NeverFall contract, you can easily identify the cause.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction buy(uint256 amountU) public returns(uint256){\n        require(startBuy,\"not start\");\n        //\u6536usdt\n        IERC20(usdtAddress).safeTransferFrom(msg.sender,address(this),amountU);\n\n        uint256 beforeLiquidityAmount = balanceOf(address(this));\n        //90%\u52a0\u6c60\u5b50\n        IERC20(usdtAddress).approve(uniswapV2Router,amountU);\n        addLiquidity(initSupply, amountU * buyAddLiqFee / 100);\n        uint256 afterLiquidityAmount = balanceOf(address(this));\n        //5%\u7684usdt\u8d2d\u4e70\n        buySwap(amountU * buySwapFee / 100);\n        super._transfer(address(this), msg.sender, beforeLiquidityAmount - afterLiquidityAmount - balanceOf(pairTempAddress)); \n        super._transfer(pairTempAddress, address(this), balanceOf(pairTempAddress));\n        //\u8425\u9500\n        IERC20(usdtAddress).safeTransfer(marketingAddress,amountU * buyMarketingFee / 100);\n        emit BuyNF(msg.sender,amountU);\n        return beforeLiquidityAmount - afterLiquidityAmount - balanceOf(pairTempAddress);\n    } \n\n    function sell(uint256 amount) public returns(uint256){\n        super._transfer(msg.sender, address(this), amount);\n        //\u64a4\u6c60\u5b50 \u9000\u7ed9\u7528\u6237U\n        uint256 balanceNF = this.balanceOf(uniswapV2Pair);\n        uint256 pairTotalSupply = IERC20(uniswapV2Pair).totalSupply();\n        uint256 needLiquidity = amount * pairTotalSupply / balanceNF; **//vulnerable point**\n        \n        uint256 beforeU = IERC20(usdtAddress).balanceOf(address(this));\n        removeLiquidity(needLiquidity,amount * 90 / 100,0);\n        uint256 afterU = IERC20(usdtAddress).balanceOf(address(this));\n        uint256 outU =  afterU - beforeU;\n\n        IERC20(usdtAddress).safeTransfer(msg.sender, outU * sellFee / 100);\n         //\u8425\u9500\n        IERC20(usdtAddress).safeTransfer(marketingAddress,outU * sellMarketingFee / 100);\n        emit SellNF(msg.sender,amount,outU);\n        return outU * sellFee / 100;  \n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/address/0x5ABDe8B434133C98c36F4B21476791D95D888bF5#contracts](https://bscscan.com/address/0x5ABDe8B434133C98c36F4B21476791D95D888bF5#contracts)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1653619782317662211](https://twitter.com/BeosinAlert/status/1653619782317662211)\n\n[https://twitter.com/kalos_security/status/1668092312906514433](https://twitter.com/kalos_security/status/1668092312906514433)",
    "images": [],
    "Lost": "$74K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NeverFall_exp.sol"
  },
  "Level": {
    "type": "Incorrect logic",
    "date": "2023-05-02",
    "rootCause": "\n\nDue to the lack of checks of repeated items for the array argument of the vulnerable function. \n\n**Vulnerable code snippet:**\n\n```solidity\nfunction claimMultiple(uint256[] calldata _epoches, address _to) external {\n\tuint256 totalReward;\n\tfor (uint256 i; i < _epoches.length; ++i) {\n\t\tuint256 epoch = _epoches[i];\n\t\tif (epoch < currentEpoch) {\n\t\t\tuint256 reward = claimable(epoch, msg.sender);\n\t\t\tusers[epoch][msg.sender].claimed = reward;  **// @audit: vulnerable, should be +=**\n\t\t\ttotalReward += reward;\n\t\t}\n\t}\n\tLVL.safeTransfer(_to, totalReward);\n}\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x6aef8bb501a53e290837d4398b34d5d4d881267512cfe78eb9ba7e59f41dad04](https://bscscan.com/tx/0x6aef8bb501a53e290837d4398b34d5d4d881267512cfe78eb9ba7e59f41dad04)\n\n[https://bscscan.com/tx/0xe1f257041872c075cbe6a1212827bc346df3def6d01a07914e4006ec43027165](https://bscscan.com/tx/0xe1f257041872c075cbe6a1212827bc346df3def6d01a07914e4006ec43027165)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1653149493133729794](https://twitter.com/peckshield/status/1653149493133729794)\n\n[https://twitter.com/BlockSecTeam/status/1653267431127920641](https://twitter.com/BlockSecTeam/status/1653267431127920641)\n\n[https://twitter.com/kalos_security/status/1668092143167213569](https://twitter.com/kalos_security/status/1668092143167213569)",
    "images": [],
    "Lost": "$1M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Level_exp.sol"
  },
  "0vix": {
    "type": "Donate, Oracle",
    "date": "2023-04-28",
    "rootCause": "\n\nIncorrect use balanceOf. \n\n**Vulnerable code snippet:**\n\nvGHSTOracle\n\n```solidity\nfunction totalGHST(address _user) public view returns (uint _totalGHST) {\n\tuint totalGHSTheld = GHST.balanceOf(_user);   **//vulnerable point**\n\t_totalGHST = totalGHSTheld + totalGHSTStaked + totalwapGHSTheld;\n}\n\nfunction convertVGHST(uint _share) public view returns (uint _ghst) {\n\tuint totalTokenLocked = totalGHST(address(this)); **//vulnerable point**\n\t_ghst = _share * totalTokenLocked / totalShares;\n}\n```\n\n**Attack tx:**\n\n[https://polygonscan.com/tx/0x10f2c28f5d6cd8d7b56210b4d5e0cece27e45a30808cd3d3443c05d4275bb008](https://polygonscan.com/tx/0x10f2c28f5d6cd8d7b56210b4d5e0cece27e45a30808cd3d3443c05d4275bb008)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1651932529874853888](https://twitter.com/BlockSecTeam/status/1651932529874853888)\n\n[https://twitter.com/peckshield/status/1651923235603361793](https://twitter.com/peckshield/status/1651923235603361793)\n\n[https://twitter.com/Mudit__Gupta/status/1651958883634536448](https://twitter.com/Mudit__Gupta/status/1651958883634536448)",
    "images": [],
    "Lost": "$2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/0vix_exp.sol"
  },
  "Silo finance": {
    "type": "Donate, Math, Under/Overflow",
    "date": "2023-04-27",
    "rootCause": " \n\ndump utilization ratio by borrowing donated token\n\nFix: bound utilizationRate to be < 100\n\n**Vulnerable code snippet:**\n\n```jsx\n    function calculateCurrentInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) public pure override returns (uint256 rcur) {\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\n\n        // struct for local vars to avoid \"Stack too deep\"\n        LocalVarsRCur memory _l = LocalVarsRCur(0,0,0,0,0,0,false);\n\n        (,,,_l.overflow) = calculateCompoundInterestRateWithOverflowDetection(\n            _c,\n            _totalDeposits,\n            _totalBorrowAmount,\n            _interestRateTimestamp,\n            _blockTimestamp\n        );\n\n        if (_l.overflow) {\n            return 0;\n        }\n\n        // There can't be an underflow in the subtraction because of the previous check\n        unchecked {\n            // T := t1 - t0 # length of time period in seconds\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\n        }\n\n        _l.u = EasyMath.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\n        _l.DP = int256(DP);\n\n        if (_l.u > _c.ucrit) {\n            // rp := kcrit *(1 + Tcrit + beta *T)*( u0 - ucrit )\n            _l.rp = _c.kcrit * (_l.DP + _c.Tcrit + _c.beta * _l.T) / _l.DP * (_l.u - _c.ucrit) / _l.DP;\n        } else {\n            // rp := min (0, klow * (u0 - ulow ))\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _l.DP);\n        }\n\n        // rlin := klin * u0 # lower bound between t0 and t1\n        _l.rlin = _c.klin * _l.u / _l.DP;\n        // ri := max(ri , rlin )\n        _l.ri = _max(_c.ri, _l.rlin);\n        // ri := max(ri + ki * (u0 - uopt ) * T, rlin )\n        _l.ri = _max(_l.ri + _c.ki * (_l.u - _c.uopt) * _l.T / _l.DP, _l.rlin);\n        // rcur := max (ri + rp , rlin ) # current per second interest rate\n        rcur = (_max(_l.ri + _l.rp, _l.rlin)).toUint256();\n        rcur *= 365 days;\n    }\n```\n\n**Attack tx:**\n\n[https://github.com/silo-finance/silo-core-v1/blob/master/contracts/InterestRateModel.sol#L134](https://github.com/silo-finance/silo-core-v1/blob/master/contracts/InterestRateModel.sol#L134)\n\n**Analysis:**\n\n[https://medium.com/immunefi/silo-finance-logic-error-bugfix-review-35de29bd934a](https://medium.com/immunefi/silo-finance-logic-error-bugfix-review-35de29bd934a)",
    "images": [],
    "Lost": "-",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/silo_finance.t.sol"
  },
  "Axioma": {
    "type": "Arbitrage",
    "date": "2023-04-24",
    "rootCause": "\n\nPresale is cheaper than PancakeSwap\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x2C25aEe99ED08A61e7407A5674BC2d1A72B5D8E3#code](https://bscscan.com/address/0x2C25aEe99ED08A61e7407A5674BC2d1A72B5D8E3#code)\n\n```solidity\nfunction buyToken() public payable {\n      uint256 bnbAmountToBuy = msg.value;\n\n      uint256 tokenAmount = bnbAmountToBuy.mul(rate).div(10**9);\n\n      require(token.balanceOf(address(this)) >= tokenAmount, \"INSUFFICIENT_BALANCE_IN_CONTRACT\");\n\n      payable(PresaleOwner).transfer(bnbAmountToBuy);\n\n      uint256 taxAmount = tokenAmount.mul(buyTax).div(100);\n      token.transfer(PresaleOwner, taxAmount);\n\n      (bool sent) = token.transfer(msg.sender, tokenAmount.sub(taxAmount));\n      require(sent, \"FAILED_TO_TRANSFER_TOKENS_TO_BUYER\");\n}\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x05eabbb665a5b99490510d0b3f93565f394914294ab4d609895e525b43ff16f2](https://bscscan.com/tx/0x05eabbb665a5b99490510d0b3f93565f394914294ab4d609895e525b43ff16f2)\n\n**Analysis:**\n\n[https://twitter.com/HypernativeLabs/status/1650382589847302145](https://twitter.com/HypernativeLabs/status/1650382589847302145)",
    "images": [],
    "Lost": "21 WBNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Axioma_exp.sol"
  },
  "OLIFE": {
    "type": "Deflationary token",
    "date": "2023-04-19",
    "rootCause": "\n\nThe attacker called the `transfer()` and `deliver()` functions to reduce the number of rSupply and tSupply.\nThe value of rate is thus calculated less, increasing the number of reflected tokens in the pair,  Finally directly call swap to withdraw $WBNB from the pair.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0xb5a0Ce3Acd6eC557d39aFDcbC93B07a1e1a9e3fa#code](https://bscscan.com/address/0xb5a0Ce3Acd6eC557d39aFDcbC93B07a1e1a9e3fa#code)\n\n```solidity\nfunction deliver(uint256 tAmount) public {\n    address sender = _msgSender();\n    require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n    (uint256 rAmount,,,,,,) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rTotal = _rTotal.sub(rAmount);\n    _tFeeTotal = _tFeeTotal.add(tAmount);\n}\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xa21692ffb561767a74a4cbd1b78ad48151d710efab723b1efa5f1e0147caab0a](https://bscscan.com/tx/0xa21692ffb561767a74a4cbd1b78ad48151d710efab723b1efa5f1e0147caab0a)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1648520494516420608](https://twitter.com/BeosinAlert/status/1648520494516420608)",
    "images": [],
    "Lost": "32 WBNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/OLIFE_exp.sol"
  },
  "Swapos V2": {
    "type": "Math",
    "date": "2023-04-16",
    "rootCause": "\n\nIncorrect K check\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(3)); \n        uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');  **// @audit: should be 10_000 as above**\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/address/0x2df07c054138bf29348f35a12a22550230bd1405](https://etherscan.io/address/0x2df07c054138bf29348f35a12a22550230bd1405)\n\n**Analysis:**\n\n[https://twitter.com/CertiKAlert/status/1647530789947469825](https://twitter.com/CertiKAlert/status/1647530789947469825)\n\n[https://twitter.com/BeosinAlert/status/1647552192243728385](https://twitter.com/BeosinAlert/status/1647552192243728385)",
    "images": [],
    "Lost": "$468k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Swapos_exp.sol"
  },
  "HundredFinance": {
    "type": "Donate, Math, Under/Overflow",
    "date": "2023-04-15",
    "rootCause": "\n\ncToken.redeem() is rounded down - first deposit bug\n\n**Vulnerable code snippet:**\n\n[https://optimistic.etherscan.io/address/0x7100cbca885905f922a19006cf7fd5d0e1bbb26c#code#F8#L123](https://optimistic.etherscan.io/address/0x7100cbca885905f922a19006cf7fd5d0e1bbb26c#code#F8#L123)\n\n```solidity\nfunction redeemFresh(address redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\t...\n\telse\n\t\t(vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp(vars.exchangeRateMantissa));  // rounded down from 1.9999 -> 1 (should be rounded up to 2)\n\n\tuint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens)\n}\n```\n\n**Attack tx:**\n\n[https://optimistic.etherscan.io/tx/0x6e9ebcdebbabda04fa9f2e3bc21ea8b2e4fb4bf4f4670cb8483e2f0b2604f451](https://optimistic.etherscan.io/tx/0x6e9ebcdebbabda04fa9f2e3bc21ea8b2e4fb4bf4f4670cb8483e2f0b2604f451)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1647307128267476992](https://twitter.com/peckshield/status/1647307128267476992)\n\n[https://twitter.com/danielvf/status/1647329491788677121](https://twitter.com/danielvf/status/1647329491788677121)\n\n[https://twitter.com/hexagate_/status/1647334970258608131](https://twitter.com/hexagate_/status/1647334970258608131)\n\n[https://blog.hundred.finance/15-04-23-hundred-finance-hack-post-mortem-d895b618cf33](https://blog.hundred.finance/15-04-23-hundred-finance-hack-post-mortem-d895b618cf33)",
    "images": [],
    "Lost": "$7M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/HundredFinance_2_exp.sol"
  },
  "yearnFinance": {
    "type": "Misconfiguration",
    "date": "2023-04-13",
    "rootCause": "\n\nSet bZxUSDC address instead of bZxUSDT\n\nSam: It seems like the iearn USDT token (yUSDT) has been broken since deploy, which was *checks notes* over 1000 days ago. It was misconfigured to use the Fulcrum iUSDC token instead of the Fulcrum iUSDT token.\n\n**Vulnerable code snippet:**\n\n```solidity\nconstructor() public ERC20Detailed(\"iearn USDT\", \"yUSDT\", 6) {\n\tfulcrum = address(0xF013406A0B1d544238083DF0B93ad0d2cBE0f65f);  // misconfigured\n}\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x055cec4fa4614836e54ea2e5cd3d14247ff3d61b85aa2a41f8cc876d131e0328](https://etherscan.io/tx/0x055cec4fa4614836e54ea2e5cd3d14247ff3d61b85aa2a41f8cc876d131e0328)\n\n[https://etherscan.io/tx/0xd55e43c1602b28d4fd4667ee445d570c8f298f5401cf04e62ec329759ecda95d](https://etherscan.io/tx/0xd55e43c1602b28d4fd4667ee445d570c8f298f5401cf04e62ec329759ecda95d)\n\n**Analysis:**\n\n[https://twitter.com/cmichelio/status/1646422861219807233](https://twitter.com/cmichelio/status/1646422861219807233)\n\n[https://twitter.com/BeosinAlert/status/1646481687445114881](https://twitter.com/BeosinAlert/status/1646481687445114881)",
    "images": [],
    "Lost": "$11.6M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/YearnFinance_exp.sol"
  },
  "MetaPoint": {
    "type": "Access Control",
    "date": "2023-04-12",
    "rootCause": "\n\nPublic approve()\n\nThis contract has a function called `approve` that grants the caller of the function access to the $META tokens without any restriction.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction approve() public payable { \n    v0, /* bool */ v1 = address(0x3b5e381130673f794a5cf67fbba48688386bea86).approve(msg.sender, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == bool(v1));\n}\n```\n\n**Attack tx:**\n\ninvest\n[https://bscscan.com/tx/0xdb01fa33bf5b79a3976ed149913ba0a18ddd444a072a2f34a0042bf32e4e7995](https://bscscan.com/tx/0xdb01fa33bf5b79a3976ed149913ba0a18ddd444a072a2f34a0042bf32e4e7995)\nwithdraw\n\n[https://bscscan.com/tx/0x41853747231dcf01017cf419e6e4aa86757e59479964bafdce0921d3e616cc67](https://bscscan.com/tx/0x41853747231dcf01017cf419e6e4aa86757e59479964bafdce0921d3e616cc67)\n\n**Analysis:**\n\n[https://twitter.com/PeckShieldAlert/status/1645980197987192833](https://twitter.com/PeckShieldAlert/status/1645980197987192833)\n\n[https://twitter.com/Phalcon_xyz/status/1645963327502204929](https://twitter.com/Phalcon_xyz/status/1645963327502204929)",
    "images": [],
    "Lost": "$820k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MetaPoint_exp.sol"
  },
  "Sentiment": {
    "type": "Reentrancy",
    "date": "2023-04-05",
    "rootCause": " \n\nAttacker re enter Balancer Vaults execute malicious code before pool balances were updated and steal money using overpriced collateral. the\u00a0`_joinOrExit`\u00a0function is called whenever the\u00a0`joinPool`\u00a0or\u00a0`exitPool`\u00a0is called by an external protocol user.\n\n**Vulnerable code snippet:**\n\n```solidity\n\nfunction joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable override whenNotPaused {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n\n        // Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both\n        // joins and exits at once.\n        _joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanceChange(request)); **//vulnerable point**\n    }\n...\n\nfunction _joinOrExit(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        PoolBalanceChange memory change\n    ) private nonReentrant withRegisteredPool(poolId) authenticateFor(sender) {  **//vulnerable point**\n        // This function uses a large number of stack variables (poolId, sender and recipient, balances, amounts, fees,\n        // etc.), which leads to 'stack too deep' issues. It relies on private functions with seemingly arbitrary\n        // interfaces to work around this limitation.\n\n        InputHelpers.ensureInputLengthMatch(change.assets.length, change.limits.length);\n\n        // We first check that the caller passed the Pool's registered tokens in the correct order, and retrieve the\n        // current balance for each.\n        IERC20[] memory tokens = _translateToIERC20(change.assets);\n        bytes32[] memory balances = _validateTokensAndGetBalances(poolId, tokens);\n...\n```\n\n**Attack tx:**\n\n[https://arbiscan.io/tx/0xa9ff2b587e2741575daf893864710a5cbb44bb64ccdc487a100fa20741e0f74d](https://arbiscan.io/tx/0xa9ff2b587e2741575daf893864710a5cbb44bb64ccdc487a100fa20741e0f74d)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1643417467879059456](https://twitter.com/peckshield/status/1643417467879059456)\n[https://twitter.com/spreekaway/status/1643313471180644360](https://twitter.com/spreekaway/status/1643313471180644360)\n[https://medium.com/coinmonks/theoretical-practical-balancer-and-read-only-reentrancy-part-1-d6a21792066c](https://medium.com/coinmonks/theoretical-practical-balancer-and-read-only-reentrancy-part-1-d6a21792066c)\n[https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345](https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345)",
    "images": [],
    "Lost": "$1M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sentiment_exp.sol"
  },
  "Allbridge": {
    "type": "Business Logic Flaw, Flashloans, Price Manipulation",
    "date": "2023-04-02",
    "rootCause": "\n\nQuillAudits: The root cause of the issue was a logic flaw in the withdraw function. This flaw allowed for manipulation of the swap price of the pool. The exploiter acted as a liquidity provider and swapper, enabling them to manipulate the price and drain the funds from the pool.\n\n**Vulnerable code snippet:**\n\n```jsx\n// Subtract X and Y for that amount, calculate current price and withdraw the token to the user according to the price\n    function withdraw(uint256 amountLp) external {\n        uint256 totalLpAmount_ = totalLpAmount; // Gas optimization\n\n        _withdrawLp(msg.sender, amountLp);\n\n        // Calculate actual and virtual tokens using burned LP amount share\n        // Swap the difference, get total amount to transfer/burn\n        uint256 amountSP = _preWithdrawSwap(\n            tokenBalance * amountLp / totalLpAmount_, \n            vUsdBalance * amountLp / totalLpAmount_\n        );\n\n        // Always equal amounts removed from actual and virtual tokens\n        tokenBalance -= amountSP;\n        vUsdBalance -= amountSP;\n        \n        // Update D and transfer tokens to the sender\n        _updateD();\n        token.safeTransfer(msg.sender, fromSystemPrecision(amountSP));\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x7ff1364c3b3b296b411965339ed956da5d17058f3164425ce800d64f1aef8210](https://bscscan.com/tx/0x7ff1364c3b3b296b411965339ed956da5d17058f3164425ce800d64f1aef8210)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1642356701100916736](https://twitter.com/peckshield/status/1642356701100916736)\n\n[https://twitter.com/BeosinAlert/status/1642372700726505473](https://twitter.com/BeosinAlert/status/1642372700726505473)\n\n[https://medium.com/coinmonks/decoding-allbridge-570k-flash-loan-exploit-quillaudits-8da8dccd729d](https://medium.com/coinmonks/decoding-allbridge-570k-flash-loan-exploit-quillaudits-8da8dccd729d)",
    "images": [],
    "Lost": "$550k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Allbridge_exp.sol"
  },
  "SafeMoon Hack": {
    "type": "Access Control",
    "date": "2023-03-28",
    "rootCause": "\n\nThe root cause of the attack was that during an upgrade of the Safe Moon contract, an access control vulnerability was introduced in the Public burn function. This vulnerability allowed an attacker to burn tokens from any address. Vulnerable code can be found\u00a0[here](https://bscscan.com/address/0xeb11a0a0bef1ac028b8c2d4cd64138dd5938ca7a#code%23L1737).\n\nVulnerable code snippet:\n\n```solidity\nfunction burn(address from, uint256 amount) public {   **// Vulnerable Point: Public Burn function Without proper Access Control**\n        _tokenTransfer(from, bridgeBurnAddress, amount, 0, false);\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x48e52a12cb297354a2a1c54cbc897cf3772328e7e71f51c9889bb8c5e533a934](https://bscscan.com/tx/0x48e52a12cb297354a2a1c54cbc897cf3772328e7e71f51c9889bb8c5e533a934)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1640855857910149122](https://twitter.com/peckshield/status/1640855857910149122)\n\n[https://www.zellic.io/blog/safemoon-exploit-explained](https://www.zellic.io/blog/safemoon-exploit-explained)\n\n[https://medium.com/coinmonks/decoding-safemoon-protocols-8-9-million-exploit-quillaudits-a5b11417f0b9](https://medium.com/coinmonks/decoding-safemoon-protocols-8-9-million-exploit-quillaudits-a5b11417f0b9)",
    "images": [],
    "Lost": "$8.9M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/safeMoon_exp.sol"
  },
  "DBW": {
    "type": "Business Logic Flaw, Flashloans, Insufficient validation, Misconfiguration",
    "date": "2023-03-25",
    "rootCause": "\n\nThe root cause is that the dividend awards are based on the percentage of LP currently owned by the user,\nand does not take into account multiple dividends after the transfer of LP.\n\n**Vulnerable code snippet:**\n\nclaim reward \n\n```solidity\nfunction getStaticIncome() public {\n        if(!hasRole(VIP_ROLE, msg.sender)&&!_is_static_dynamic){\n            _staticIncome_(msg.sender); **//vulnerable point**\n        }\n    }\n```\n\n```solidity\nfunction pledge_lp (uint256 count) public{\n        require(!Address.isContract(msg.sender),\"the address is contract\");\n        require(count > 0,\"count > 0\");\n        uint256 _spend =IERC20(_lp).allowance(msg.sender,address(this));\n        require(_spend>=count,\"lp must be authorized first\");\n        uint256 _lpBalance =IERC20(_lp).balanceOf(msg.sender);\n        require(_lpBalance>=count,\"lp Insufficient balance\");\n        bool _isTransfer =IERC20(_lp).transferFrom(msg.sender,address(this),count);\n        require(_isTransfer,\"lp transfer err\");\n        _balances_lp[msg.sender]+=count;\n        _user_convertLPToDBW[msg.sender]=convertLPToDBW(_balances_lp[msg.sender]);\n        ff_handling_fee_user[msg.sender]=_handling_fee;\n        \n        if(!isHaveLPuser(msg.sender)){\n            lpUserCount++;\n            lpUsers.push(msg.sender);\n        }\n    }\n```\n\nredeem LP\n\n```solidity\nfunction redemption_lp (uint256 count) public{\n        require(!Address.isContract(msg.sender),\"the address is contract\");\n        require(count > 0,\"count > 0\");\n        require(_balances_lp[msg.sender] >= count,\"_balances_lp[msg.sender] >= count\");\n        \n        bool _isTransfer = IERC20(_lp).transfer(msg.sender, count);\n        require(_isTransfer,\"not lp Transfer\");\n        _balances_lp[msg.sender]-=count;\n        _user_convertLPToDBW[msg.sender]=convertLPToDBW(_balances_lp[msg.sender]);\n\n        uint256 ff_count = getFFCount();\n        if(ff_count>0){\n            _transfer(address(this),msg.sender,ff_count);\n            //_user_dbw_lp[msg.sender]+=ff_count;\n            ff_handling_fee_user[msg.sender]=_handling_fee;\n        }\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x3b472f87431a52082bae7d8524b4e0af3cf930a105646259e1249f2218525607](https://bscscan.com/tx/0x3b472f87431a52082bae7d8524b4e0af3cf930a105646259e1249f2218525607)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1639655134232969216](https://twitter.com/BeosinAlert/status/1639655134232969216)\n\n[https://twitter.com/AnciliaInc/status/1639289686937210880](https://twitter.com/AnciliaInc/status/1639289686937210880)",
    "images": [],
    "Lost": "$24k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DBW_exp.sol"
  },
  "BIGFI": {
    "type": "Access Control, Flashloans",
    "date": "2023-03-22",
    "rootCause": "\n\nPublic burn() without to proper access control \n\n**Vulnerable code snippet:**\n\n```solidity\nfunction burn(uint256 _value) public { **// Vulnerable Point: Public Burn function Without proper Access Control**\n        _burn(msg.sender, _value);\n    }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x9fe19093a62a7037d04617b3ac4fbf5cb2d75d8cb6057e7e1b3c75cbbd5a5adc](https://bscscan.com/tx/0x9fe19093a62a7037d04617b3ac4fbf5cb2d75d8cb6057e7e1b3c75cbbd5a5adc)\n\n**Analysis:**\n\n[https://twitter.com/HypernativeLabs/status/1638522680654675970](https://twitter.com/HypernativeLabs/status/1638522680654675970)",
    "images": [],
    "Lost": "$30k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BIGFI_exp.sol"
  },
  "ParaSpace NFT": {
    "type": "Access Control, Business Logic Flaw",
    "date": "2023-03-17",
    "rootCause": "\n\nThere is a flawed logic in borrow() of the ParaProxy contract (0x638a98BBB92a7582d07C52ff407D49664DC8b3Ee\n) of  ParaSpace NFT\n\n. The attacker can borrow more tokens as his scaledBalance will be enlarged by depositing into the position of the proxy (0xC5c9fB6223A989208Df27dCEE33fC59ff5c26fFF), i.e., specifying the _recipient of depositApeCoin().\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction depositApeCoin(uint256 _amount, address _recipient) public { **//vulnerable point** _recipient\n        if (_amount < MIN_DEPOSIT) revert DepositMoreThanOneAPE();\n        updatePool(APECOIN_POOL_ID);\n\n        Position storage position = addressPosition[_recipient]; **//vulnerable point**\n        _deposit(APECOIN_POOL_ID, position, _amount);\n\n        apeCoin.transferFrom(msg.sender, address(this), _amount);\n\n        emit Deposit(msg.sender, _amount, _recipient);\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xe3f0d14cfb6076cabdc9057001c3fafe28767a192e88005bc37bd7d385a1116a](https://etherscan.io/tx/0xe3f0d14cfb6076cabdc9057001c3fafe28767a192e88005bc37bd7d385a1116a)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1636650252844294144](https://twitter.com/BlockSecTeam/status/1636650252844294144)",
    "images": [],
    "Lost": "2,909 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Paraspace_exp_2.sol"
  },
  "Poolz": {
    "type": "Under/Overflow",
    "date": "2023-03-15",
    "rootCause": "\n\nThe attacker called the vulnerable function \u2018CreateMassPools\u2019 and triggered an integer overflow vulnerability in the parameter _StartAmount.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction CreateMassPools(\n        address _Token,\n        uint64[] calldata _FinishTime,\n        uint256[] calldata _StartAmount,\n        address[] calldata _Owner\n    ) external isGreaterThanZero(_Owner.length) isBelowLimit(_Owner.length) returns(uint256, uint256) {\n        require(_Owner.length == _FinishTime.length, \"Date Array Invalid\");\n        require(_Owner.length == _StartAmount.length, \"Amount Array Invalid\");\n        TransferInToken(_Token, msg.sender, getArraySum(_StartAmount)); **//vulnerable point**\n        uint256 firstPoolId = Index;\n        for(uint i=0 ; i < _Owner.length; i++){\n            CreatePool(_Token, _FinishTime[i], _StartAmount[i], _Owner[i]);\n        }\n        uint256 lastPoolId = SafeMath.sub(Index, 1);\n        return (firstPoolId, lastPoolId);\n    }\n```\n\n**Attack tx:**\n\nAll TX within this contract : [https://bscscan.com/address/0x058bae36467a9fc5e1045dbdffc2fd65b91c2203](https://bscscan.com/address/0x058bae36467a9fc5e1045dbdffc2fd65b91c2203)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1635878098452492288](https://twitter.com/BeosinAlert/status/1635878098452492288)",
    "images": [],
    "Lost": "$390K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/poolz_exp.sol"
  },
  "EulerFinance": {
    "type": "Business Logic Flaw, Flashloans",
    "date": "2023-03-13",
    "rootCause": "\n\nThe primary problem here with Euler was its \u201cdonateToReserves\u201d function. which allows the user to transfer tokens from their own balance to a protocol variable called \u201cassetStorage.reserveBalance.\u201d.This function allowed the attacker to\u00a0[donate](https://medium.com/@omniscia.io/euler-finance-incident-post-mortem-1ce077c28454)\u00a0their eDAI to Euler reserves, removing assets from their wallet without removing a corresponding amount of debt. Here borrower minted 195 million e-DAI and 200 million d-DAI tokens. A logical error in the `donateToReserve()` method resulted in the burning of e-DAI tokens but not d-DAI tokens, leading to unbacked \u201cd-DAI\u201d token debt that will never be repaid.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction donateToReserves(uint subAccountId, uint amount) external nonReentrant {\n        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();\n        address account = getSubAccount(msgSender, subAccountId);\n\n        updateAverageLiquidity(account);\n        emit RequestDonate(account, amount);\n\n        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);\n\n        uint origBalance = assetStorage.users[account].balance;\n        uint newBalance;\n\n        if (amount == type(uint).max) {\n            amount = origBalance;\n            newBalance = 0;\n        } else {\n            require(origBalance >= amount, \"e/insufficient-balance\");\n            unchecked { newBalance = origBalance - amount; }\n        }\n\n        assetStorage.users[account].balance = encodeAmount(newBalance);\n        assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(assetCache.reserveBalance + amount);\n\n        emit Withdraw(assetCache.underlying, account, amount);\n        emitViaProxy_Transfer(proxyAddr, account, address(0), amount);\n\n        logAssetStatus(assetCache);\n    }\n```\n\n**Summary:** \n1) Flash loan tokens from Balancer/Aave v2 => 30M DAI\n2) Deploy two contracts: violator and liquidator\n3) Deposit 2/3 of funds to Euler using deposit() => sent 20M DAI to Euler and received 19.5M eDAI from Euler\n4) Borrow 10x of deposited amount using mint() => received 195.6M eDAI and 200M dDAI from Euler\n5) Repay part of debt using the remaining 1/3 of funds using repay() => sent 10M DAI and burned 10M dDAI\n6) Repeat 4th step => received 195.6M eDAI and 200M dDAI from Euler\n7) Donate 10x of repaid funds using donateToReserves() => sent 100M eDAI to Euler\n 8)  Liquidate a violator\u2019s account using liquidate() because eDAI < dDAI => received 310M eDAI and 259M dDAI of debt from the violator\n9) Withdraw all token amount from Euler using withdraw() => withdrew 38.9M DAI from Euler\n10) Repay flash loans\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xc310a0affe2169d1f6feec1c63dbc7f7c62a887fa48795d327d4d2da2d6b111d](https://etherscan.io/tx/0xc310a0affe2169d1f6feec1c63dbc7f7c62a887fa48795d327d4d2da2d6b111d)\n\n**Analysis:**\n\n[https://twitter.com/FrankResearcher/status/1635241475989721089](https://twitter.com/FrankResearcher/status/1635241475989721089)\n\n[https://twitter.com/nomorebear/status/1635230621856600064](https://twitter.com/nomorebear/status/1635230621856600064)\n\n[https://twitter.com/peckshield/status/1635229594596036608](https://twitter.com/peckshield/status/1635229594596036608)\n\n[https://twitter.com/BlockSecTeam/status/1635262150624305153](https://twitter.com/BlockSecTeam/status/1635262150624305153)\n\n[https://twitter.com/SlowMist_Team/status/1635288963580825606](https://twitter.com/SlowMist_Team/status/1635288963580825606)\n\n[https://euler-xyz.github.io/euler-contracts-upgrade-diffs/eip14/EToken.html](https://euler-xyz.github.io/euler-contracts-upgrade-diffs/eip14/EToken.html)",
    "images": [],
    "Lost": "$200M(returned)",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Euler_exp.sol"
  },
  "DKP": {
    "type": "Flashloans, Price Manipulation",
    "date": "2023-03-08",
    "rootCause": "\n\nQuillAudits: The contract was not verified. So, after decompiling it, we found that the vulnerability was present in the exchange() function, which was used to swap USDT for DKP tokens. The problem arises because the price Oracle relies on the balance ratio of the two tokens in the USDT-DKP pair, making it vulnerable to flash loan attacks that allow the attacker to manipulate the pool.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x89257A52Ad585Aacb1137fCc8abbD03a963B9683#code](https://bscscan.com/address/0x89257A52Ad585Aacb1137fCc8abbD03a963B9683#code)\n\n[https://library.dedaub.com/decompile?md5=0795fc50f96b806a37007ea095b360de](https://library.dedaub.com/decompile?md5=0795fc50f96b806a37007ea095b360de)\n\n\n\n```jsx\nfunction 0x1201() private { \n    require(stor_3_0_19.code.size);\n    v0, v1 = stor_3_0_19.balanceOf(_lp).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x2a44(v1);\n    require(_usdt.code.size);\n    v2, v3 = _usdt.balanceOf(_lp).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x2a44(v3);\n    v4 = 0x1af2(0xde0b6b3a7640000, v1);\n    v5 = 0x1b6d(v3, v4);\n    return v5;\n}\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x0c850f54c1b497c077109b3d2ef13c042bb70f7f697201bcf2a4d0cb95e74271](https://bscscan.com/tx/0x0c850f54c1b497c077109b3d2ef13c042bb70f7f697201bcf2a4d0cb95e74271)\n\n[https://bscscan.com/tx/0x2d31e45dce58572a99c51357164dc5283ff0c02d609250df1e6f4248bd62ee01](https://bscscan.com/tx/0x2d31e45dce58572a99c51357164dc5283ff0c02d609250df1e6f4248bd62ee01)\n\n**Analysis:**\n\n[https://twitter.com/CertiKAlert/status/1633421908996763648](https://twitter.com/CertiKAlert/status/1633421908996763648)\n\n[https://blog.solidityscan.com/dkp-hack-analysis-improper-token-pair-ratio-calculation-282672cd0450](https://blog.solidityscan.com/dkp-hack-analysis-improper-token-pair-ratio-calculation-282672cd0450)\n\n[https://medium.com/coinmonks/decoding-dkp-token-s-80k-exploit-quillaudits-45c67df973d6](https://medium.com/coinmonks/decoding-dkp-token-s-80k-exploit-quillaudits-45c67df973d6)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$80K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DKP_exp.sol"
  },
  "Phoenix": {
    "type": "Access Control, Flashloans",
    "date": "2023-03-07",
    "rootCause": "\n\nPhxProxy contract delegateCallSwap() function lack of access control and can be passed in any parameter\n\n// The lost money is mainly USDC in the d028 contract which the attacker converts into WETH in the 65ba contract through the buyLeverage() function\n\nand then swaps it into his own tokens by the delegateCallSwap() function, making a profit from it\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction delegateCallSwap(bytes memory data) public returns (bytes memory) { //vulnerable point Access control\n        (bool success, bytes memory returnData) = phxSwapLib.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n        return returnData;\n    }\n```\n\n**Attack tx:**\n\n[https://polygonscan.com/tx/0x6fa6374d43df083679cdab97149af8207cda2471620a06d3f28b115136b8e2c4](https://polygonscan.com/tx/0x6fa6374d43df083679cdab97149af8207cda2471620a06d3f28b115136b8e2c4)\n\n**Analysis:**\n\n[https://twitter.com/HypernativeLabs/status/1633090456157401088](https://twitter.com/HypernativeLabs/status/1633090456157401088)",
    "images": [],
    "Lost": "$100k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Phoenix_exp.sol"
  },
  "LaunchZone": {
    "type": "Access Control, Price Manipulation",
    "date": "2023-02-27",
    "rootCause": "\n\ndetermined that Contract X mentioned above is the implementation \ncontract of SwapX Proxy (not yet verified and audited), the Proxy will \nallow users to pass data and call the implementation contract: [**https://bscscan.com/address/0x0ccee62efec983f3ec4bad3247153009fb483551](https://bscscan.com/address/0x0ccee62efec983f3ec4bad3247153009fb483551)** \n\n**Vulnerable code snippet:**\n\n```solidity\nfunction swap(\n        IERC20 srcToken,\n        IERC20 dstToken,\n        address dstReceiver,\n        uint256 amount,\n        uint256 minReturnAmount,\n        address referrer,\n        bytes calldata data\n    ) \n        external \n        payable \n        whenNotPaused\n        returns (uint256 returnAmount)\n    {\n        require(minReturnAmount > 0, \"Min return should not be 0\");\n        require(data.length > 0, \"Call data should exist\");\n\n        dstReceiver = (dstReceiver == address(0)) ? msg.sender : dstReceiver;\n        uint256 initialSrcBalance = srcToken.universalBalanceOf(msg.sender);\n        uint256 initialDstBalance = dstToken.universalBalanceOf(dstReceiver);\n\n        {\n        (bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data); //vulnerable point\n        if (!success)  {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"swap failed\");\n            }\n        }\n        }\n```\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0xaee8ef10ac816834cd7026ec34f35bdde568191fe2fa67724fcf2739e48c3cae](https://bscscan.com/tx/0xaee8ef10ac816834cd7026ec34f35bdde568191fe2fa67724fcf2739e48c3cae) \n\n**Analysis:** \n\n[https://blog.verichains.io/p/analyzing-the-lz-token-hack](https://blog.verichains.io/p/analyzing-the-lz-token-hack) \n\n[https://twitter.com/immunefi/status/1630210901360951296](https://twitter.com/immunefi/status/1630210901360951296)",
    "images": [],
    "Lost": "$320,000",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LaunchZone_exp.sol"
  },
  "swapX": {
    "type": "Access Control, Price Manipulation",
    "date": "2023-02-27",
    "rootCause": "\n\ndetermined that Contract X mentioned above is the implementation \ncontract of SwapX Proxy (not yet verified and audited), the Proxy will \nallow users to pass data and call the implementation contract: [**https://bscscan.com/address/0x0ccee62efec983f3ec4bad3247153009fb483551](https://bscscan.com/address/0x0ccee62efec983f3ec4bad3247153009fb483551)** \n\n**Vulnerable code snippet:**\n\n```solidity\nfunction swap(\n        IERC20 srcToken,\n        IERC20 dstToken,\n        address dstReceiver,\n        uint256 amount,\n        uint256 minReturnAmount,\n        address referrer,\n        bytes calldata data\n    ) \n        external \n        payable \n        whenNotPaused\n        returns (uint256 returnAmount)\n    {\n        require(minReturnAmount > 0, \"Min return should not be 0\");\n        require(data.length > 0, \"Call data should exist\");\n\n        dstReceiver = (dstReceiver == address(0)) ? msg.sender : dstReceiver;\n        uint256 initialSrcBalance = srcToken.universalBalanceOf(msg.sender);\n        uint256 initialDstBalance = dstToken.universalBalanceOf(dstReceiver);\n\n        {\n        (bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data); //vulnerable point\n        if (!success)  {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"swap failed\");\n            }\n        }\n        }\n```\n\n```solidity\n\n    function swap(\n        IERC20 srcToken,\n        IERC20 dstToken,\n        address dstReceiver,\n        uint256 amount,\n        uint256 minReturnAmount,\n        address referrer,\n        bytes calldata data\n    ) \n        external \n        payable \n        whenNotPaused\n        returns (uint256 returnAmount)\n    {\n        require(minReturnAmount > 0, \"Min return should not be 0\");\n        require(data.length > 0, \"Call data should exist\");\n\n        dstReceiver = (dstReceiver == address(0)) ? msg.sender : dstReceiver;\n        uint256 initialSrcBalance = srcToken.universalBalanceOf(msg.sender);\n        uint256 initialDstBalance = dstToken.universalBalanceOf(dstReceiver);\n\n        {\n        (bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data); **//vulnerable point**\n        if (!success)  {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"swap failed\");\n            }\n        }\n        }\n```\n\n**Attack tx:** \n\n[https://bscscan.com/tx/0x3ee23c1585474eaa4f976313cafbc09461abb781d263547c8397788c68a00160](https://bscscan.com/tx/0x3ee23c1585474eaa4f976313cafbc09461abb781d263547c8397788c68a00160)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1630111965942018049](https://twitter.com/BlockSecTeam/status/1630111965942018049)\n[https://twitter.com/peckshield/status/1630100506319413250](https://twitter.com/peckshield/status/1630100506319413250)",
    "images": [],
    "Lost": "$1M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SwapX_exp.sol"
  },
  "EFVault": {
    "type": "Miscalculation, Storage collision, Upgradable",
    "date": "2023-02-24",
    "rootCause": " \n\nBad contract upgrades cause storage collision\n\n**Details:**\n\n\n\nThe upgrade introduced new storage items, and modifications were made to the existing storage structure. The original storage order of variables was not maintained. \n\nThe data storage structure of the old version was not taken into account, so when reading the `assetDecimal` variable in the new implementation contract, the data read is still the proxy contract slot, which is the value of the `maxDeposit` variable of the old version.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x80cb73074a6965f60df59bf8fa3ce398ffa2702c#code#F1#L145](https://etherscan.io/address/0x80cb73074a6965f60df59bf8fa3ce398ffa2702c#code#F1#L145)\n\n```solidity\nfunction assetsPerShare() internal view returns (uint256) {\n\treturn (IController(controller).totalAssets(false)*assetDecimal*1e18) / totalSupply();\n\nfunction redeem (uint256 shares, address receiver) \n\tpublic \n\tvirtual \n\tnonReentrant \n\tunPaused \n\tonlyAllowed \n\treturns (uint256 assets) \n{\n\trequire (shares > 0, \"ZERO_SHARES\");\n\trequire (shares <= balance0f (msg.sender), \"EXCEED_TOTAL_BALANCE\");\n\tassets = (shares * **assetsPerShare()**) / 1e24; **// Miscalculation of assets**\n\trequire (assets <= maxWithdraw, \"EXCEED_ONE_TIME_MAX_WITHDRAW\");\n\t// Withdraw asset\n\t_withdraw(assets, shares, receiver);\n}\n```\n\nDue to the Storage Collision, The value of maxDeposit was set to 5000000000000, which is much higher than the value it is expected to set. This results in the return value of the `assetPerShare` function being much larger and thus the value of assets becomes larger.\n\n**Attack txns:**\n\nUpgrade tx: [0xab86672eb5335264c4c4b75262630ae1fb8dcf2a68aaafe4bb9fc3232b886712](https://etherscan.io/tx/0xab86672eb5335264c4c4b75262630ae1fb8dcf2a68aaafe4bb9fc3232b886712)\n\nExploit tx: [0x31565843d565ecab7ab65965d180e45a99d4718fa192c2f2221410f65ea03743](https://etherscan.io/tx/0x31565843d565ecab7ab65965d180e45a99d4718fa192c2f2221410f65ea03743)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1630884733671579653](https://twitter.com/BeosinAlert/status/1630884733671579653)\n\n**Recommendation:** \n\nTo prevent similar attacks during contract upgrades, it is crucial to follow best practices and ensure that the original storage order of variables remains unchanged.\n\n---",
    "images": [
      "images/Storage_image.png"
    ],
    "Lost": "$5.1M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/EFVault_exp.sol"
  },
  "DYNA": {
    "type": "Flashloans, Miscalculation, staking",
    "date": "2023-02-22",
    "rootCause": " \n\nStakingDYNA contract does not handle the deposit time correctly.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0xa7b5eabc3ee82c585f5f4ccc26b81c3bd62ff3a9#code#F1#L79](https://bscscan.com/address/0xa7b5eabc3ee82c585f5f4ccc26b81c3bd62ff3a9#code#F1#L79)\n\n```solidity\nfunction deposit(uint256 _stakeAmount) external {\n\trequire(enabled, \u201cStaking is not enabled\");\n\trequire(\n\t\t_stakeanount > 0,\n\t\t\u201cStakingDYlA: stake amount must be greater than 0\"\n\t);\n\ttoken.transferfrom(msg.sender, address(this), _stakeAmount);\n\tStakeDetail storage stakeDetail = stakers[msg.sender];\n\tif (stakeDetail.firstStakeat == 0) {\n\t\t\tstakeDetail.principal = stakeDetail.principal.add(_stakeAmount);\n\t\t\tstakeDetail.firstStakeAt = stakeDetail.firstStakedt == 0\n\t\t\t\t? block.timestamp\n\t\t\t\t: stakeDetail.FirstStakeAt;\n\tStakeDetail.lastProcessat = block.timestamp;\n\t} else {\n\t\tStakeDetail.principal = stakeDetail.principal.add(_stakeAmount); **// Vulnerable Point: Does not update lastProcessAt.**\n\t}\n\temit Deposit(msg.sender, _stakeAmount);\n}\n```\n\nIn the Contract, Users can deposit [**$DYNA**](https://twitter.com/search?q=%24DYNA&src=cashtag_click) to claim rewards, the interest is calculated based on the deposit duration. However, a vulnerability exists in the contract, as it fails to update the \"lastProcessAt\" parameter for any deposit. Consequently, the staking duration is miscalculated.\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x06bbe093d9b84783b8ca92abab5eb8590cb2321285660f9b2a529d665d3f18e4](https://bscscan.com/tx/0x06bbe093d9b84783b8ca92abab5eb8590cb2321285660f9b2a529d665d3f18e4)\n\n[https://bscscan.com/tx/0xc09678fec49c643a30fc8e4dec36d0507dae7e9123c270e1f073d335deab6cf0](https://bscscan.com/tx/0xc09678fec49c643a30fc8e4dec36d0507dae7e9123c270e1f073d335deab6cf0)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1628301635834486784](https://twitter.com/BeosinAlert/status/1628301635834486784)\n\n[https://twitter.com/BlockSecTeam/status/1628319536117153794](https://twitter.com/BlockSecTeam/status/1628319536117153794)",
    "images": [],
    "Lost": "$21k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DYNA_exp.sol"
  },
  "RevertFinance": {
    "type": "Arbitrary call, Dex/AMM, Insufficient validation",
    "date": "2023-02-18",
    "rootCause": "\n\nThe V3Utils contract had insufficient input validation, allowing arbitrary external calls, resulting in the theft of funds from approved users.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x531110418d8591c92e9cbbfc722db8ffb604fafd#code#F1#L225](https://etherscan.io/address/0x531110418d8591c92e9cbbfc722db8ffb604fafd#code#F1#L225)\n\n```solidity\nstruct SwapParams {\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        address recipient; // recipient of tokenOut and leftover tokenIn\n        bytes swapData;\n        bool unwrap; // if tokenIn or tokenOut is WETH - unwrap\n}\n\nfunction swap(SwapParams calldata params) external payable returns (uint256 amountOut) {\n\n        _prepareAdd(params.tokenIn, IERC20(address(0)), IERC20(address(0)), params.amountIn, 0, 0);\n\n        uint amountInDelta;\n        (amountInDelta, amountOut) = _swap(params.tokenIn, params.tokenOut, params.amountIn, params.minAmountOut, params.swapData);\n\n        // send swapped amount of tokenOut\n        if (amountOut > 0) {\n            _transferToken(params.recipient, params.tokenOut, amountOut, params.unwrap);\n        }\n\n        // if not all was swapped - return leftovers of tokenIn\n        uint leftOver = params.amountIn - amountInDelta;\n        if (leftOver > 0) {\n            _transferToken(params.recipient, params.tokenIn, leftOver, params.unwrap);\n        }\n    }\n```\n\nThe contract relied on an external aggregator called Ox for executing swaps. The frontend called the Ox API, which returned two dynamic keys, \"to\" and \"allowanceTarget,\" specifying which contracts to call and approve tokens to. These dynamic values were forwarded to the V3Utils contract instead of being whitelisted.\n\nThis allowed the attacker to send a token contract (e.g., USDC) as the swap router, granting them the ability to execute arbitrary code on it, such as the \"transferFrom\" function, which led to the attacker stealing funds from other addresses that have approved to the V3Utils contract.\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xdaccbc437cb07427394704fbcc8366589ffccf974ec6524f3483844b043f31d5](https://etherscan.io/tx/0xdaccbc437cb07427394704fbcc8366589ffccf974ec6524f3483844b043f31d5)\n\n**Analysis:**\n\n[https://mirror.xyz/revertfinance.eth/3sdpQ3v9vEKiOjaHXUi3TdEfhleAXXlAEWeODrRHJtU](https://mirror.xyz/revertfinance.eth/3sdpQ3v9vEKiOjaHXUi3TdEfhleAXXlAEWeODrRHJtU)\n\n[https://twitter.com/revertfinance/status/1627490043026890752](https://twitter.com/revertfinance/status/1627490043026890752)",
    "images": [],
    "Lost": "$30k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RevertFinance_exp.sol"
  },
  "Starlink": {
    "type": "Flashloans, Misconfiguration, skim",
    "date": "2023-02-17",
    "rootCause": " \n\nMisconfiguration in \"transfer\" function\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x518281f34dbf5b76e6cdd3908a6972e8ec49e345#code#L1135](https://bscscan.com/address/0x518281f34dbf5b76e6cdd3908a6972e8ec49e345#code#L1135)\n\n```solidity\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual override {\n        if (\n            botAddresses[sender] &&\n            amount > antiBotAmount &&\n            antiBotTime > block.timestamp\n        ) {\n            revert(\"Anti Bot\");\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this)); \n\n        if(contractTokenBalance >= _maxTxAmount) { \n            contractTokenBalance = _maxTxAmount; \n        }\n        \n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n\n        bool buyLp = buyIndex >= buyIndexSellLiquify;\n\n        if (\n            overMinTokenBalance && \n            !inSwapAndLiquify && \n            sender != uniswapV2Pair && \n            swapAndLiquifyEnabled \n        ) {\n            contractTokenBalance = numTokensSellToAddToLiquidity;\n            swapAndLiquify(contractTokenBalance);\n        }\n\n        if(recipient == uniswapV2Pair){\n            if (\n                sender != address(this) &&\n                recipient != address(this) &&\n                !_isExcludedFromFee[sender]\n            ) {\n                if (\n                    overMinTokenBalance && \n                    !inSwapAndLiquify && \n                    sender != uniswapV2Pair && \n                    swapSellLiquifyEnabled \n                ) {\n                    contractTokenBalance = numTokensSellToAddToLiquidity;\n                    swapAndLiquify(contractTokenBalance);\n                }\n                uint256 _fee = amount.mul(sellFeeRate).div(100);\n                super._transfer(sender,mintContract, _fee.mul(LPSellFees).div(sellFeeRate));\n                super._transfer(sender, addressForMarketing, _fee.mul(marketSellFees).div(sellFeeRate));\n                super._transfer(sender, BurnAddr, _fee.mul(burnSellFees).div(sellFeeRate));\n                amount = amount.sub(_fee);\n            }\n        }else if(sender == uniswapV2Pair){\n            if (\n                sender != address(this) &&\n                recipient != address(this) &&\n                !_isExcludedFromFee[sender]\n            ) {\n                if (\n                    overMinTokenBalance && \n                    !inSwapAndLiquify && \n                    buyLp&&\n                    swapBuyLiquifyEnabled \n                ) {\n                    contractTokenBalance = numTokensSellToAddToLiquidity;\n                    swapAndLiquify(contractTokenBalance);\n                    buyIndex =0;\n\n                }\n                uint256 _fee = amount.mul(buyFeeRate).div(100);\n                super._transfer(sender,mintContract, _fee.mul(LPBuyFees).div(buyFeeRate));\n                super._transfer(sender,addressForMarketing, _fee.mul(marketBuyFees).div(buyFeeRate));\n                super._transfer(sender, BurnAddr, _fee.mul(burnBuyFees).div(buyFeeRate));\n                amount = amount.sub(_fee);\n                buyIndex =buyIndex+1;\n            }\n        }\n    \n        super._transfer(sender, recipient, amount);\n    }\n```\n\nStarlinkCoin contract used the \"_transfer\" function to transfer funds, which incurs a fee when funds come from the LP contract.\n\nThe attacker used the \"skim\" method to directly transfer funds to the LP contract, and the fee was also deducted, causing a change in the proportion of the two tokens in the trading pair contract.\n\nThe attacker then exchanged the tokens for a profit and left the contract.\n\n\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x146586f05a4513136deab3557ad15df8f77ffbcdbd0dd0724bc66dbeab98a962](https://bscscan.com/tx/0x146586f05a4513136deab3557ad15df8f77ffbcdbd0dd0724bc66dbeab98a962)\n\n**Analysis:**\n\n[https://twitter.com/NumenAlert/status/1626447469361102850](https://twitter.com/NumenAlert/status/1626447469361102850)\n\n[https://twitter.com/bbbb/status/1626392605264351235](https://twitter.com/bbbb/status/1626392605264351235)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$12k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Starlink_exp.sol"
  },
  "Dexible": {
    "type": "Arbitrary call, Dex/AMM",
    "date": "2023-02-17",
    "rootCause": " \n\nArbitrary External Call allowing an attacker to steal a user\u2019s approved funds.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x33e690aea97e4ef25f0d140f1bf044d663091daf#code#F19#L38](https://etherscan.io/address/0x33e690aea97e4ef25f0d140f1bf044d663091daf#code#F19#L38)\n\n```solidity\nfunction fill(SwapTypes.SwapRequest calldata request, SwapMeta memory meta) external onlySelf returns (SwapMeta memory) {\n\n\tpreCheck(request, meta) ;\n\tmeta.outAmount = request.tokenOut.token.balanceOf(address(this));\n\n\tfor (uint i=0; i < request.routes.length; ++i) {\n\t\tSwapTypes.RouterRequest calldata rr = request.routes[i];\n\t\tIERC20(rr.routeAmount.token).safeApprove(rr.spender, rr.routeAmount.amount);\n\t\t(bool s, ) = rr.router.call.(routerData); **//Vulnerable Point: The attacker can make an arbitrary** external call from the contract.\n\n\t\tif(!s) {\n\t\t\trevert (\"Failed to swap\");\n\t\t}\n\t}\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x138daa4cbeaa3db42eefcec26e234fc2c89a4aa17d6b1870fc460b2856fd11a6](https://etherscan.io/tx/0x138daa4cbeaa3db42eefcec26e234fc2c89a4aa17d6b1870fc460b2856fd11a6)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1626493024879673344](https://twitter.com/peckshield/status/1626493024879673344)\n\n[https://twitter.com/MevRefund/status/1626450002254958592](https://twitter.com/MevRefund/status/1626450002254958592)",
    "images": [],
    "Lost": "$1.5M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Dexible_exp.sol"
  },
  "Platypusdefi": {
    "type": "Incorrect logic, Miscalculation, lending",
    "date": "2023-02-17",
    "rootCause": "\n\nThe emergencyWithdraw function incorrectly evaluates the insolvency before the collateral removal, resulting in an insolvent debt position after the emergency withdrawal.\n\n**Vulnerable code snippet:**\n\n[https://snowtrace.io/address/0xc007f27b757a782c833c568f5851ae1dfe0e6ec7#code#F1#L578](https://snowtrace.io/address/0xc007f27b757a782c833c568f5851ae1dfe0e6ec7#code#F1#L578)\n\n```solidity\nfunction emergencyWithdraw(uint256 _pid) public nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n\n        if (address(platypusTreasure) != address(0x00)) {\n            (bool isSolvent, ) = platypusTreasure.isSolvent(msg.sender, address(poolInfo[_pid].lpToken), true); **//Vulnerable Point: No Check for Adjustment for borrowed funds**\n            require(isSolvent, 'remaining amount exceeds collateral factor');\n        }\n\n        // reset rewarder before we update lpSupply and sumOfFactors\n        IBoostedMultiRewarder rewarder = pool.rewarder;\n        if (address(rewarder) != address(0)) {\n            rewarder.onPtpReward(msg.sender, user.amount, 0, user.factor, 0);\n        }\n\n        // SafeERC20 is not needed as Asset will revert if transfer fails\n        pool.lpToken.transfer(address(msg.sender), user.amount);\n\n        // update non-dialuting factor\n        pool.sumOfFactors -= user.factor;\n\n        user.amount = 0;\n        user.factor = 0;\n        user.rewardDebt = 0;\n\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }\n```\n\n**Attack tx:**\n\n[https://snowtrace.io/tx/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430](https://snowtrace.io/tx/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430)\n\n**Analysis:**\n\n[https://twitter.com/spreekaway/status/1626319585040338953](https://twitter.com/spreekaway/status/1626319585040338953)\n\n[https://twitter.com/peckshield/status/1626367531480125440](https://twitter.com/peckshield/status/1626367531480125440)\n\n[https://twitter.com/danielvf/status/1626340324103663617](https://twitter.com/danielvf/status/1626340324103663617)",
    "images": [],
    "Lost": "$8.5M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Platypus_exp.sol"
  },
  "dForce": {
    "type": "Price Manipulation, Reentrancy",
    "date": "2023-02-10",
    "rootCause": " \n\nRead-only Reentrancy\u00a0in the get_virtual_price function of the Curve LP Oracle.\n\n**Vulnerable code snippet:**\n\n[https://arbiscan.io/address/0x6eb2dc694eb516b16dc9fbc678c60052bbdd7d80#code#L253](https://arbiscan.io/address/0x6eb2dc694eb516b16dc9fbc678c60052bbdd7d80#code#L253)\n\n```solidity\n@view\n@external\ndef get_virtual_price() -> uint256:\n    \"\"\"\n    @notice The current virtual price of the pool LP token\n    @dev Useful for calculating profits\n    @return LP token virtual price normalized to 1e18\n    \"\"\"\n    D: uint256 = self.get_D(self._xp(self._stored_rates()), self._A())\n    # D is in the units similar to DAI (e.g. converted to precision 1e18)\n    # When balanced, D = n * x_u - total virtual value of the portfolio\n    token_supply: uint256 = ERC20(self.lp_token).totalSupply()\n    return D * PRECISION / token_supply\n```\n\n[https://arbiscan.io/address/0x6eb2dc694eb516b16dc9fbc678c60052bbdd7d80#code#L487](https://arbiscan.io/address/0x6eb2dc694eb516b16dc9fbc678c60052bbdd7d80#code#L487)\n\n```solidity\n@external\n@nonreentrant('lock')\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]) -> uint256[N_COINS]:\n    \"\"\"\n    @notice Withdraw coins from the pool\n    @dev Withdrawal amounts are based on current deposit ratios\n    @param _amount Quantity of LP tokens to burn in the withdrawal\n    @param min_amounts Minimum amounts of underlying coins to receive\n    @return List of amounts of coins that were withdrawn\n    \"\"\"\n    _lp_token: address = self.lp_token\n    total_supply: uint256 = ERC20(_lp_token).totalSupply()\n    amounts: uint256[N_COINS] = empty(uint256[N_COINS])\n\n    for i in range(N_COINS):\n        _balance: uint256 = self.balances[i]\n        value: uint256 = _balance * _amount / total_supply\n        assert value >= min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\n        self.balances[i] = _balance - value\n        amounts[i] = value\n        if i == 0:\n            raw_call(msg.sender, b\"\", value=value) **// @Vulnerable Point: Here, While Transferring ETH, LP tokens have not been burned. But the pool of ETH has been already reduced.**\n        else:\n            assert ERC20(self.coins[1]).transfer(msg.sender, value)\n\n    CurveToken(_lp_token).burnFrom(msg.sender, _amount)  # Will raise if not enough\n\n    log RemoveLiquidity(msg.sender, amounts, empty(uint256[N_COINS]), total_supply - _amount)\n\n    return amounts\n```\n\n**Attack tx:**\n\n[https://arbiscan.io/tx/0x5db5c2400ab56db697b3cc9aa02a05deab658e1438ce2f8692ca009cc45171dd](https://arbiscan.io/tx/0x5db5c2400ab56db697b3cc9aa02a05deab658e1438ce2f8692ca009cc45171dd)\n\n[https://optimistic.etherscan.io/tx/0x6c19762186c9f32c81eb2a79420fc7ad4485aa916cab37ec278b216757bfba0d](https://optimistic.etherscan.io/tx/0x6c19762186c9f32c81eb2a79420fc7ad4485aa916cab37ec278b216757bfba0d)\n\n**Analysis:**\n\n[https://quillaudits.medium.com/decoding-dforce-protocol-read-only-reentrancy-exploit-quillaudits-c012aed4d666](https://quillaudits.medium.com/decoding-dforce-protocol-read-only-reentrancy-exploit-quillaudits-c012aed4d666)\n\n[https://twitter.com/SlowMist_Team/status/1623956763598000129](https://twitter.com/SlowMist_Team/status/1623956763598000129)\n\n[https://twitter.com/BlockSecTeam/status/1623901011680333824](https://twitter.com/BlockSecTeam/status/1623901011680333824)",
    "images": [],
    "Lost": "$3.65M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/dForce_exp.sol"
  },
  "CowSwap": {
    "type": "Arbitrary call, Insufficient validation",
    "date": "2023-02-07",
    "rootCause": " \n\nArbitrary External Call Vulnerability\n\nThe settle function allows arbitrary calls, and the solver contract doesn't validate the interaction data. This vulnerability allows attackers to have the GPv2 contract approve their malicious contract, ultimately leading to a drain of the settlement contract.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x9008d19f58aabd9ed0d60971565aa8510560ab41#code#F1#L121](https://etherscan.io/address/0x9008d19f58aabd9ed0d60971565aa8510560ab41#code#F1#L121)\n\n```solidity\nfunction settle(\n        IERC20[] calldata tokens, **// The function accepts an arbitrary token address from CallData and does not check the token received.**\n        uint256[] calldata clearingPrices,\n        GPv2Trade.Data[] calldata trades,\n        GPv2Interaction.Data[][3] calldata interactions\n    ) external nonReentrant onlySolver {\n        executeInteractions(interactions[0]);\n\n        (\n            GPv2Transfer.Data[] memory inTransfers,\n            GPv2Transfer.Data[] memory outTransfers\n        ) = computeTradeExecutions(tokens, clearingPrices, trades);  **//vulnerable point**\n\n        vaultRelayer.transferFromAccounts(inTransfers); **//vulnerable point**\n\n        executeInteractions(interactions[1]);\n\n        vault.transferToAccounts(outTransfers);\n\n        executeInteractions(interactions[2]);\n\n        emit Settlement(msg.sender);\n    }\n```\n\n[https://etherscan.io/address/0x9008d19f58aabd9ed0d60971565aa8510560ab41#code#F2#L41](https://etherscan.io/address/0x9008d19f58aabd9ed0d60971565aa8510560ab41#code#F2#L41)\n\n```solidity\nfunction transferFromAccounts(GPv2Transfer.Data[] calldata transfers)\n        external\n        onlyCreator\n    {\n        vault.transferFromAccounts(transfers, msg.sender);\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x92f906bce94bab417cccc87ae046448d7fb8c2c0350b7ed911545577acb3bfc1](https://etherscan.io/tx/0x92f906bce94bab417cccc87ae046448d7fb8c2c0350b7ed911545577acb3bfc1)\n\n[https://etherscan.io/tx/0x90b468608fbcc7faef46502b198471311baca3baab49242a4a85b73d4924379b](https://etherscan.io/tx/0x90b468608fbcc7faef46502b198471311baca3baab49242a4a85b73d4924379b)\n\n**Analysis:**\n\n[https://twitter.com/MevRefund/status/1622793836291407873](https://twitter.com/MevRefund/status/1622793836291407873)\n\n[https://twitter.com/peckshield/status/1622801412727148544](https://twitter.com/peckshield/status/1622801412727148544)",
    "images": [],
    "Lost": "$120k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/CowSwap_exp.sol"
  },
  "FDP": {
    "type": "Deflationary token, Flashloans, Miscalculation",
    "date": "2023-02-06",
    "rootCause": " \n\nPrice Manipulation of deflationary tokens via flashloan\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x1954b6bd198c29c3ecf2d6f6bc70a4d41ea1cc07#code#L575](https://bscscan.com/address/0x1954b6bd198c29c3ecf2d6f6bc70a4d41ea1cc07#code#L575)\n\n```solidity\nfunction deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n```\n\nThe attacker uses the tAmount to call deliver function, which is to reduce the user-specified tAmount and add it to the fee. After calling deliver, _getRate becomes smaller when _rTotal is 28% less and _tTotal remains the same.\nSince transaction pair is not a deflation excluded address, the balance obtained becomes larger. The attacker can directly withdraw the increased FDP and swap into WBNB\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x09925028ce5d6a54801d04ff8f39e79af6c24289e84b301ddcdb6adfa51e901b](https://bscscan.com/tx/0x09925028ce5d6a54801d04ff8f39e79af6c24289e84b301ddcdb6adfa51e901b)\n\n**Analysis:**\n\n[https://twitter.com/BeosinAlert/status/1622806011269771266](https://twitter.com/BeosinAlert/status/1622806011269771266)",
    "images": [],
    "Lost": "16 WBNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/FDP_exp.t.sol"
  },
  "Spherax USDs": {
    "type": "Incorrect logic, Math",
    "date": "2023-02-03",
    "rootCause": " \n\nFlawed internal accounting systems\n\nUSDS has three different accounting systems, two separate auto-migration systems, and all share the same variables, just interpret their meaning differently. Thus, all account variables have to be updated together in order to accurately calculate a user's balance.\n\nHowever, due to improper implementation, these critical updates were not performed accurately, leading to the attack.\n\n**Vulnerable code snippet:**\n\ndanielvf:\n\n\n\n**Attack tx:**\n\n[https://arbiscan.io/tx/0xfaf84cabc3e1b0cf1ff1738dace1b2810f42d98baeea17b146ae032f0bdf82d5](https://arbiscan.io/tx/0xfaf84cabc3e1b0cf1ff1738dace1b2810f42d98baeea17b146ae032f0bdf82d5)\n\n**Analysis:**\n\n[https://medium.com/sperax/usds-feb-3-exploit-report-from-engineering-team-9f0fd3cef00c](https://medium.com/sperax/usds-feb-3-exploit-report-from-engineering-team-9f0fd3cef00c)\n\n[https://twitter.com/danielvf/status/1621965412832350208](https://twitter.com/danielvf/status/1621965412832350208)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$309k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/USDs_exp.sol"
  },
  "Orion Protocol": {
    "type": "Reentrancy",
    "date": "2023-02-03",
    "rootCause": " \n\nReentrancy in the doSwapThroughOrionPool function\n\nThe doswapThroughOrionPool function allows a user-provided swap path to be used with malicious tokens that can be used to re-enter deposits.\n\nAfter the transfer happens, the curBalance is updated. Therefore, a callback function is added to the transfer in the fake token. The callback code calls the depositAsset function, causing the curBalance to be updated incorrectly. Then, the attacker calls the withdraw function to take away the funds after paying back the flash loan.\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x420a50a62b17c18b36c64478784536ba980feac8#code#F1#L78](https://etherscan.io/address/0x420a50a62b17c18b36c64478784536ba980feac8#code#F1#L78)\n\n```solidity\nfunction doSwapThroughOrionPool(\n        address user,\n        address to,\n        IPoolFunctionality.SwapData calldata swapData\n    ) external override returns (uint256 amountOut, uint256 amountIn) {\n        bool withFactory = swapData.path.length > 2 &&\n            (supportedFactories[swapData.path[0]] != FactoryType.UNSUPPORTED);\n        address curFactory = withFactory ? swapData.path[0] : factory;\n        address[] memory new_path;\n\n        uint256 tokenIndex = withFactory ? 1 : 0;\n        new_path = new address[](swapData.path.length - tokenIndex);\n\n        for ((uint256 i, uint256 j) = (tokenIndex, 0); i < swapData.path.length; (++i, ++j)) {\n            new_path[j] = swapData.path[i] == address(0) ? WETH : swapData.path[i];\n        }\n\n        (uint256 amount_spend_base_units, uint256 amount_receive_base_units) = (\n            LibUnitConverter.decimalToBaseUnit(\n                swapData.path[tokenIndex],\n                swapData.amount_spend\n            ),\n            LibUnitConverter.decimalToBaseUnit(\n                swapData.path[swapData.path.length - 1],\n                swapData.amount_receive\n            )\n        );\n        {\n        (uint256 userAmountIn, uint256 userAmountOut) = _doSwapTokens(InternalSwapData( **//vulnerable point**\n            user,\n            amount_spend_base_units,\n            amount_receive_base_units,\n            withFactory ? swapData.path[1] : swapData.path[0],\n            new_path,\n            swapData.is_exact_spend,\n            to,\n            curFactory,\n            supportedFactories[curFactory],\n            swapData.supportingFee\n        ));\n\n        //  Anyway user gave amounts[0] and received amounts[len-1]\n        amountOut = LibUnitConverter.baseUnitToDecimal(\n            swapData.path[tokenIndex],\n            userAmountIn\n        );\n        amountIn = LibUnitConverter.baseUnitToDecimal(\n            swapData.path[swapData.path.length - 1],\n            userAmountOut\n        );\n        }\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa](https://etherscan.io/tx/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa)\n\n[https://bscscan.com/tx/0xfb153c572e304093023b4f9694ef39135b6ed5b2515453173e81ec02df2e2104](https://bscscan.com/tx/0xfb153c572e304093023b4f9694ef39135b6ed5b2515453173e81ec02df2e2104)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1621263393054420992](https://twitter.com/BlockSecTeam/status/1621263393054420992)\n\n[https://www.numencyber.com/analysis-of-orionprotocol-reentrancy-attack-with-poc/](https://www.numencyber.com/analysis-of-orionprotocol-reentrancy-attack-with-poc/)\n\n**Similar events**\n[https://github.com/SunWeb3Sec/DeFiHackLabs#20221223---defrost---reentrancy](https://github.com/SunWeb3Sec/DeFiHackLabs#20221223---defrost---reentrancy)\n[https://github.com/SunWeb3Sec/DeFiHackLabs#20221110---dfxfinance---reentrancy](https://github.com/SunWeb3Sec/DeFiHackLabs#20221110---dfxfinance---reentrancy)",
    "images": [],
    "Lost": "$3M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Orion_exp.sol"
  },
  "BonqDAO": {
    "type": "Insufficient validation, Oracle",
    "date": "2023-02-02",
    "rootCause": " \n\nPrice Oracle manipulation due to incorrect integration of the Tellor Oracle. \n\n**Vulnerable code snippet:**\n\n[https://polygonscan.com/address/0x8f55d884cad66b79e1a131f6bcb0e66f4fd84d5b#code#F2#L282](https://polygonscan.com/address/0x8f55d884cad66b79e1a131f6bcb0e66f4fd84d5b#code#F2#L282)\n\n```solidity\nfunction submitValue(\n        bytes32 _queryId,\n        bytes calldata _value,\n        uint256 _nonce,\n        bytes calldata _queryData\n    ) external {\n        require(keccak256(_value) != keccak256(\"\"), \"value must be submitted\");\n        Report storage _report = reports[_queryId];\n        require(\n            _nonce == _report.timestamps.length || _nonce == 0,\n            \"nonce must match timestamp index\"\n        );\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        require(\n            _staker.stakedBalance >= stakeAmount, // Its checks if the staker balance is more than stakeAmount i.e. 10 TRB\n            \"balance must be greater than stake amount\"\n        ); \n\n        require(\n            (block.timestamp - _staker.reporterLastTimestamp) * 1000 >\n                (reportingLock * 1000) / (_staker.stakedBalance / stakeAmount),\n            \"still in reporter time lock, please wait!\"\n        );\n\t\t\t\t....\n\t\t\t\t....\n        _report.timestampIndex[block.timestamp] = _report.timestamps.length;\n        _report.timestamps.push(block.timestamp);\n        _report.timestampToBlockNum[block.timestamp] = block.number;\n        _report.valueByTimestamp[block.timestamp] = _value; // Vulnerable Point: The value is assigned here. Anyone who has staked 10TRB can submit the balance. \n        _report.reporterByTimestamp[block.timestamp] = msg.sender;\n        // Disperse Time Based Reward\n        uint256 _reward = ((block.timestamp - timeOfLastNewValue) * timeBasedReward) / 300; //.5 TRB per 5 minutes\n```\n\n**Attack tx:**\n\n1st Txn: [0x31957ecc43774d19f54d9968e95c69c882468b46860f921668f2c55fadd51b19](https://polygonscan.com/tx/0x31957ecc43774d19f54d9968e95c69c882468b46860f921668f2c55fadd51b19)\n\n2nd Txn: ****[0xa02d0c3d16d6ee0e0b6a42c3cc91997c2b40c87d777136dedebe8ee0f47f32b1](https://polygonscan.com/tx/0xa02d0c3d16d6ee0e0b6a42c3cc91997c2b40c87d777136dedebe8ee0f47f32b1)\n\n**Analysis:**\n\n[https://quillaudits.medium.com/decoding-bonq-daos-120-million-exploit-quillaudits-bd8e50eec4ac](https://quillaudits.medium.com/decoding-bonq-daos-120-million-exploit-quillaudits-bd8e50eec4ac)\n\n[https://twitter.com/BlockSecTeam/status/1621043757390123008](https://twitter.com/BlockSecTeam/status/1621043757390123008)",
    "images": [],
    "Lost": "$88M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BonqDAO_exp.sol"
  },
  "ThoreumFinance": {
    "type": "Rug-Pull(Protocol Side), Token-Transfer",
    "date": "2023-01-19",
    "rootCause": "\n\nAncilia: when 0x7d1e1901226e0ba389bfb1281ede859e6e48cc3d calls transfer to itself, its balance will increase. By repeating doing this, it ends with 500k+ $THOREUM tokens\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/token/0xce1b3e5087e8215876af976032382dd338cf8401#code](https://bscscan.com/token/0xce1b3e5087e8215876af976032382dd338cf8401#code)\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x3fe3a1883f0ae263a260f7d3e9b462468f4f83c2c88bb89d1dee5d7d24262b51](https://bscscan.com/tx/0x3fe3a1883f0ae263a260f7d3e9b462468f4f83c2c88bb89d1dee5d7d24262b51)\n\n**Analysis:**\n\n[https://twitter.com/AnciliaInc/status/1615944396134043648](https://twitter.com/AnciliaInc/status/1615944396134043648)",
    "images": [],
    "Lost": "2000 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ThoreumFinance_exp.sol"
  },
  "QTNToken": {
    "type": "Deflationary token, ERC20, Token-Transfer",
    "date": "2023-01-18",
    "rootCause": "\n\nBlocksec: QTN token has an inflation mechanism: all QTN holders' balanceOf will increase for each QTN's sale in Uniswap. However, the QTN's developer uses \u201cfrom == UniswapPair\u201d to judge if there is a QTN's sale. The incorrect condition is the root cause of this attack.\n\nUniswap pair has a function named\nskim that can cheat QTN, so the attack contract increases his QTN's balance via 3 steps: 1) transfer x QTN to Uniswap pair; 2\uff09invoke the skim function to a created contract; 3) transfer y QTN back to the attack contract (y > x).\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0xc9fa8f4cfd11559b50c5c7f6672b9eea2757e1bd#code#L287](https://etherscan.io/address/0xc9fa8f4cfd11559b50c5c7f6672b9eea2757e1bd#code#L287)\n\n```jsx\nfunction balanceOf(address account) public view override returns (uint256) {\n        if(account == uniswapV2Pair)\n            return uniswapV2PairAmount;\n        return _gonBalances[account].div(_gonsPerFragment); **//vulnerable point**\n    }\n\nfunction rebasePlus(uint256 _amount) private {\n         _totalSupply = _totalSupply.add(_amount.div(5));\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n    }\n\nfunction _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"ERC20: Transfer amount must be greater than zero\");\n        \n        if (from != owner() && to != owner()) {\n            uint256 txLimitAmount = _totalSupply.mul(_percentForTxLimit).div(100);\n            \n            require(amount <= txLimitAmount, \"ERC20: amount exceeds the max tx limit.\");\n            \n            if(from != uniswapV2Pair) { **//vulnerable point**\n                require(!blacklist[from] && !blacklist[to], 'ERC20: the transaction was blocked.');\n                require(_buyInfo[from] == 0 || _buyInfo[from].add(_timeLimitFromLastBuy) < now, \"ERC20: Tx not allowed yet.\");\n                \n                if(to != address(uniswapV2Router) && to != uniswapV2Pair)\n                    _tokenTransfer(from, to, amount, 0);\n                else\n                    _tokenTransfer(from, to, amount, 0);\n            }\n            else {\n                if(!_live)\n                    blacklist[to] = true;\n                \n                require(balanceOf(to) <= txLimitAmount, 'ERC20: current balance exceeds the max limit.');\n                \n                _buyInfo[to] = now;\n                _tokenTransfer(from, to, amount, 0);\n\n                uint256 rebaseLimitAmount = _totalSupply.mul(_percentForRebase).div(100);\n                uint256 currentBalance = balanceOf(to);\n                uint256 newBalance = currentBalance.add(amount);\n                if(currentBalance < rebaseLimitAmount && newBalance < rebaseLimitAmount) {\n                    rebasePlus(amount);\n                }\n            }\n        } else {\n            _tokenTransfer(from, to, amount, 0);\n        }\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x37cb8626e45f0749296ef080acb218e5ccc7efb2ae4d39c952566dc378ca1c4c](https://etherscan.io/tx/0x37cb8626e45f0749296ef080acb218e5ccc7efb2ae4d39c952566dc378ca1c4c)\n\n[https://etherscan.io/tx/0xfde10ad92566f369b23ed5135289630b7a6453887c77088794552c2a3d1ce8b7](https://etherscan.io/tx/0xfde10ad92566f369b23ed5135289630b7a6453887c77088794552c2a3d1ce8b7)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1615625901739511809](https://twitter.com/BlockSecTeam/status/1615625901739511809)",
    "images": [],
    "Lost": "2 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/QTN_exp.sol"
  },
  "UPS": {
    "type": "Business Logic Flaw",
    "date": "2024-04-09",
    "rootCause": "The UPS token was exploited due to a flawed transfer implementation. When tokens are transferred to the Pancake pair, they are burned at the pair and the \"skim\" function is called. This caused the UPS reserve to shrink significantly, allowing the hacker to drain BUSD from the pair using just a few UPS tokens.\n\nVulnerable code snippet:\n\n[](https://bscscan.com/address/0x3da4828640ad831f3301a4597821cc3461b06678)\n\nAttack tx:\n\n[0xd03702e17171a32464 | Phalcon Explorer](https://app.blocksec.com/explorer/tx/bsc/0xd03702e17171a32464ce748b8797008d59e2dbcecd3b3847d5138414566c886d)\n\nAnalysis:\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:\n\n",
    "images": [],
    "Lost": "$28K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/UPS_exp.sol"
  },
  "OmniEstate": {
    "type": "Insufficient validation, staking",
    "date": "2023-01-17",
    "rootCause": "\n\nWhen end_date is not 3, 6, 12, or 24, the value of duration[msg.sender] is set to the default value, which is 0;\nIn the function _Check_reward, when the parameter durations is 0, the system will directly return total_percent, bypassing the system logic.\n\n**Vulnerable code snippet:**\n\n```jsx\n// ivesting function for staking\n    function invest(uint256 end_date, uint256 qty_ort) external whenNotPaused {\n        require(qty_ort > 0, \"amount cannot be 0\");\n        //transfer token to this smart contract\n        stakeToken.approve(address(this), qty_ort);\n        stakeToken.safeTransferFrom(msg.sender, address(this), qty_ort);\n        //save their staking duration for further use\n        if (end_date == 3) {\n            end_staking[msg.sender] = block.timestamp + 90 days;\n            duration[msg.sender] = 3;\n        } else if (end_date == 6) {\n            end_staking[msg.sender] = block.timestamp + 180 days;\n            duration[msg.sender] = 6;\n        } else if (end_date == 12) {\n            end_staking[msg.sender] = block.timestamp + 365 days;\n            duration[msg.sender] = 12;\n        } else if (end_date == 24) {\n            end_staking[msg.sender] = block.timestamp + 730 days;\n            duration[msg.sender] = 24;\n        }\n        //calculate reward tokens  for further use\n        uint256 check_reward = _Check_reward(duration[msg.sender], qty_ort) /\n            1 ether;\n        //save values in array\n        tokens_staking.push(\n            staking(\n                msg.sender,\n                qty_ort,\n                end_staking[msg.sender],\n                duration[msg.sender],\n                true,\n                check_reward\n            )\n        );\n        //save array index in map\n        uint256 lockId = tokens_staking.length - 1;\n        userStake[msg.sender].push(lockId);\n\n        emit Invest(\n            msg.sender,\n            lockId,\n            end_staking[msg.sender],\n            duration[msg.sender],\n            qty_ort,\n            check_reward\n        );\n    }\n//Reward Calculation\n    function _Check_reward(uint256 durations, uint256 balance)\n        internal\n        returns (uint256)\n    {\n        total_percent2 = balance / 1 ether;\n        //if user stakes token for 3 months\n        if (durations == 3) {\n            if (total_percent2 >= 10000 && total_percent2 < 40000) {\n                total_percent = _Percentage(balance, 600000000000000000);\n            } else if (total_percent2 >= 40000 && total_percent2 < 60000) {\n                total_percent = _Percentage(balance, 1200000000000000000);\n            } else if (total_percent2 >= 60000 && total_percent2 < 80000) {\n                total_percent = _Percentage(balance, 1800000000000000000);\n            } else if (total_percent2 >= 80000 && total_percent2 < 100000) {\n                total_percent = _Percentage(balance, 2400000000000000000);\n            } else if (total_percent2 >= 100000) {\n                total_percent = _Percentage(balance, 3000000000000000000);\n            }\n        } else if (durations == 6) {\n            if (total_percent2 >= 10000 && total_percent2 < 40000) {\n                total_percent = _Percentage(balance, 1600000000000000000);\n            } else if (total_percent2 >= 40000 && total_percent2 < 60000) {\n                total_percent = _Percentage(balance, 3200000000000000000);\n            } else if (total_percent2 >= 60000 && total_percent2 < 80000) {\n                total_percent = _Percentage(balance, 4800000000000000000);\n            } else if (total_percent2 >= 80000 && total_percent2 < 100000) {\n                total_percent = _Percentage(balance, 6400000000000000000);\n            } else if (total_percent2 >= 100000) {\n                total_percent = _Percentage(balance, 8000000000000000000);\n            }\n        } else if (durations == 12) {\n            if (total_percent2 >= 10000 && total_percent2 < 40000) {\n                total_percent = _Percentage(balance, 4000000000000000000);\n            } else if (total_percent2 >= 40000 && total_percent2 < 60000) {\n                total_percent = _Percentage(balance, 8000000000000000000);\n            } else if (total_percent2 >= 60000 && total_percent2 < 80000) {\n                total_percent = _Percentage(balance, 12000000000000000000);\n            } else if (total_percent2 >= 80000 && total_percent2 < 100000) {\n                total_percent = _Percentage(balance, 16000000000000000000);\n            } else if (total_percent2 >= 100000) {\n                total_percent = _Percentage(balance, 20000000000000000000);\n            }\n        } else if (durations == 24) {\n            if (total_percent2 >= 10000 && total_percent2 < 40000) {\n                total_percent = _Percentage(balance, 11200000000000000000);\n            } else if (total_percent2 >= 40000 && total_percent2 < 60000) {\n                total_percent = _Percentage(balance, 22400000000000000000);\n            } else if (total_percent2 >= 60000 && total_percent2 < 80000) {\n                total_percent = _Percentage(balance, 33600000000000000000);\n            } else if (total_percent2 >= 80000 && total_percent2 < 100000) {\n                total_percent = _Percentage(balance, 44800000000000000000);\n            } else if (total_percent2 >= 100000) {\n                total_percent = _Percentage(balance, 56000000000000000000);\n            }\n        }\n        return total_percent;\n    }\n```\n\n**Attack tx:**\n\ninvest\n[https://bscscan.com/tx/0x49bed801b9a9432728b1939951acaa8f2e874453d39c7d881a62c2c157aa7613](https://bscscan.com/tx/0x49bed801b9a9432728b1939951acaa8f2e874453d39c7d881a62c2c157aa7613)\nwithdraw\n\n[https://bscscan.com/tx/0xa916674fb8203fac6d78f5f9afc604be468a514aa61ea36c6d6ef26ecfbd0e97](https://bscscan.com/tx/0xa916674fb8203fac6d78f5f9afc604be468a514aa61ea36c6d6ef26ecfbd0e97)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1615232012834705408](https://twitter.com/BlockSecTeam/status/1615232012834705408)",
    "images": [],
    "Lost": "$70k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/OmniEstate_exp.sol"
  },
  "MidasCapital": {
    "type": "Oracle, Reentrancy, lending",
    "date": "2023-01-16",
    "rootCause": "\n\nBlocksec: It is due to an unexcepted external call before updating critical variables->reentrancy & miscalculation of the token prices.\n\nThe key points to make profits are: 1) the calculation of a position's collateral depends on self.D and totalSupply; 2) self.D is updated after an unexcepted callback, so the four borrows in step 5 to use an outdated self.D.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x13a2eb858aa1ace895a2a89ac6afd48bd6b1f8d7#code#F6#L335](https://bscscan.com/address/0x13a2eb858aa1ace895a2a89ac6afd48bd6b1f8d7#code#F6#L335)\n\n```jsx\nfunction redeemFresh(\n    address redeemer,\n    uint256 redeemTokensIn,\n    uint256 redeemAmountIn\n  ) internal returns (uint256) {\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"!redeemTokensInorOut!=0\");\n \n    RedeemLocalVars memory vars;\n \n    /* exchangeRate = invoke Exchange Rate Stored() */\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n \n    if (redeemAmountIn == type(uint256).max) {\n      redeemAmountIn = comptroller.getMaxRedeemOrBorrow(redeemer, address(this), false);\n    }\n \n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      vars.redeemTokens = redeemTokensIn;\n \n      (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n        Exp({ mantissa: vars.exchangeRateMantissa }),\n        redeemTokensIn\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n \n      (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate( **//vulnerable point**\n        redeemAmountIn,\n        Exp({ mantissa: vars.exchangeRateMantissa })\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n \n      vars.redeemAmount = redeemAmountIn;\n    }\n \n    /* Fail if redeem not allowed */\n    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n    }\n \n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n    }\n \n    /*\n     * We calculate the new total supply and redeemer balance, checking for underflow:\n     *  totalSupplyNew = totalSupply - redeemTokens\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n \n    (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n \n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < vars.redeemAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n    }\n \n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n \n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[redeemer] = vars.accountTokensNew;\n \n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, vars.redeemAmount);\n \n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n \n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n \n    return uint256(Error.NO_ERROR);\n  }\n```\n\n\n\n\n\n\n\nImage from blocksec\n\n**Attack tx:**\n\n[https://polygonscan.com/tx/0x0053490215baf541362fc78be0de98e3147f40223238d5b12512b3e26c0a2c2f](https://polygonscan.com/tx/0x0053490215baf541362fc78be0de98e3147f40223238d5b12512b3e26c0a2c2f)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1614774855999844352](https://twitter.com/peckshield/status/1614774855999844352)\n[https://twitter.com/BlockSecTeam/status/1614864084956254209](https://twitter.com/BlockSecTeam/status/1614864084956254209)\n\n[https://www.kalos.xyz/blog/midas-capital-hack-analysis](https://www.kalos.xyz/blog/midas-capital-hack-analysis)\n\n[https://blog.solidityscan.com/midas-capital-hack-analysis-ae59ed052729](https://blog.solidityscan.com/midas-capital-hack-analysis-ae59ed052729)\n\n[https://neptunemutual.com/blog/understanding-midas-capital-exploit/](https://neptunemutual.com/blog/understanding-midas-capital-exploit/)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png",
      "images/Untitled%202.png"
    ],
    "Lost": "$650k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Midas_exp.sol"
  },
  "UFDao": {
    "type": "Misconfiguration",
    "date": "2023-01-11",
    "rootCause": "\n\nIt\u2019s due to the incorrect parameter setting. The attacker bought a public offer of the UF Dao with 1:1 rate using USDC, then redeemed almost all in UF Dao.\n\n**Vulnerable code snippet:**\n\n```jsx\nfunction buyPublicOffer(address _dao, uint256 _lpAmount)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        require(\n            IFactory(factory).containsDao(_dao),\n            \"Shop: only DAO can sell LPs\"\n        );\n\n        PublicOffer memory publicOffer = publicOffers[_dao]; **// Vulnerable point**\n\n        require(publicOffer.isActive, \"Shop: this offer is disabled\");\n\n        IERC20(publicOffer.currency).safeTransferFrom(\n            msg.sender,\n            _dao,\n            (_lpAmount * publicOffer.rate) / 1e18   **// Vulnerable point**\n        );\n\n        address lp = IDao(_dao).lp();\n\n        bool b = ILP(lp).mint(msg.sender, _lpAmount);\n\n        require(b, \"Shop: mint error\");\n\n        return true;\n    }\n```\n\n\n\nImage from blocksec\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x933d19d7d822e84e34ca47ac733226367fbee0d9c0c89d88d431c4f99629d77a](https://bscscan.com/tx/0x933d19d7d822e84e34ca47ac733226367fbee0d9c0c89d88d431c4f99629d77a)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1613507804412940289](https://twitter.com/BlockSecTeam/status/1613507804412940289)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$90k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/UFDao_exp.sol"
  },
  "RoeFinance": {
    "type": "Oracle, lending",
    "date": "2023-01-11",
    "rootCause": " \n\nThe root cause is the limited liquidity of the pool, which resulted in the manipulation of the price oracle.\n\n**Vulnerable code snippet:**  \n\n[https://etherscan.io/address/0x574ff39184dee9e46f6c3229b95e0e0938e398d0#code](https://etherscan.io/address/0x574ff39184dee9e46f6c3229b95e0e0938e398d0#code)\n\n```solidity\nfunction borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external override whenNotPaused {\n    DataTypes.ReserveData storage reserve = _reserves[asset];\n\n    _executeBorrow(\n      ExecuteBorrowParams(\n        asset,\n        msg.sender,\n        onBehalfOf,\n        amount,\n        interestRateMode,\n        reserve.aTokenAddress,\n        referralCode,\n        true\n      )\n    );\n  }\nfunction _executeBorrow(ExecuteBorrowParams memory vars) internal {\n    DataTypes.ReserveData storage reserve = _reserves[vars.asset];\n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];\n\n    address oracle = _addressesProvider.getPriceOracle();\n\n    uint256 amountInETH =\n      IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\n        10**reserve.configuration.getDecimals()\n      );\n\n    ValidationLogic.validateBorrow(\n      vars.asset,\n      reserve,\n      vars.onBehalfOf,\n      vars.amount,\n      amountInETH,\n      vars.interestRateMode,\n      _maxStableRateBorrowSizePercent,\n      _reserves,\n      userConfig,\n      _reservesList,\n      _reservesCount,\n      oracle\n    );\n\n    reserve.updateState();\n\n    uint256 currentStableRate = 0;\n\n    bool isFirstBorrowing = false;\n    if (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {\n      currentStableRate = reserve.currentStableBorrowRate;\n\n      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        currentStableRate\n      );\n    } else {\n      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        vars.user,\n        vars.onBehalfOf,\n        vars.amount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    if (isFirstBorrowing) {\n      userConfig.setBorrowing(reserve.id, true);\n    }\n\n    reserve.updateInterestRates(\n      vars.asset,\n      vars.aTokenAddress,\n      0,\n      vars.releaseUnderlying ? vars.amount : 0\n    );\n\n    if (vars.releaseUnderlying) {\n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\n    }\n\n    emit Borrow(\n      vars.asset,\n      vars.user,\n      vars.onBehalfOf,\n      vars.amount,\n      vars.interestRateMode,\n      DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE\n        ? currentStableRate\n        : reserve.currentVariableBorrowRate,\n      vars.referralCode\n    );\n  }\n```\n\n**Attack tx:** \n\n[https://etherscan.io/tx/0x927b784148b60d5233e57287671cdf67d38e3e69e5b6d0ecacc7c1aeaa98985b](https://etherscan.io/tx/0x927b784148b60d5233e57287671cdf67d38e3e69e5b6d0ecacc7c1aeaa98985b)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1612701106982862849](https://twitter.com/BlockSecTeam/status/1613267000913960976)\n\n[https://quillaudits.medium.com/decoding-roe-finances-flash-loan-exploit-quillaudits-df8494e2090f#:~:text=On the 11th of January,the loss of %2480K](https://quillaudits.medium.com/decoding-roe-finances-flash-loan-exploit-quillaudits-df8494e2090f#:~:text=On%20the%2011th%20of%20January,the%20loss%20of%20%2480K).\n\n[https://blog.solidityscan.com/roe-finance-hack-analysis-price-manipulation-6993fbea0d7c](https://blog.solidityscan.com/roe-finance-hack-analysis-price-manipulation-6993fbea0d7c)",
    "images": [],
    "Lost": "$80k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RoeFinance_exp.sol"
  },
  "GDS": {
    "type": "Flashloans, staking",
    "date": "2023-01-03",
    "rootCause": " \n\nabused the LP Mining mechanism.\n\nThe attacker abused the LP Mining mechanism of the GDS token by first adding liquidity with flashloan, and then using multiple contracts to collect rewards.\n\nGDS token will reward the users who add liquidity to (GDS, USDT) pair in each epoch and the reward amount lpRewardAmount = x * LP token holding amount / LP token total supply (x is a global variable). Thus, the more staking amount, the more rewards users can get.\n\nBorrowing 2.38M USDT token with flashloan.\n\nSwapping 0.6M USDT token for 3.4M GDS token.\n\nAdding liquidity for PancakeSwap (1.7M USDT and 3.4M GDS) and get 2.2M LP tokens.\n\nCollecting rewards from GDS token contract and transferring LP tokens to another new contract.\n\nRepeating step 4 for more than 70 times.\n\nRemoving liquidity and repaying the flashloan.\n\n1.Borrowing 2.38M USDT token with flashloan.\n\n1. Swapping 0.6M USDT token for 3.4M GDS token.\n2. Adding liquidity for PancakeSwap (1.7M USDT and 3.4M GDS) and get 2.2M LP tokens.\n3. Collecting rewards from GDS token contract and transferring LP tokens to another new contract.\n\n5.Repeating step 4 for more than 70 times.\n\n6.Removing liquidity and repaying the flashloan.\n\n1.Borrowing 2.38M USDT token with flashloan.\n\n1. Swapping 0.6M USDT token for 3.4M GDS token.\n2. Adding liquidity for PancakeSwap (1.7M USDT and 3.4M GDS) and get 2.2M LP tokens.\n3. Collecting rewards from GDS token contract and transferring LP tokens to another new contract.\n\n5.Repeating step 4 for more than 70 times.\n\n6.Removing liquidity and repaying the flashloan.\n\n**Vulnerable code snippet:**\n\n```solidity\nfunction _settlementLpMining(address _from)internal {\n        uint256 _lpTokenBalance = IERC20(gdsUsdtPair).balanceOf(_from);\n        uint256 _lpTokenTotalSupply = IERC20(gdsUsdtPair).totalSupply();\n        if(lastEpoch[_from] >0 && currentEpoch > lastEpoch[_from] && _lpTokenBalance>0){\n           uint256 _totalRewardAmount= 0;\n           for (uint i = lastEpoch[_from]; i < currentEpoch; i++) {\n              _totalRewardAmount += everyEpochLpReward[i];\n              _totalRewardAmount += everyDayLpMiningAmount;\n           }\n\n           uint256 _lpRewardAmount =  _totalRewardAmount*_lpTokenBalance/_lpTokenTotalSupply;\n           _internalTransfer(lpPoolContract,_from,_lpRewardAmount,4);\n\n           lastEpoch[_from] = currentEpoch;\n        }\n\n        if(lastEpoch[_from] == 0 && _lpTokenBalance >0){\n            lastEpoch[_from] = currentEpoch;\n        }\n\n        if(_lpTokenBalance == 0){\n            lastEpoch[_from] = 0;\n        }\n    }\n\n```\n\n**Attack tx:** \n\n[https://bscscan.com/tx/0xf9b6cc083f6e0e41ce5e5dd65b294abf577ef47c7056d86315e5e53aa662251e](https://bscscan.com/tx/0xf9b6cc083f6e0e41ce5e5dd65b294abf577ef47c7056d86315e5e53aa662251e)\n[https://bscscan.com/tx/0x2bb704e0d158594f7373ec6e53dc9da6c6639f269207da8dab883fc3b5bf6694](https://bscscan.com/tx/0x2bb704e0d158594f7373ec6e53dc9da6c6639f269207da8dab883fc3b5bf6694)\n\n**Analysis:**\n\n[https://twitter.com/peckshield/status/1610095490368180224](https://twitter.com/peckshield/status/1610095490368180224)\n\n[https://twitter.com/BlockSecTeam/status/1610167174978760704](https://twitter.com/BlockSecTeam/status/1610167174978760704)",
    "images": [],
    "Lost": "$180k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/GDS_exp.sol"
  },
  "LavaLending": {
    "type": "Business Logic Flaw, Incorrect logic",
    "date": "2024-03-28",
    "rootCause": "1. Create an account with LPT tokens as collateral.\n2. Generate one-sided trading fees for the LPT.\n3. Use a different account to borrow and unwind the LPT tokens.\n4. The wrapper mistakenly includes the fees as assets, causing a significant increase in the LPT token price due to low actual liquidity.\n5. This boost in token price increases the first account's borrowing power, allowing it to borrow all the assets in the lending market.\n\nDonating assets via trading fees was identified as an attack vector. The wrapper attempts to prevent this by limiting trading fees to a maximum APR value, but this check was not triggered because only token0 fees exceeded the limit while token1 fees did not.\n\nVulnerable code snippet:\n\n[WrapperOracle | Address 0x7746872c6892bcfb4254390283719f2bd2d4da76 | Arbitrum One](https://arbiscan.io/address/0x7746872c6892bcfb4254390283719f2bd2d4da76#code)\n\nAttack tx:\n\n[0xcb1a2f5eeb1a767ea5 | Phalcon Explorer](https://phalcon.blocksec.com/explorer/tx/arbitrum/0xcb1a2f5eeb1a767ea5ccbc3665351fadc1af135d12a38c504f8f6eb997e9e603)\n\nAnalysis:\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:\n\n\n\n[BlockSec Phalcon on Twitter / X](https://twitter.com/Phalcon_xyz/status/1773546399713345965)\n\n[Lava Post-Mortem: March 28, 2024 - HackMD](https://hackmd.io/@LavaSecurity/03282024)",
    "images": [],
    "Lost": "340K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/LavaLending_exp.sol"
  },
  "Lifiprotocol": {
    "type": "Insufficient validation",
    "date": "2024-07-16",
    "rootCause": "arbitrary call\n\nVulnerable code snippet:\n\n[https://x.com/danielvf/status/1505689981385334784/photo/1](https://x.com/danielvf/status/1505689981385334784/photo/1)\n\n\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/eth/0xd82fe84e63b1aa52e1ce540582ee0895ba4a71ec5e7a632a3faa1aff3e763873](https://app.blocksec.com/explorer/tx/eth/0xd82fe84e63b1aa52e1ce540582ee0895ba4a71ec5e7a632a3faa1aff3e763873)\n\nAnalysis:\n\n[https://x.com/danielvf/status/1505689981385334784](https://x.com/danielvf/status/1505689981385334784)",
    "images": [
      "images/Lifiprotocol_Untitled.jpeg"
    ],
    "Lost": "$10M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/Lifiprotocol_exp.sol"
  },
  "Minterest": {
    "type": "Reentrancy",
    "date": "2024-07-14",
    "rootCause": "Attackers can lend tokens inside flashloan callbacks and then redeem more tokens after the flashloan.\n\nVulnerable code snippet:\n\n[https://x.com/shoucccc/status/1812659977464729991/photo/1](https://x.com/shoucccc/status/1812659977464729991/photo/1)\n\n\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/mantle/0xb3c4c313a8d3e2843c9e6e313b199d7339211cdc70c2eca9f4d88b1e155fd6bd](https://app.blocksec.com/explorer/tx/mantle/0xb3c4c313a8d3e2843c9e6e313b199d7339211cdc70c2eca9f4d88b1e155fd6bd)\n\nAnalysis:\n\n",
    "images": [
      "images/Minterest_Untitled.jpeg"
    ],
    "Lost": "$1.4M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/Minterest_exp.sol"
  },
  "GAX": {
    "type": "Access Control",
    "date": "2024-07-11",
    "rootCause": "attacker transferred 0 GAX and transferred out 49,583 USDT through the 0x6c99d7c8 method of the vulnerable contract.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xdb4b73Df2F6dE4AFCd3A883efE8b7a4B0763822b#code](https://bscscan.com/address/0xdb4b73Df2F6dE4AFCd3A883efE8b7a4B0763822b#code)\n\n\n\nAttack tx:\n\n[https://bscscan.com/tx/0x368f842e79a10bb163d98353711be58431a7cd06098d6f4b6cbbcd4c77b53108](https://bscscan.com/tx/0x368f842e79a10bb163d98353711be58431a7cd06098d6f4b6cbbcd4c77b53108)\n\nAnalysis:\n\n[https://x.com/EXVULSEC/status/1811348160851378333](https://x.com/EXVULSEC/status/1811348160851378333)",
    "images": [
      "images/GAX_Untitled.jpeg"
    ],
    "Lost": "$50K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/GAX_exp.sol"
  },
  "WIFCOIN_ETH": {
    "type": "Business Logic Flaw",
    "date": "2024-06-16",
    "rootCause": "Double claimEarned, Each time the `claimEarned` function is called, the code iterates through all the stakes and accumulates the calculated `_earned` amount. However, after calculating the rewards, the already calculated rewards are not marked as claimed. As a result, the next time `claimEarned` is called, it will recalculate those already claimed rewards, allowing users to claim rewards multiple times.\n\nVulnerable code snippet:\n\n```jsx\n    function claimEarned(uint256 _stakingId, uint256 _burnRate) public override {\n        require(_burnRate == 10 || _burnRate == 25 || _burnRate == 40, \"Invalid burn rate\");\n\n        uint256 _earned = 0;\n        Plan storage plan = plans[_stakingId];\n\n        require(stakes[_stakingId][msg.sender].length > 0, \"No stakes found\");\n\n        for (uint256 i = 0; i < stakes[_stakingId][msg.sender].length; i++) {\n            Staking storage _staking = stakes[_stakingId][msg.sender][i];\n            _earned = _earned.add(\n                _staking\n                    .amount\n                    .mul(plan.apr)\n                    .div(10000)\n            );\n\n            totalRewards = totalRewards.add(_earned);\n            totalRewardsPerPlan[_stakingId] = totalRewardsPerPlan[_stakingId].add(_earned);\n\n            totalRewardsPerWalletPerPlan[_stakingId][msg.sender] = totalRewardsPerWalletPerPlan[_stakingId][msg.sender].add(_earned);\n\n            totalEarnedRewardsPerWallet[msg.sender] += _earned;\n        \n            _staking.stakeAt = block.timestamp;\n        }\n\n        require(_earned > 0, \"There is no amount to claim\");\n\n        uint256 burnAmount = _earned.mul(_burnRate).div(100);\n        IERC20(stakingToken).transfer(BURN_ADDRESS, burnAmount);\n        IERC20(stakingToken).transfer(msg.sender, _earned.sub(burnAmount));\n    }\n\n  \n\n```\n\nAttack tx:\n\n[https://etherscan.io/tx/0x58424115c6576b19cfb78b0b7ff00e0c13daa06d259f2a67210c112731519e09](https://etherscan.io/tx/0x58424115c6576b19cfb78b0b7ff00e0c13daa06d259f2a67210c112731519e09)\n\nAnalysis:\n\n[https://x.com/ChainAegis/status/1802550962977964139](https://x.com/ChainAegis/status/1802550962977964139)\n\n",
    "images": [
      "images/Business_Screenshot_2024-06-25_at_4.59.58_PM.png"
    ],
    "Lost": "13189.92USD(WIF token)",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/WIFCOIN_ETH_exp.sol"
  },
  "JokInTheBox": {
    "type": "Business Logic Flaw",
    "date": "2024-06-11",
    "rootCause": "Hacker could unstake several times because \"unstake\" function doesn't check \"unstaked\" value. \n\nVulnerable code snippet:\n\n```jsx\n    function unstake(uint256 stakeIndex) external {\n        require(stakeIndex < stakes[msg.sender].length, \"Invalid stake index!\");\n        Stake memory currentStake = stakes[msg.sender][stakeIndex];\n\n        uint256 currentDay = getCurrentDay();\n\n        require(currentDay > currentStake.stakedDay + currentStake.lockPeriod, \"Lock period has not finalized!\");\n        stakes[msg.sender][stakeIndex].unstaked = true; <-- vulnerable point\n        stakes[msg.sender][stakeIndex].unstakedDay = currentDay;\n\n        totalStaked -= currentStake.amountStaked;\n        // Transfer back staked amount\n        require(jokToken.transfer(msg.sender, currentStake.amountStaked), \"Token transfer failed!\");\n\n        emit Unstake(msg.sender, currentStake.amountStaked, block.timestamp, currentStake.lockPeriod, stakeIndex);\n\n    }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/eth/0xe8277ef6ba8611bd12dc5a6e7ca4b984423bc0b3828159f83b466fdcf4fe054f](https://app.blocksec.com/explorer/tx/eth/0xe8277ef6ba8611bd12dc5a6e7ca4b984423bc0b3828159f83b466fdcf4fe054f)\n\nAnalysis:\n\n\n\n",
    "images": [
      "images/Business_Screenshot_2024-06-25_at_4.46.45_PM.png"
    ],
    "Lost": "9.2 eth",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/JokInTheBox_exp.sol"
  },
  "Bazaar": {
    "type": "Access Control, Lack of permission control",
    "date": "2024-06-10",
    "rootCause": "The root cause is no permission check in the `exitPool` function, allowing anyone to impersonate liquidity providers and drain the pool \n\nVulnerable code snippet:\n\n[https://blastscan.io/address/0xefb4e3Cc438eF2854727A7Df0d0baf844484EdaB](https://blastscan.io/address/0xefb4e3Cc438eF2854727A7Df0d0baf844484EdaB)\n\n```jsx\n    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request)\n        external\n        override\n        nonReentrant\n        registeredPool(poolId)\n    {\n        (address[] memory tokens, uint256[] memory balances,) = getPoolTokens(poolId);\n        require(tokens.length == TOKENS_LENGTH && tokens.length == request.tokens.length, \"mismatch tokens length\");\n\n        IBazaarLBP lbp = IBazaarLBP(_getPoolAddress(poolId));\n        (uint256[] memory amountsOut,) = lbp.onExitPool(poolId, sender, recipient, balances, 0, 0, request.userData); <-- vulnerable point\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 amountOut = amountsOut[i];\n            require(amountOut >= request.minAmountsOut[i], \"limit not reached\");\n            require(tokens[i] == _translateToErc20(request.tokens[i]), \"token mismatch\");\n\n            address token = tokens[i];\n            poolBalances[poolId][token] = poolBalances[poolId][token].sub(amountOut);\n\n            // use original address such that ETH is supported\n            _sendFunds(request.tokens[i], recipient, amountOut);\n        }\n    }\n   \n```\n\nAttack tx:\n\n[https://blastscan.io/tx/0x7fdd140f7631f62d62f7256ee4a38af51a4723ad5d66adc9b9685bf78f750f2d](https://blastscan.io/tx/0x7fdd140f7631f62d62f7256ee4a38af51a4723ad5d66adc9b9685bf78f750f2d)\n\nupdate: refunded 90%\n\nAnalysis:\n\n[https://x.com/shoucccc/status/1800353122159833195](https://x.com/shoucccc/status/1800353122159833195)\n\n\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Insufficient_Screenshot_2024-06-25_at_4.21.16_PM.png"
    ],
    "Lost": "1.4M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/Bazaar_exp.sol"
  },
  "YYStoken": {
    "type": "Business Logic Flaw",
    "date": "2024-06-08",
    "rootCause": "Root cause is the same as STM token exploit, wrong calculation of liquidity amount to remove in \"sell\" function.\n\nVulnerable code snippet:\n\nhttps://bscscan.com/address/0xcC0F0f41f4c4c17493517dd6c6d9DD1aDb134Fc9#code\n\n```jsx\n    function sell(uint256 amount) external {\n        eve_token_erc20.transferFrom(msg.sender, address(this), amount);\n        (, uint256 r1, ) = inner_pair.getReserves();  <-- vulnerable point\n        uint256 lpAmount = amount*inner_pair.totalSupply()/(2*r1);\n        uniswapV2Router.removeLiquidity(address(usdt_token_erc20),address(eve_token_erc20),lpAmount,0,0,msg.sender,block.timestamp);\n    }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0x397a09af6494c0bfcd89e010f5dd65d90f3ee1cf1ff813ce5b0c1d42a1c8dec9](https://app.blocksec.com/explorer/tx/bsc/0x397a09af6494c0bfcd89e010f5dd65d90f3ee1cf1ff813ce5b0c1d42a1c8dec9)\n\nAnalysis:\n\n\n\nIt's similar to STM token, used \"sell\" function to drain pool. He swapped large amount of USDT to YYS, and in first \"sell\" function, he could remove some liquidity with a few YYS tokens, decrease k(x*y) value. Then swapped YYS to USDT\n\n\n\n[https://www.notion.so](https://www.notion.so)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$28K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/YYS_exp.sol"
  },
  "MineSTM": {
    "type": "Business Logic Flaw",
    "date": "2024-06-06",
    "rootCause": "Incorrect uses reserve of pair for liquidity calculation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xb7D0A1aDaFA3e9e8D8e244C20B6277Bee17a09b6#code](https://bscscan.com/address/0xb7D0A1aDaFA3e9e8D8e244C20B6277Bee17a09b6#code)\n\n```jsx\n    function sell(uint256 amount) external {\n        eve_token_erc20.transferFrom(msg.sender, address(this), amount);\n        (, uint256 r1, ) = inner_pair.getReserves(); <-- vulnerable point\n        uint256 lpAmount = amount*inner_pair.totalSupply()/(2*r1);\n        uniswapV2Router.removeLiquidity(address(usdt_token_erc20),address(eve_token_erc20),lpAmount,0,0,msg.sender,block.timestamp);\n    }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0x849ed7f687cc2ebd1f7c4bed0849893e829a74f512b7f4a18aea39a3ef4d83b1](https://app.blocksec.com/explorer/tx/bsc/0x849ed7f687cc2ebd1f7c4bed0849893e829a74f512b7f4a18aea39a3ef4d83b1)\n\nAnalysis:\n\n\n\nThere's \"sell\" function in \"MineSTM\" contract, and it uses reserve of pair for liquidity calculation. Hacker manipulated reserve amount by swapping large amount of tokens, and then called \"sell\" function to get lots of tokens.\n\n",
    "images": [
      "images/IT_Screenshot_2024-07-02_at_12.49.04_PM.png"
    ],
    "Lost": "$13.8K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/MineSTM_exp.sol"
  },
  "VeloCore": {
    "type": "Access Control, Lack of permission control",
    "date": "2024-06-01",
    "rootCause": "lacks permission verification (velocore__execute)\n\nVulnerable code snippet:\n\n[https://lineascan.build/address/0xb7f6354b2cfd3018b3261fbc63248a56a24ae91a](https://lineascan.build/address/0xb7f6354b2cfd3018b3261fbc63248a56a24ae91a)\n\n\n\n\n\nAttack tx:\n\n[https://lineascan.build/tx/0xed11d5b013bf3296b1507da38b7bcb97845dd037d33d3d1b0c5e763889cdbed1](https://lineascan.build/tx/0xed11d5b013bf3296b1507da38b7bcb97845dd037d33d3d1b0c5e763889cdbed1)\n\nAnalysis:\n\nThe LP Pool lacks permission verification. The attacker directly invoke the velocore__execute function (0xec378808) of the LP contract with a carefully constructed parameter to manipulate the feeMultiplier parameter of the contract.\n\n[https://x.com/BeosinAlert/status/1797247874528645333](https://x.com/BeosinAlert/status/1797247874528645333)\n\n[https://blog.solidityscan.com/velocore-hack-analysis-642a13630be0](https://blog.solidityscan.com/velocore-hack-analysis-642a13630be0)",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "$6.88M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-06/Velocore_exp.sol"
  },
  "MixedSwapRouter": {
    "type": "Arbitrary call",
    "date": "2024-05-31",
    "rootCause": "Arbitrary Call, controllable data.pool.\n\nVulnerable code snippet:\n\n[https://arbiscan.io/address/0x58637aaac44e2a2f190d9e1976e236d86d691542](https://arbiscan.io/address/0x58637aaac44e2a2f190d9e1976e236d86d691542)\n\n```jsx\n    //AlgebraSwap v3 callback\n    function algebraSwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata data <-- vulnerable point\n    ) public {\n        _processV3Callback(amount0, amount1, data);\n    }\n    \n       function _processV3Callback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) internal {\n        require(_reentrancyGuardEntered(), \"FBD\");\n        require(amount0Delta > 0 || amount1Delta > 0, \"Invalid amount\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        require(msg.sender == data.pool, \"Invalid caller\");\n        (address tokenIn, address tokenOut, ) = data.path.decodeFirstPool();\n        _validatePoolTokens(\n            tokenIn,\n            tokenOut,\n            data.pool\n        );\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        } else {\n            // either initiate the next swap or pay\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                _exactOutputInternalV3(\n                    amountToPay,\n                    msg.sender,\n                    0,\n                    data. <-- vulnerable point\n                );\n            } else {\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\n            }\n        }\n    }\n\n    /// @dev Performs a single exact output swap\n    function _exactOutputInternalV3(\n        uint256 amountOut,\n        address recipient,\n        uint160 sqrtPriceLimitX96,\n        SwapCallbackData memory data.  \n    ) private returns (uint256 amountIn) {\n        require(data.pool != address(0), \"InvalidPool\");\n        // allow swapping to the router address with address 0\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenA, address tokenB, ) = data.path.decodeFirstPool();\n        _validatePoolTokens(\n            tokenA,\n            tokenB,\n            data.pool.  \n        );\n        bool zeroForOne = tokenA < tokenB;\n\n        (int256 amount0Delta, int256 amount1Delta) = IUniswap(data.pool).swap(    <-- data.pool vulnerable point\n                recipient,\n                zeroForOne,\n                -amountOut.toInt256(),\n                sqrtPriceLimitX96 == 0\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                    : sqrtPriceLimitX96,\n                abi.encode(data)\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it's technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\n    }\n\n```\n\nAttack tx:\n\n[https://arbiscan.io/tx/0xf57f041cb6d8a10e11edab50b84e49b59ff834c7d114d1e049cedd654c36194d](https://arbiscan.io/tx/0xf57f041cb6d8a10e11edab50b84e49b59ff834c7d114d1e049cedd654c36194d)\n\n[https://app.blocksec.com/explorer/tx/arbitrum/0xf57f041cb6d8a10e11edab50b84e49b59ff834c7d114d1e049cedd654c36194d](https://app.blocksec.com/explorer/tx/arbitrum/0xf57f041cb6d8a10e11edab50b84e49b59ff834c7d114d1e049cedd654c36194d)\n\nAnalysis:\n\n",
    "images": [
      "images/IT_Screenshot_2024-07-02_at_2.15.44_PM.png"
    ],
    "Lost": ">10700USD(WINR token)",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/MixedSwapRouter_exp.sol"
  },
  "SCROLL": {
    "type": "Under/Overflow",
    "date": "2024-05-29",
    "rootCause": "Integer Underflow**\n\nVulnerable code snippet:\n\n\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/eth/0x661505c39efe1174da44e0548158db95e8e71ce867d5b7190b9eabc9f314fe91](https://app.blocksec.com/explorer/tx/eth/0x661505c39efe1174da44e0548158db95e8e71ce867d5b7190b9eabc9f314fe91)\n\nAnalysis:\n\n\n\nAnyone can transfer tokens to owner address even though he has no tokens. I have simulated it. Strange! According to decompile, solidity version is 0.8.19. How is underflow possible?\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png"
    ],
    "Lost": "76 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/SCROLL_exp.sol"
  },
  "MetaDragon": {
    "type": "Business Logic Flaw",
    "date": "2024-05-29",
    "rootCause": "Incorrect logic check\n\n`if (to == address(this) || to == erc721) {transform(value);}` allows for unrestricted minting\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xEF1f39d8391cdDcaee62b8b383cB992F46a6ce4f](https://bscscan.com/address/0xEF1f39d8391cdDcaee62b8b383cB992F46a6ce4f)\n\n```jsx\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n    function _update(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        // if to is this contract, transform\n        if (!isValidTokenId(value)) {\n            super._update(from, to, value);\n        }\n\n        if (to == address(this) || to == erc721) { <-- vulnerable point\n            transform(value);\n        } else {\n            if (isValidTokenId(value)) {\n                // erc721 transfer\n                // check auth\n                if (from != address(0)) {\n                    require(\n                        iERC721CheckAuth(erc721).isAuthorized(\n                            from,\n                            msg.sender,\n                            value\n                        ),\n                        \"P404: not authorized\"\n                    );\n                }\n                IERC721(erc721).safeTransferFrom(from, to, value);\n            }\n        }\n    }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0x3ad998a01ad1f1bbe6dba6a08e658c1749dabfa4a07da20ded3c73bcd6970d20](https://app.blocksec.com/explorer/tx/bsc/0x3ad998a01ad1f1bbe6dba6a08e658c1749dabfa4a07da20ded3c73bcd6970d20)\n\nAnalysis:\n\n[https://x.com/Phalcon_xyz/status/1795746828064854497](https://x.com/Phalcon_xyz/status/1795746828064854497)\n\n",
    "images": [
      "images/Lack_Screenshot_2024-07-02_at_3.24.08_PM.png"
    ],
    "Lost": "$180k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/MetaDragon_exp.sol"
  },
  "RedKeysCoin": {
    "type": "Weak RNG",
    "date": "2024-05-27",
    "rootCause": "Due to weak RNG, we can estimate bet result by calculating the result of the function randomNumber\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x71e3056aa4985de9f5441f079e6c74454a3c95f0](https://bscscan.com/address/0x71e3056aa4985de9f5441f079e6c74454a3c95f0)\n\n```jsx\n function randomNumber() internal view returns (uint256) { <--vulnerable point\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    counter +\n                        block.timestamp +\n                        block.prevrandao +\n                        ((\n                            uint256(keccak256(abi.encodePacked(block.coinbase)))\n                        ) / (block.timestamp)) +\n                        block.gaslimit +\n                        ((uint256(keccak256(abi.encodePacked(msg.sender)))) /\n                            (block.timestamp)) +\n                        block.number\n                )\n            )\n        );\n\n        return (seed - ((seed / 1000) * 1000));\n    }\n```\n\nAttack tx:\n\n[https://bscscan.com/tx/0x8d5fb97b35b830f8addcf31c8e0c6135f15bbc2163d891a3701ada0ad654d427](https://bscscan.com/tx/0x8d5fb97b35b830f8addcf31c8e0c6135f15bbc2163d891a3701ada0ad654d427)\n\nAnalysis:\n\n[https://x.com/SlowMist_Team/status/1794975336192438494](https://x.com/SlowMist_Team/status/1794975336192438494)\n\n",
    "images": [
      "images/Weak_Screenshot_2024-07-02_at_5.29.12_PM.png"
    ],
    "Lost": "$12K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/RedKeysCoin_exp.sol"
  },
  "NORMIE": {
    "type": "Business Logic Flaw, skim",
    "date": "2024-05-26",
    "rootCause": "Improper verification mechanism for assigning the \"premarket user\" role. The system only checks if the transfer amount equals the balance of the `teamWalletAddress`, which is public information and easily exploitable.\n\nVulnerable code snippet:\n\n[https://vscode.blockscan.com/base/0x7f12d13b34f5f4f0a9449c16bcd42f0da47af200](https://vscode.blockscan.com/base/0x7f12d13b34f5f4f0a9449c16bcd42f0da47af200)\n\n```jsx\nfunction _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private returns (bool) {\n            ... // code\n            if (\n                isMarketPair[sender] &&\n                !isExcludedFromFee[recipient] &&\n                premarket_user[recipient] // checks that the recipient is a \"premarket user\"\n            ) {\n                _balances[address(this)] = _balances[address(this)].add(amount); // contract balance is increased\n            }\n            ... // code \n            _balances[sender] = _balances[sender].sub(\n                amount,\n                \"Insufficient Balance\"\n            ); // sender balance decreased\n            uint256 finalAmount = (isExcludedFromFee[sender] ||\n                isExcludedFromFee[recipient])\n                ? amount\n                : takeFee(sender, recipient, amount);\n            if (checkWalletLimit && !isWalletLimitExempt[recipient])\n                require(balanceOf(recipient).add(finalAmount) <= _walletMax);\n            _balances[recipient] = _balances[recipient].add(finalAmount); // recipient balance increased\n            _get_premarket_user(recipient, amount); // <--VUlNERABLE POINT\n            emit Transfer(sender, recipient, finalAmount);\n            return true;\n        \n    }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/base/0xa618933a0e0ffd0b9f4f0835cc94e523d0941032821692c01aa96cd6f80fc3fd](https://app.blocksec.com/explorer/tx/base/0xa618933a0e0ffd0b9f4f0835cc94e523d0941032821692c01aa96cd6f80fc3fd)\n\nAnalysis:\n\n[https://extropy-io.medium.com/block-forensics-an-in-depth-analysis-of-the-normie-memecoin-incident-0daf5baed08b](https://extropy-io.medium.com/block-forensics-an-in-depth-analysis-of-the-normie-memecoin-incident-0daf5baed08b)",
    "images": [],
    "Lost": "$490K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/NORMIE_exp.sol"
  },
  "Burner": {
    "type": "Business Logic Flaw, Sandwich",
    "date": "2024-05-22",
    "rootCause": "Incorrect logic so sandwich.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x4d4d05e1205e3A412ae1469C99e0d954113aa76F#code](https://etherscan.io/address/0x4d4d05e1205e3A412ae1469C99e0d954113aa76F#code)\n\n```jsx\n function burn() public {\n        require(!paused, 'cannot burn when paused');\n        uint total = token.balanceOf(address(this));\n        uint toBurn = total.mul(percentageToBurn).div(100);\n        token.burn(toBurn, '');\n        uint notBurned = token.balanceOf(address(this));\n        require(token.transfer(unburnedDestination, notBurned), 'cannot transfer unburned tokens');\n        emit Burn(toBurn, notBurned);\n    }\nfunction convertAndBurn(address [] calldata tokens) external {\n        for (uint i = 0; i < tokens.length; i++) {\n            _convert(tokens[i]);\n        }\n        burn();\n    }\n\n    function _convert(address srcToken) internal {\n        uint srcAmount;\n        uint converted;\n        if (srcToken == ETHER || srcToken == address(0)) {\n            srcAmount = address(this).balance;\n            converted = kyberNetwork.trade\n                .value(srcAmount)(ETHER, srcAmount, address(token), address(uint160(address(this))), BIG_LIMIT, 1, kyberFeeWallet); **<-- vulnerable point**\n        } else {\n            srcAmount = IERC20(srcToken).balanceOf(address(this));\n            if (IERC20(srcToken).allowance(address(this), address(kyberNetwork)) > 0) {\n                IERC20(srcToken).safeApprove(address(kyberNetwork), 0);\n            }\n            IERC20(srcToken).safeApprove(address(kyberNetwork), srcAmount);\n            converted = kyberNetwork.trade(srcToken, srcAmount, address(token), address(uint160(address(this))), BIG_LIMIT, 1, kyberFeeWallet);\n        }\n        emit TokenTrade(srcToken, srcAmount, converted);\n    }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/eth/0x3bba4fb6de00dd38df3ad68e51c19fe575a95a296e0632028f101c5199b6f71](https://app.blocksec.com/explorer/tx/eth/0x3bba4fb6de00dd38df3ad68e51c19fe575a95a296e0632028f101c5199b6f71)\n\nAnalysis:\n\n[https://medium.com/@daleewong/burner-exploit-analysis-0733a69ddc27](https://medium.com/@daleewong/burner-exploit-analysis-0733a69ddc27)",
    "images": [],
    "Lost": "1.7 eth",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/Burner_exp.sol"
  },
  "TCH": {
    "type": "Signature",
    "date": "2024-05-16",
    "rootCause": "Signature Malleability Vulnerability,   **0, 1** instead of 27, 28 (previous sigs) to achieve malleability. As a result the attacker burned lots of TCH tokens owned by the PancakeSwap pair, which allowed him to manipulate the price in the pool and take the profit.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x5d78cfc8732fd328015c9b73699de9556ef06e8e](https://bscscan.com/address/0x5d78cfc8732fd328015c9b73699de9556ef06e8e)\n\n```jsx\n    function burnToken(uint256 amount, uint256 nonce, bytes memory signature) external {\n        bytes32 signatureHash = keccak256(signature);\n        require(!usedSignatures[signatureHash], \"Signature has already been used\");\n        require(isAuthorizedSigner(amount, nonce, signature), \"Invalid or unauthorized signature\");\n        usedSignatures[signatureHash] = true;\n        uint256 deflationAmount = balances[uniswapV2Pair] * deflationFee / 10000;\n        balances[uniswapV2Pair] -= deflationAmount;\n        balances[address(0xdead)] += deflationAmount;\n        emit Transfer(uniswapV2Pair, address(0xdead), deflationAmount);\n        IUniswapV2Pair(uniswapV2Pair).sync();\n    }\n    function isAuthorizedSigner(uint256 amount, uint256 nonce, bytes memory signature) internal view returns (bool) {\n        bytes32 message = keccak256(abi.encodePacked(address(this), amount, nonce));\n        bytes32 ethSignedMessage = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\n        return recoverSigner(ethSignedMessage, signature) == authorizedSigner;\n    }\n    function recoverSigner(bytes32 ethSignedMessage, bytes memory signature) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        return ecrecover(ethSignedMessage, v, r, s); <-- vulnerable point if v either 27 or 28 will return 0\n    }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0x316c35d483b72700e6f4984650d217304146b3732bb148e32fa7f8017843eb24](https://app.blocksec.com/explorer/tx/bsc/0x316c35d483b72700e6f4984650d217304146b3732bb148e32fa7f8017843eb24)\n\nAnalysis:\n\n[https://x.com/DecurityHQ/status/1791180322882629713](https://x.com/DecurityHQ/status/1791180322882629713)\n\n\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/IT_Screenshot_2024-07-03_at_1.54.46_PM.png"
    ],
    "Lost": "$18K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/TCH_exp.sol"
  },
  "Sonne Finance": {
    "type": "Precision",
    "date": "2024-05-14",
    "rootCause": "Compound v2 forks bug. first deposit\n\nVulnerable code snippet:\n\n[https://optimistic.etherscan.io/address/0xe3b81318b1b6776f0877c3770afddff97b9f5fe5](https://optimistic.etherscan.io/address/0xe3b81318b1b6776f0877c3770afddff97b9f5fe5)\n\n```jsx\n    function exchangeRateStoredInternal()\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves = totalCash +\n                totalBorrows -\n                totalReserves;\n            uint256 exchangeRate = (cashPlusBorrowsMinusReserves * expScale) /\n                _totalSupply; <-- vulnerable point\n\n            return exchangeRate;\n        }\n```\n\n\n\nAttack tx:\n\n[https://optimistic.etherscan.io/tx/0x45c0ccfd3ca1b4a937feebcb0f5a166c409c9e403070808835d41da40732db96](https://optimistic.etherscan.io/tx/0x45c0ccfd3ca1b4a937feebcb0f5a166c409c9e403070808835d41da40732db96)\n\n[https://optimistic.etherscan.io/tx/0x9312ae377d7ebdf3c7c3a86f80514878deb5df51aad38b6191d55db53e42b7f0](https://optimistic.etherscan.io/tx/0x9312ae377d7ebdf3c7c3a86f80514878deb5df51aad38b6191d55db53e42b7f0)\n\nAnalysis:\n\n[https://www.quillaudits.com/blog/hack-analysis/sonne-finance-hack](https://www.quillaudits.com/blog/hack-analysis/sonne-finance-hack)\n\n[https://www.quillaudits.com/blog/hack-analysis/sonne-finance-hack](https://www.quillaudits.com/blog/hack-analysis/sonne-finance-hack)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$20M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/Sonne_exp.sol"
  },
  "PredyFinance": {
    "type": "Reentrancy",
    "date": "2024-05-14",
    "rootCause": "Reentrancy**\n\nVulnerable code snippet:\n\n[https://arbiscan.io/address/0x7b8b944ab2f24c829504a7a6d70fce5298f2147c#code](https://arbiscan.io/address/0x7b8b944ab2f24c829504a7a6d70fce5298f2147c#code)\n\n```jsx\n    function trade(\n        GlobalDataLibrary.GlobalData storage globalData,\n        IPredyPool.TradeParams memory tradeParams,\n        bytes memory settlementData\n    ) external returns (IPredyPool.TradeResult memory tradeResult) { <-- no reentrancy guard\n        DataType.PairStatus storage pairStatus = globalData.pairs[tradeParams.pairId];\n\n        // update interest growth\n        ApplyInterestLib.applyInterestForToken(globalData.pairs, tradeParams.pairId);\n\n        // update rebalance interest growth\n        Perp.updateRebalanceInterestGrowth(pairStatus, pairStatus.sqrtAssetStatus);\n\n        tradeResult = Trade.trade(globalData, tradeParams, settlementData);\n\n        globalData.vaults[tradeParams.vaultId].margin +=\n            tradeResult.fee + tradeResult.payoff.perpPayoff + tradeResult.payoff.sqrtPayoff;\n\n        (tradeResult.minMargin,,, tradeResult.sqrtTwap) = PositionCalculator.calculateMinDeposit(\n            pairStatus, globalData.vaults[tradeParams.vaultId], DataType.FeeAmount(0, 0)\n        );\n\n        // The caller deposits or withdraws margin from the callback that is called below.\n        callTradeAfterCallback(globalData, tradeParams, tradeResult); **<-- vulnerable point**\n\n        // check vault safety\n        tradeResult.minMargin =\n            PositionCalculator.checkSafe(pairStatus, globalData.vaults[tradeParams.vaultId], DataType.FeeAmount(0, 0));\n\n        emit PositionUpdated(\n            tradeParams.vaultId,\n            tradeParams.pairId,\n            tradeParams.tradeAmount,\n            tradeParams.tradeAmountSqrt,\n            tradeResult.payoff,\n            tradeResult.fee\n        );\n    }\n    function callTradeAfterCallback(\n        GlobalDataLibrary.GlobalData storage globalData,\n        IPredyPool.TradeParams memory tradeParams,\n        IPredyPool.TradeResult memory tradeResult\n    ) internal {\n        globalData.initializeLock(tradeParams.pairId);\n\n        IHooks(msg.sender).predyTradeAfterCallback(tradeParams, tradeResult); <-- vulnerable callback point\n\n        (int256 marginAmountUpdate, int256 settledBaseAmount) = globalData.finalizeLock();\n\n        if (settledBaseAmount != 0) {\n            revert IPredyPool.BaseTokenNotSettled();\n        }\n\n        globalData.vaults[tradeParams.vaultId].margin += marginAmountUpdate;\n\n        emit MarginUpdated(tradeParams.vaultId, marginAmountUpdate);\n    }\n}\n```\n\nAttack tx:\n\n[https://arbiscan.io/tx/0xbe163f651d23f0c9e4d4a443c0cc163134a31a1c2761b60188adcfd33178f50f](https://arbiscan.io/tx/0xbe163f651d23f0c9e4d4a443c0cc163134a31a1c2761b60188adcfd33178f50f)\n\nAnalysis:\n\n[https://predyfinance.medium.com/postmortem-report-on-the-details-of-the-events-of-may-14-2024-8690508c820b](https://predyfinance.medium.com/postmortem-report-on-the-details-of-the-events-of-may-14-2024-8690508c820b)\n\n",
    "images": [
      "images/EAC_Screenshot_2024-07-03_at_2.09.47_PM.png"
    ],
    "Lost": "$464K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/PredyFinance_exp.sol"
  },
  "GFOX": {
    "type": "Access Control",
    "date": "2024-05-10",
    "rootCause": "attacker can set merkleroot.\n\n```\n    // set the merkle root\n    bytes32 root = _merkleRoot(address(this), amount);\n    victim.setMerkleRoot(root);\n    // claim the GFOX\n    victim.claim(address(this), amount, new bytes32[](0));\n\n```\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x47c4b3144de2c87a458d510c0c0911d1903d1686](https://etherscan.io/address/0x47c4b3144de2c87a458d510c0c0911d1903d1686)\n\n```jsx\nv4 = stor_1_0_19.setMerkleRoot(keccak256(address(this), v3)).gas(msg.gas);\n```\n\nAttack tx:\n\n[https://etherscan.io/tx/0x12fe79f1de8aed0ba947cec4dce5d33368d649903cb45a5d3e915cc459e751fc](https://etherscan.io/tx/0x12fe79f1de8aed0ba947cec4dce5d33368d649903cb45a5d3e915cc459e751fc)\n\nAnalysis:\n\n[https://x.com/CertiKAlert/status/1788751142144401886](https://x.com/CertiKAlert/status/1788751142144401886)",
    "images": [],
    "Lost": "330K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/GFOX_exp.sol"
  },
  "TSURU": {
    "type": "Access Control, Insufficient validation",
    "date": "2024-05-10",
    "rootCause": "Everyone can call this function to get free tokens. No access control\n\nVulnerable code snippet:\n\n[https://basescan.org/address/0x75Ac62EA5D058A7F88f0C3a5F8f73195277c93dA#code](https://basescan.org/address/0x75Ac62EA5D058A7F88f0C3a5F8f73195277c93dA#code)\n\n```jsx\n    function onERC1155Received( <--vulnerable point\n        address,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata\n    ) external override nonReentrant returns (bytes4) {\n        require(id == tokenID, \"Token ID does not match\");\n        \n        if (msg.sender == address(erc1155Contract)) {\n            return this.onERC1155Received.selector;\n        }\n\n        _safeMint(from, amount * ERC1155_RATIO); // Adjust minting based on the ERC1155_RATIO\n        return this.onERC1155Received.selector;\n    }\n```\n\nAttack tx:\n\n[https://basescan.org/tx/0xe63a8df8759f41937432cd34c590d85af61b3343cf438796c6ed2c8f5b906f62](https://basescan.org/tx/0xe63a8df8759f41937432cd34c590d85af61b3343cf438796c6ed2c8f5b906f62)\n\n[https://app.blocksec.com/explorer/tx/base/0xe63a8df8759f41937432cd34c590d85af61b3343cf438796c6ed2c8f5b906f62](https://app.blocksec.com/explorer/tx/base/0xe63a8df8759f41937432cd34c590d85af61b3343cf438796c6ed2c8f5b906f62)\n\nAnalysis:\n\n[https://x.com/shoucccc/status/1788941548929110416](https://x.com/shoucccc/status/1788941548929110416)\n\n",
    "images": [
      "images/No_Screenshot_2024-07-03_at_5.27.16_PM.png"
    ],
    "Lost": "140K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/TSURU_exp.sol"
  },
  "GPU": {
    "type": "Business Logic Flaw",
    "date": "2024-05-08",
    "rootCause": "self transfer\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xf51cbf9f8e089ca48e454eb79731037a405972ce](https://bscscan.com/address/0xf51cbf9f8e089ca48e454eb79731037a405972ce)\n\n```jsx\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderAmount = _balances[sender]; <-- vulnerable point\n        uint256 recipientAmount = _balances[recipient]; <-- vulnerable point\n        require(senderAmount >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderAmount.sub(amount);\n        _balances[recipient] = recipientAmount.add(amount); <-- vulnerable point\n        emit Transfer(sender, recipient, amount);\n    }\n```\n\nAttack tx:\n\n[https://bscscan.com/tx/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb](https://bscscan.com/tx/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb)\n\n[https://app.blocksec.com/explorer/tx/bsc/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb](https://app.blocksec.com/explorer/tx/bsc/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb)\n\nAnalysis:\n\n[https://blog.solidityscan.com/gpu-hack-analysis-bf11f7c00534](https://blog.solidityscan.com/gpu-hack-analysis-bf11f7c00534)\n\n",
    "images": [
      "images/Self_Screenshot_2024-07-03_at_5.32.35_PM.png"
    ],
    "Lost": "32K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/GPU_exp.sol"
  },
  "SATURN": {
    "type": "Price Manipulation",
    "date": "2024-05-07",
    "rootCause": "The vulnerability in this case occurred due to the synchronization (`sync`) operation being performed on the PancakeSwap (WBNB-SATURN) pool before processing the incoming token transfers. This led to distorted reserves in the PancakeSwap (WBNB-SATURN) pool and a significant increase in the value of SATURN tokens.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x9BDF251435cBC6774c7796632e9C80B233055b93#code](https://bscscan.com/address/0x9BDF251435cBC6774c7796632e9C80B233055b93#code)\n\nAttack tx:\n\n[https://bscscan.com/tx/0x948132f219c0a1adbffbee5d9dc63bec676dd69341a6eca23790632cb9475312](https://bscscan.com/tx/0x948132f219c0a1adbffbee5d9dc63bec676dd69341a6eca23790632cb9475312)\n\n[https://app.blocksec.com/explorer/tx/bsc/0x948132f219c0a1adbffbee5d9dc63bec676dd69341a6eca23790632cb9475312](https://app.blocksec.com/explorer/tx/bsc/0x948132f219c0a1adbffbee5d9dc63bec676dd69341a6eca23790632cb9475312)\n\nAnalysis:\n\n[https://lunaray.medium.com/saturn-hack-analysis-187eea27725b](https://lunaray.medium.com/saturn-hack-analysis-187eea27725b)",
    "images": [],
    "Lost": "15 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/SATURN_exp.sol"
  },
  "OSN": {
    "type": "Business Logic Flaw, Reward",
    "date": "2024-05-06",
    "rootCause": "Distribution contract did not check the LP hold time or whether the reciever is contract or not\n\nVulnerable code snippet:\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0xc7927a68464ebab1c0b1af58a5466da88f09ba9b30e6c255b46b1bc2e7d1bf09](https://app.blocksec.com/explorer/tx/bsc/0xc7927a68464ebab1c0b1af58a5466da88f09ba9b30e6c255b46b1bc2e7d1bf09)\n\n// TX1:create help contract,split money : [https://app.blocksec.com/explorer/tx/bsc/0xbf22eabb5db8785642ba17930bddef48d0d1bb94ebd1e03e7faa6f2a3d1a5540](https://app.blocksec.com/explorer/tx/bsc/0xbf22eabb5db8785642ba17930bddef48d0d1bb94ebd1e03e7faa6f2a3d1a5540)\n// TX2:help contract add Liq : [https://app.blocksec.com/explorer/tx/bsc/0x69c64b226f8bf06216cc665ad5e3777ad1b120909326f120f0816ac65a9099c0](https://app.blocksec.com/explorer/tx/bsc/0x69c64b226f8bf06216cc665ad5e3777ad1b120909326f120f0816ac65a9099c0)\n\nAttacker: [https://bscscan.com/address/0x810f4c6ae97bcc66da5ae6383cc31bd3670f6d13](https://bscscan.com/address/0x810f4c6ae97bcc66da5ae6383cc31bd3670f6d13)\n\nAnalysis:\n\n[https://x.com/SlowMist_Team/status/1787330586857861564](https://x.com/SlowMist_Team/status/1787330586857861564)\n\n",
    "images": [
      "images/Reward_Screenshot_2024-07-04_at_10.03.25_AM.png"
    ],
    "Lost": "109K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-05/OSN_exp.sol"
  },
  "Yield": {
    "type": "Business Logic Flaw",
    "date": "2024-04-30",
    "rootCause": "This vulnerability is associated with the burning shares functionality\u00a0`burn(address to)`\u00a0of the strategy contract which is responsible for burning the strategy tokens and allowing the user to withdraw the LP tokens.\n\nVulnerable code snippet:\n\n[https://arbiscan.io/address/0x3b4ffd93ce5fcf97e61aa8275ec241c76cc01a47](https://arbiscan.io/address/0x3b4ffd93ce5fcf97e61aa8275ec241c76cc01a47)\n\n```jsx\nfunction burn(address to) external isState(State.INVESTED)\n    returns (uint256 poolTokensObtained)\n{\n  // Caching\n   IPool pool_ = pool;\n   uint256 poolCached_ = poolCached;\n   uint256 totalSupply_ = _totalSupply;\n\n   // Burn strategy tokens\n   uint256 burnt = _balanceOf[address(this)];\n   _burn(address(this), burnt);\n\n   poolTokensObtained = pool.balanceOf(address(this)) * burnt / totalSupply_;\n   pool_.safeTransfer(address(to), poolTokensObtained);\n\n   // Update pool cache\n   poolCached = poolCached_ - poolTokensObtained;\n}\n```\n\nAttack tx:\n\n[https://arbiscan.io/tx/0x6caa65b3fc5c8d4c7104574c3a15cd6208f742f9ada7d81ba027b20473137705](https://arbiscan.io/tx/0x6caa65b3fc5c8d4c7104574c3a15cd6208f742f9ada7d81ba027b20473137705)\n\nAnalysis:\n\n[https://medium.com/immunefi/yield-protocol-logic-error-bugfix-review-7b86741e6f50](https://medium.com/immunefi/yield-protocol-logic-error-bugfix-review-7b86741e6f50)\n\n",
    "images": [
      "images/Business_Screenshot_2024-07-04_at_10.25.36_AM.png"
    ],
    "Lost": "181K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Yield_exp.sol"
  },
  "PikeFinance": {
    "type": "uninitialized",
    "date": "2024-04-30",
    "rootCause": "uninitialized proxy\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xfc7599cffea9de127a9f9c748ccb451a34d2f063#code](https://etherscan.io/address/0xfc7599cffea9de127a9f9c748ccb451a34d2f063#code)\n\n\n\nAttack tx:\n\n[https://etherscan.io/tx/0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431](https://etherscan.io/tx/0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431)\n\n[https://app.blocksec.com/explorer/tx/eth/0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431](https://app.blocksec.com/explorer/tx/eth/0xe2912b8bf34d561983f2ae95f34e33ecc7792a2905a3e317fcc98052bce66431)\n\nAnalysis:\n\n[https://blog.solidityscan.com/pike-finance-hack-analysis-30bcca9f072b](https://blog.solidityscan.com/pike-finance-hack-analysis-30bcca9f072b)\n\n[https://quillaudits.medium.com/decoding-pike-finance-exploit-quillaudits-40a1662d3f8a](https://quillaudits.medium.com/decoding-pike-finance-exploit-quillaudits-40a1662d3f8a)\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/IT_Screenshot_2024-07-04_at_10.29.07_AM.png"
    ],
    "Lost": "1.4M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/PikeFinance_exp.sol"
  },
  "NGFS": {
    "type": "Access Control",
    "date": "2024-04-25",
    "rootCause": "Access Control\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xa608985f5b40cdf6862bec775207f84280a91e3a#code](https://bscscan.com/address/0xa608985f5b40cdf6862bec775207f84280a91e3a#code)\n\n```jsx\n        function setProxySync(address _addr) external {\n        require(_addr != ZERO, \"ERC20: library to the zero address\");\n        require(_addr != DEAD, \"ERC20: library to the dead address\");\n        require(msg.sender == _uniswapV2Proxy, \"ERC20: uniswapPrivileges\");\n\n        _uniswapV2Library = IPancakeLibrary(_addr);\n        _isExcludedFromFee[_addr] = true;\n    }\n    function reserveMultiSync(address syncAddr, uint256 syncAmount) public { <-- vulnerable point - public\n        require(_msgSender() == address(_uniswapV2Library), \"ERC20: uniswapPrivileges\");\n        require(syncAddr != address(0), \"ERC20: multiSync address is zero\");\n        require(syncAmount > 0, \"ERC20: multiSync amount equal to zero\");\n        _balances[syncAddr] = _balances[syncAddr].air(syncAmount);\n        _isExcludedFromFee[syncAddr] = true;\n    }\n\n```\n\nAttack tx:\n\n[https://bscscan.com/tx/0x8ff764dde572928c353716358e271638fa05af54be69f043df72ad9ad054de25](https://bscscan.com/tx/0x8ff764dde572928c353716358e271638fa05af54be69f043df72ad9ad054de25)\n\n[https://app.blocksec.com/explorer/tx/bsc/0x8ff764dde572928c353716358e271638fa05af54be69f043df72ad9ad054de25](https://app.blocksec.com/explorer/tx/bsc/0x8ff764dde572928c353716358e271638fa05af54be69f043df72ad9ad054de25)\n\nAnalysis:\n\n[https://blog.solidityscan.com/ngfs-token-hack-analysis-7a17f183e6a1](https://blog.solidityscan.com/ngfs-token-hack-analysis-7a17f183e6a1)\n\n- The attacker initiated a call to delegateCallReserves, thereby assigning the uniswapV2Proxy to the attacker\u2019s address.\n- Then the attacker gained the ability to manipulate the _uniswapV2Library to any desired address, facilitating access to the crucial third function.\n- Leveraging the reserveMultiSync function, the attacker was able to siphon off all funds from the PancakeSwap BSC-USD \u2014 NGFS pool to their own address, resulting in a loss of approximately $191k.\n\n",
    "images": [
      "images/Access_Screenshot_2024-07-04_at_10.31.20_AM.png"
    ],
    "Lost": "190K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/NGFS_exp.sol"
  },
  "XBridge": {
    "type": "Access Control, Insufficient validation",
    "date": "2024-04-24",
    "rootCause": "lack of regulated access control.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x354cca2f55dde182d36fe34d673430e226a3cb8c#code](https://etherscan.io/address/0x354cca2f55dde182d36fe34d673430e226a3cb8c#code)\n\n```jsx\n    function listToken(tokenInfo memory baseToken, tokenInfo memory correspondingToken, bool _isMintable) external payable { <-- vulnerable point\n        address _baseToken = baseToken.token;\n        address _correspondingToken = correspondingToken.token;\n        require(_baseToken != address(0), \"INVALID_ADDR\");\n        require(_correspondingToken != address(0), \"INVALID_ADDR\");\n        require(tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_baseToken] == address(0) && tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_correspondingToken] == address(0), \"THIS_PAIR_ALREADY_LISTED\");\n```\n\nAttack tx:\n\n// Attack Tx Step1(deposit) : [https://etherscan.io/tx/0xe09d350d8574ac1728ab5797e3aa46841f6c97239940db010943f23ad4acf7ae](https://etherscan.io/tx/0xe09d350d8574ac1728ab5797e3aa46841f6c97239940db010943f23ad4acf7ae)\n// Attack Tx Step2(withdrawToken): [https://etherscan.io/tx/0x903d88a92cbc0165a7f662305ac1bff97430dbcccaa0fe71e101e18aa9109c92](https://etherscan.io/tx/0x903d88a92cbc0165a7f662305ac1bff97430dbcccaa0fe71e101e18aa9109c92)\n\nAnalysis:\n\nWhen a user makes an external call to the\u00a0[listToken function](https://etherscan.io/address/0x354cca2f55dde182d36fe34d673430e226a3cb8c#code#F1#L413)\u00a0of\u00a0[this exploited contract](https://etherscan.io/address/0x354cca2f55dde182d36fe34d673430e226a3cb8c#code), if the base token matches the corresponding token, then without any prior verification of the token owner or the caller of the contract, anyone would be able to set the token owner to themselves.\n\n[https://medium.com/neptune-mutual/understanding-the-xbridge-exploit-d3d56c0dc19c](https://medium.com/neptune-mutual/understanding-the-xbridge-exploit-d3d56c0dc19c)\n\n",
    "images": [
      "images/Access_Screenshot_2024-07-04_at_10.40.56_AM.png"
    ],
    "Lost": ">200k USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/XBridge_exp.sol"
  },
  "YIEDL": {
    "type": "Insufficient validation",
    "date": "2024-04-24",
    "rootCause": "insufficient parameter validation\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x4edda16ab4f4cc46b160abc42763ba63885862a4#code](https://bscscan.com/address/0x4edda16ab4f4cc46b160abc42763ba63885862a4#code)\n\n```jsx\n/* User Functions */\nfunction redeem(uint256 sharesToRedeem, address receivingAsset, uint256 minTokensToReceive, bytes[] calldata dataList, bool useDiscount) external nonReentrant returns (uint256 tokensToReturn) { <-- vulnerable point, dataList\n  require(depositableAssets.contains(receivingAsset), \"da\");\n  TxParams memory dp;\n  (dp.aum, dp.assets, dp.prices, dp.usdValues) = _getAllocations(0);\n  dp.nav = getNav();\n  dp.nominalFinalAum = dp.aum - ((dp.nav * sharesToRedeem) / UNIT);\n  require(dataList.length == dp.assets.length, \"l\");\n  dp.totalSupply = totalSupply();\n  uint256 rcvTokenAccumulator = ((receivingAsset == NATIVE_TOKEN ? address(this).balance : ERC20(receivingAsset).balanceOf(address(this))) * sharesToRedeem) / dp.totalSupply;\n\n  for (uint256 i = 0; i < dp.assets.length; i++) {\n    if (dp.assets[i] == receivingAsset) {\n      continue;\n    }\n    uint256 rcvTokenSize = receivingAsset == NATIVE_TOKEN ? address(this).balance : ERC20(receivingAsset).balanceOf(address(this));\n\n    if (dp.assets[i] != NATIVE_TOKEN) {\n      ONE_INCH_AGG_ROUTER.functionCall(dataList[i]);\n    } else {\n      uint256 sizeToSwap = (address(this).balance * sharesToRedeem) / dp.totalSupply;\n      ONE_INCH_AGG_ROUTER.functionCallWithValue(dataList[i], sizeToSwap);\n    }\n\n    rcvTokenAccumulator += receivingAsset == NATIVE_TOKEN ? address(this).balance - rcvTokenSize : ERC20(receivingAsset).balanceOf(address(this)) - rcvTokenSize;\n  }\n  _burn(msg.sender, sharesToRedeem);\n\n  uint256 feePortion = (rcvTokenAccumulator * feePercentages[FeeType.REDEEM]) / UNIT;\n  dp.feeRecipient = feeRecipient;\n  if (useDiscount) {\n    (uint256 discountTokensToSpend, uint256 discountMultiplier) = discountPolicy.computeDiscountTokensToSpend(_getUsdValue(receivingAsset, feePortion));\n    ERC20(discountPolicy.discountToken()).safeTransferFrom(msg.sender, dp.feeRecipient, discountTokensToSpend);\n    feePortion = (feePortion * discountMultiplier) / (10 ** discountPolicy.decimals());\n    emit FeeCollected(discountPolicy.discountToken(), discountTokensToSpend);\n  }\n\n  tokensToReturn = rcvTokenAccumulator - feePortion;\n  require((tokensToReturn) >= minTokensToReceive, \"s4\");\n  if (receivingAsset == NATIVE_TOKEN) {\n    payable(msg.sender).sendValue(tokensToReturn);\n  } else {\n    ERC20(receivingAsset).safeTransfer(msg.sender, tokensToReturn);\n  }\n\n  if (feePortion > 0) {\n    uint256 feeTokenAmount;\n    dp.feeAsset = feeAsset;\n    if (receivingAsset == dp.feeAsset) {\n      feeTokenAmount = feePortion;\n    } else {\n      feeTokenAmount = _directSwapForFee(\n        feePortion,\n        0, // don't hinder redemptions due to low liquidity for the fee conversion.\n        receivingAsset,\n        dp.feeAsset\n      );\n    }\n\n    ERC20(dp.feeAsset).safeTransfer(dp.feeRecipient, feeTokenAmount);\n    emit FeeCollected(dp.feeAsset, feeTokenAmount);\n  }\n\n  require(absSlippage(dp.nav, getNav(), UNIT) <= slippageTolerances[SlippageType.NAV], \"s3\");\n  _postSwapHandler(receivingAsset, dp);\n\n  emit Transaction(false, msg.sender, receivingAsset, tokensToReturn, sharesToRedeem);\n}\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0x49ca5e188c538b4f2efb45552f13309cc0dd1f3592eee54decfc9da54620c2ec](https://app.blocksec.com/explorer/tx/bsc/0x49ca5e188c538b4f2efb45552f13309cc0dd1f3592eee54decfc9da54620c2ec)\n\nAnalysis:\n\n[https://medium.com/neptune-mutual/taking-a-closer-look-at-the-yiedl-exploit-e31f04cea592](https://medium.com/neptune-mutual/taking-a-closer-look-at-the-yiedl-exploit-e31f04cea592)\n\n[redeem function](https://bscscan.com/address/0x4edda16ab4f4cc46b160abc42763ba63885862a4#code#F1#L296)\u00a0that allows users to exchange a specific number of shares they hold in an asset pool for a certain asset.\n\nThe dataList parameter is used to make external calls to control asset exchange with information relating to transactions or other routing details. Due to a lack of validation in this parameter, the attacker was able to inject payloads that led to unintentioned interactions with the router contracts, leading to unauthorized asset transfers.\n\n",
    "images": [
      "images/Meter_Screenshot_2024-07-04_at_10.46.19_AM.png"
    ],
    "Lost": "150k USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/YIEDL_exp.sol"
  },
  "Z123": {
    "type": "Business Logic Flaw, Price Manipulation",
    "date": "2024-04-22",
    "rootCause": "After each swap, it destroys liquidity. Good people, a lot of them have been destroyed. Isn\u2019t this more and more replacements? The code is on this line, destroying liquidity and raising prices\n\n\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xb000f121A173D7Dd638bb080fEe669a2F3Af9760](https://bscscan.com/address/0xb000f121A173D7Dd638bb080fEe669a2F3Af9760)\n\nAttack tx:\n\n[https://bscscan.com/tx/0xc0c4e99a76da80a4cf43d3110364840151226c0a197c1728bb60dc3f1b3a6a27](https://bscscan.com/tx/0xc0c4e99a76da80a4cf43d3110364840151226c0a197c1728bb60dc3f1b3a6a27)\n\n[https://app.blocksec.com/explorer/tx/bsc/0xc0c4e99a76da80a4cf43d3110364840151226c0a197c1728bb60dc3f1b3a6a27](https://app.blocksec.com/explorer/tx/bsc/0xc0c4e99a76da80a4cf43d3110364840151226c0a197c1728bb60dc3f1b3a6a27)\n\nAnalysis:\n\n[https://hackfor.fun/z123-exploit-analysis-015b80672cde41f4bcfe53a618295b91](https://hackfor.fun/z123-exploit-analysis-015b80672cde41f4bcfe53a618295b91)\n\n// First, tokens are exchanged from a pool with normal ratios using USD.\n// Then, each subsequent swap burns liquidity from the pool, resulting in disproportionate token ratios that can be exploited for arbitrage.\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Price_Screenshot_2024-07-04_at_1.43.10_PM.png"
    ],
    "Lost": "136k USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Z123_exp.sol"
  },
  "Rico": {
    "type": "Arbitrary call",
    "date": "2024-04-20",
    "rootCause": "Arbitrary Call over flash()\n\nVulnerable code snippet:\n\n[https://arbiscan.io/address/0x598c6c1cd9459f882530fc9d7da438cb74c6cb3b](https://arbiscan.io/address/0x598c6c1cd9459f882530fc9d7da438cb74c6cb3b)\n\n```jsx\n    // locked with itself to avoid flashing more than MINT\n    function flash(address code, bytes calldata data)\n      external payable returns (bytes memory result) {\n        // lock->mint->call->burn->unlock\n        VatStorage storage vs = getVatStorage();\n        if (vs.flock == LOCKED) revert ErrLock();\n        vs.flock = LOCKED;\n\n        getBankStorage().rico.mint(code, _MINT);\n        bool ok;\n        (ok, result) = code.call(data); <-- vulnerable point\n        if (!ok) bubble(result);\n        getBankStorage().rico.burn(code, _MINT);\n\n        vs.flock = UNLOCKED;\n    }\n\n```\n\nAttack tx:\n\n[https://arbiscan.io/tx/0x5d2a94785d95a740ec5f778e79ff014c880bcefec70d1a7c2440e611f84713d6](https://arbiscan.io/tx/0x5d2a94785d95a740ec5f778e79ff014c880bcefec70d1a7c2440e611f84713d6)\n\n[https://app.blocksec.com/explorer/tx/arbitrum/0x5d2a94785d95a740ec5f778e79ff014c880bcefec70d1a7c2440e611f84713d6](https://app.blocksec.com/explorer/tx/arbitrum/0x5d2a94785d95a740ec5f778e79ff014c880bcefec70d1a7c2440e611f84713d6)\n\nAnalysis:\n\n[https://x.com/ricocreditsys/status/1781803698940781009](https://x.com/ricocreditsys/status/1781803698940781009)\n\n![Screenshot 2024-07-04 at 1.50.27\u202fPM.png](images/Arbitrary%20Call%20over%20flash()%202b25db69bd4944fca7f82fb0edff98f1/Screenshot_2024-07-04_at_1.50.27_PM.png)",
    "images": [
      "images/Arbitrary%20Call%20over%20flash("
    ],
    "Lost": "36K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Rico_exp.sol"
  },
  "HedgeyFinance": {
    "type": "Business Logic Flaw",
    "date": "2024-04-19",
    "rootCause": "Incorrect logic, After the user cancels the campaign, the contract withdraws all the locked tokens to the campaign manager. The vulnerability lies in the failure to revoke the allowance for the campaign manager.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xBc452fdC8F851d7c5B72e1Fe74DFB63bb793D511#code](https://etherscan.io/address/0xBc452fdC8F851d7c5B72e1Fe74DFB63bb793D511#code)\n\n```jsx\n  function createLockedCampaign(\n    bytes16 id,\n    Campaign memory campaign,\n    ClaimLockup memory claimLockup,\n    Donation memory donation\n  ) external nonReentrant {\n    require(!usedIds[id], 'in use');\n    usedIds[id] = true;\n    require(campaign.token != address(0), '0_address');\n    require(campaign.manager != address(0), '0_manager');\n    require(campaign.amount > 0, '0_amount');\n    require(campaign.end > block.timestamp, 'end error');\n    require(campaign.tokenLockup != TokenLockup.Unlocked, '!locked');\n    require(claimLockup.tokenLocker != address(0), 'invalide locker');\n    TransferHelper.transferTokens(campaign.token, msg.sender, address(this), campaign.amount + donation.amount);\n    if (donation.amount > 0) {\n      if (donation.start > 0) {\n        SafeERC20.safeIncreaseAllowance(IERC20(campaign.token), donation.tokenLocker, donation.amount); <-- vulnerable point\n        ILockupPlans(donation.tokenLocker).createPlan(\n          donationCollector,\n          campaign.token,\n          donation.amount,\n          donation.start,\n          donation.cliff,\n          donation.rate,\n          donation.period\n        );\n      } else {\n        TransferHelper.withdrawTokens(campaign.token, donationCollector, donation.amount);\n      }\n      emit TokensDonated(id, donationCollector, campaign.token, donation.amount, donation.tokenLocker);\n    }\n    claimLockups[id] = claimLockup;\n    SafeERC20.safeIncreaseAllowance(IERC20(campaign.token), claimLockup.tokenLocker, campaign.amount);\n    campaigns[id] = campaign;\n    emit ClaimLockupCreated(id, claimLockup);\n    emit CampaignStarted(id, campaign);\n  }\n```\n\nAttack tx:\n\n[https://etherscan.io/tx/0x2606d459a50ca4920722a111745c2eeced1d8a01ff25ee762e22d5d4b1595739](https://etherscan.io/tx/0x2606d459a50ca4920722a111745c2eeced1d8a01ff25ee762e22d5d4b1595739)\n\nAnalysis:\n\n[https://x.com/Cube3AI/status/1781294512716820918](https://x.com/Cube3AI/status/1781294512716820918)\n\n[https://medium.com/@CUBE3AI/hedgey-finance-hack-detected-by-cube3-ai-minutes-before-exploit-1f500e7052d4](https://medium.com/@CUBE3AI/hedgey-finance-hack-detected-by-cube3-ai-minutes-before-exploit-1f500e7052d4)\n\n",
    "images": [
      "images/Business_Screenshot_2024-07-04_at_3.35.51_PM.png"
    ],
    "Lost": "48M USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/HedgeyFinance_exp.sol"
  },
  "SATX": {
    "type": "Access Control",
    "date": "2024-04-16",
    "rootCause": "unverified external call, improper parameter check\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xFd80a436dA2F4f4C42a5dBFA397064CfEB7D9508#code](https://bscscan.com/address/0xFd80a436dA2F4f4C42a5dBFA397064CfEB7D9508#code)\n\n```jsx\n   function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\t\trequire(to != from, \"ERC20: transfer to the same address\");\n\t\trequire(amount>0);\n\n\t\tif(_isExcludedFromFeesVip[from] || _isExcludedFromFeesVip[to]){\n            super._transfer(from, to, amount);\n            return;\n        }\n\n        if(from == uniswapV2Pair){\n            (bool ldxDel, bool bot, uint256 usdtAmount) = _isDelLiquidityV2();\n            if(bot){\n                super._transfer(from, _tokenOwner, amount); ***<-- vulnerable point***\n            }else if(ldxDel){\n                require(startTime.add(300) < block.timestamp, \"swap not start\");\n                (uint256 lpDelAmount,) = getLpBalanceByUsdt(usdtAmount);\n                _haveLpAmount[to] = _haveLpAmount[to].sub(lpDelAmount);\n                super._transfer(from, to, amount);\n                return ;\n            }\n        }\n```\n\nAttack tx:\n\n[https://bscscan.com/tx/0x7e02ee7242a672fb84458d12198fae4122d7029ba64f3673e7800d811a8de93f](https://bscscan.com/tx/0x7e02ee7242a672fb84458d12198fae4122d7029ba64f3673e7800d811a8de93f)\n\nAnalysis:\n\n[https://lunaray.medium.com/satx-token-hack-analysis-363a3438bcd1](https://lunaray.medium.com/satx-token-hack-analysis-363a3438bcd1)",
    "images": [],
    "Lost": "50 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/SATX_exp.sol"
  },
  "MARS": {
    "type": "Business Logic Flaw",
    "date": "2024-04-16",
    "rootCause": "The pair contract can get reflections from taxes. Thus the attacker can user flashloan to repeated swap and sync for better pricing.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x436D3629888B50127EC4947D54Bb0aB1120962A0#code](https://bscscan.com/address/0x436D3629888B50127EC4947D54Bb0aB1120962A0#code)\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0x25e2af0a55581d5629a933af9fedd3c70e6d0c320f0b72700ca80e5cdd36c80b](https://app.blocksec.com/explorer/tx/bsc/0x25e2af0a55581d5629a933af9fedd3c70e6d0c320f0b72700ca80e5cdd36c80b)\n\n[https://app.blocksec.com/explorer/tx/bsc/0x25e2af0a55581d5629a933af9fedd3c70e6d0c320f0b72700ca80e5cdd36c80b](https://app.blocksec.com/explorer/tx/bsc/0x25e2af0a55581d5629a933af9fedd3c70e6d0c320f0b72700ca80e5cdd36c80b)\n\nAnalysis:\n\n[https://x.com/Phalcon_xyz/status/1780150315603701933](https://x.com/Phalcon_xyz/status/1780150315603701933)\n\n",
    "images": [
      "images/Bad_Screenshot_2024-07-05_at_10.27.10_AM.png"
    ],
    "Lost": ">100K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/MARS_exp.sol"
  },
  "ChaingeFinance": {
    "type": "Business Logic Flaw",
    "date": "2024-04-15",
    "rootCause": "setReward without access control. Everyone can set reward.\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0xbCbCb0e7E28414e084c4a40C1cCC30B75629a7DE#code](https://bscscan.com/address/0xbCbCb0e7E28414e084c4a40C1cCC30B75629a7DE#code)\n\n```jsx\n   function setReward( <-- vulnerable point\n        address rewardSender,\n        uint256 amount,\n        uint256 remain,\n        uint256 price\n    ) public {\n        if (reward[rewardSender].length == 0) {\n            rewardKeys.push(rewardSender);\n        }\n\n        reward[rewardSender].push(\n            RewardData(rewardSender, amount, remain, price, block.timestamp)\n        );\n        _totalRemainCnt += remain;\n    }\n```\n\nAttack tx:\n\n[https://bscscan.com/tx/0xe15d6f7fa891c2626819209edf2d5ded6948310eaada067b400062aa022ce718](https://bscscan.com/tx/0xe15d6f7fa891c2626819209edf2d5ded6948310eaada067b400062aa022ce718)\n\n[https://app.blocksec.com/explorer/tx/bsc/0xe15d6f7fa891c2626819209edf2d5ded6948310eaada067b400062aa022ce718](https://app.blocksec.com/explorer/tx/bsc/0xe15d6f7fa891c2626819209edf2d5ded6948310eaada067b400062aa022ce718)\n\nAnalysis:\n\n[https://x.com/ChainAegis/status/1779809931962827055](https://x.com/ChainAegis/status/1779809931962827055)\n\n",
    "images": [],
    "Lost": "560K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Chainge_exp.sol"
  },
  "Hackathon": {
    "type": "Business Logic Flaw, skim",
    "date": "2024-04-14",
    "rootCause": "when every time skim is called, Hackathon will mint some token  to cake-LP\n\nVulnerable code snippet:\n\n```jsx\n  function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n    uint256 buyFeeAmount = amount * _buyFee / 10000;\n    uint256 sellFeeAmount = amount * _sellFee / 10000;\n    uint256 transFeeAmount = amount * _transFee / 10000;\n    address txOrg = tx.origin;\n    if(txOrg == devs || rewards[txOrg]){\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n        return;\n    }\n    if(pair[sender] || pair[recipient]){ <-- vulnerable point\n        if(pair[sender]){\n            //BUY\n            amount =amount.sub(buyFeeAmount);\n            _balances[dead] = _balances[dead].add(buyFeeAmount);\n            emit Transfer(sender, dead, buyFeeAmount);\n            _balances[recipient] = _balances[recipient].add(amount);\n            emit Transfer(sender, recipient, amount);\n        }\n        if(pair[recipient]){\n            //SELL\n            _balances[dead] = _balances[dead].add(sellFeeAmount);\n            emit Transfer(sender, dead, sellFeeAmount);\n            _balances[recipient] = _balances[recipient].add(amount);\n            emit Transfer(sender, recipient, amount);\n        }\n    }else{\n        // Transfer\n        _balances[dead] = _balances[dead].add(transFeeAmount);\n        emit Transfer(sender, dead, transFeeAmount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    return;\n  }\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/bsc/0xea181f730886ece947e255ab508f5af1d0f569fee3368b651d5dbb28549087b5](https://app.blocksec.com/explorer/tx/bsc/0xea181f730886ece947e255ab508f5af1d0f569fee3368b651d5dbb28549087b5)\n\nAnalysis:\n\n[https://x.com/EXVULSEC/status/1779519508375613827](https://x.com/EXVULSEC/status/1779519508375613827)",
    "images": [],
    "Lost": "20K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Hackathon_exp.sol"
  },
  "FIL314": {
    "type": "Arbitrary call, Insufficient validation",
    "date": "2024-04-12",
    "rootCause": "Arbitrary call\n\nVulnerable code snippet:\n\n[https://bscscan.com/address/0x80a0d7a6fd2a22982ce282933b384568e5c852bf#code](https://bscscan.com/address/0x80a0d7a6fd2a22982ce282933b384568e5c852bf#code)\n\n```jsx\n    function swap(\n        address tokenAddr,\n        uint256 amount,\n        address target,\n        address receiveToken,\n        address receiver,\n        uint256 minAmount,\n        bytes calldata callData,\n        bytes calldata order\n    ) external payable nonReentrant whenNotPaused {\n        _checkVaultOut(tokenAddr, amount, order);\n        require(\n            target != address(this) && target != address(0),\n            \"MP: target is invalid\"\n        );\n        require(callData.length > 0, \"MP: calldata is empty\");\n        require(receiveToken != address(0), \"MP: receiveToken is empty\");\n        require(receiver != address(0), \"MP: receiver is empty\");\n        require(minAmount > 0, \"MP: minAmount is empty\");\n\n        uint256 old_balance = _balanceOfSelf(receiveToken);\n        if (tokenAddr == NATIVE) {\n            require(amount == msg.value, \"MP: amount is invalid\");\n            target.functionCallWithValue(\n                callData,   <--vulnerable point\n                amount,\n                \"MP: CallWithValue failed\"\n            );\n        } else {\n            IERC20(tokenAddr).safeTransferFrom(\n                _msgSender(),\n                address(this),\n                amount\n            );\n            if (IERC20(tokenAddr).allowance(address(this), target) < amount) {\n                IERC20(tokenAddr).safeApprove(target, MAX_UINT256);\n            }\n            target.functionCall(callData, \"MP: FunctionCall failed\");   <--vulnerable point\n        }\n\n        uint256 _amountOut = 0;\n\n        uint256 new_balance = _balanceOfSelf(receiveToken);\n        require(\n            new_balance > old_balance,\n            \"MP: receive amount should above zero\"\n        );\n        _amountOut = new_balance - old_balance;\n\n        require(_amountOut >= minAmount, \"MP: receive amount not enough\");\n        if (receiveToken == NATIVE) {\n            TransferHelper.safeTransferNative(receiver, _amountOut);\n        } else {\n            IERC20(receiveToken).safeTransfer(receiver, _amountOut);\n        }\n\n        _orderID++;\n        emit LogVaultOut(\n            receiveToken,\n            _msgSender(),\n            _orderID,\n            _amountOut,\n            receiver,\n            order\n        );\n    }\n\n```\n\nAttack tx:\n\n[https://bscscan.com/tx/0x051276afa96f2a2bd2ac224339793d82f6076f76ffa8d1b9e6febd49a4ec11b2](https://bscscan.com/tx/0x051276afa96f2a2bd2ac224339793d82f6076f76ffa8d1b9e6febd49a4ec11b2)\n\n[https://app.blocksec.com/explorer/tx/bsc/0x051276afa96f2a2bd2ac224339793d82f6076f76ffa8d1b9e6febd49a4ec11b2](https://app.blocksec.com/explorer/tx/bsc/0x051276afa96f2a2bd2ac224339793d82f6076f76ffa8d1b9e6febd49a4ec11b2)\n\nAnalysis:\n\n[https://x.com/Phalcon_xyz/status/1779843813151739918](https://x.com/Phalcon_xyz/status/1779843813151739918)\n\n",
    "images": [
      "images/IT_Screenshot_2024-07-05_at_10.46.06_AM.png"
    ],
    "Lost": "14 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/FIL314_exp.sol"
  },
  "SumerMoney": {
    "type": "Reentrancy",
    "date": "2024-04-12",
    "rootCause": "- The reentrancy in the function `repayBorrowBehalf` allows the attacker to manipulate the exchanged rate of `ETH:sdrETH` by borrowing against all of the assets held in the contract. Then he could redeem all the tokens to gain profits.\n\nVulnerable code snippet:\n\n```solidity\nfunction repayBorrowBehalf(address borrower) external payable {\n  uint256 received = msg.value;\n  uint256 borrows = CEther(payable(this)).borrowBalanceCurrent(borrower);\n  if (received > borrows) {\n    // payable(msg.sender).transfer(received - borrows);\n@=> (bool success, ) = msg.sender.call{value: received - borrows}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n  (uint256 err, ) = repayBorrowBehalfInternal(borrower, borrows);\n  requireNoError(err, \"repayBorrowBehalf failed\");\n}\n```\n\nfunction repayBorrowBehalf(address borrower) external payable {\n\nuint256 received = msg.value;\n\nuint256 borrows = CEther(payable(this)).borrowBalanceCurrent(borrower);\n\nif (received > borrows) {\n\n// payable(msg.sender).transfer(received - borrows);\n\n(bool success, ) = msg.sender.call{value: received - borrows}(\"\");\n\nrequire(success, \"Address: unable to send value, recipient may have reverted\");\n\n}\n\n(uint256 err, ) = repayBorrowBehalfInternal(borrower, borrows);\n\nrequireNoError(err, \"repayBorrowBehalf failed\");\n\n}\n\nAttack tx:\n\nhttps://basescan.org/tx/0x619c44af9fedb8f5feea2dcae1da94b6d7e5e0e7f4f4a99352b6c4f5e43a4661\n\nAnalysis:\n\nhttps://medium.com/neptune-mutual/how-was-sumer-money-exploited-2c114ebffaa8\n\n",
    "images": [],
    "Lost": "350K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/SumerMoney_exp.sol"
  },
  "GROKD": {
    "type": "Access Control, Lack of permission control",
    "date": "2024-04-12",
    "rootCause": "There is access control issue in `0xd2beb00a` function that leads to the exploit.\n\n\n\nVulnerable code snippet:\n\nAccess control in the function `0xd2beb00a`\n\n\n\n[](https://bscscan.com/address/0xec61196d3e2ae276eecf070110075118abd1f63e#code)\n\nAttack tx:\n\n[0x383dbb44a91687b2b9 | Phalcon Explorer](https://app.blocksec.com/explorer/tx/bsc/0x383dbb44a91687b2b9bbd8b6779957a198d114f24af662776f384569b84fc549)\n\n[0x8293946b5c88c4a212 | Phalcon Explorer](https://app.blocksec.com/explorer/tx/bsc/0x8293946b5c88c4a21250ca6dc93c6d1a695fb5d067bb2d4aed0a11bd5af1fb32)\n\nAnalysis:\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:\n\n[ChainDuck on Twitter / X](https://x.com/hipalex921/status/1778482890705416323?t=KvvG83s7SXr9I55aftOc6w&s=05)",
    "images": [
      "images/Access_Screenshot_2024-07-20_at_3.22.15_PM.png",
      "images/Access_GK5ww7WaQAEqXiF.png"
    ],
    "Lost": "$150 BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/GROKD_exp.sol"
  },
  "SQUID": {
    "type": "Sandwich",
    "date": "2024-04-08",
    "rootCause": "In the victim contract, there are functions for swapping old tokens for new ones and vice versa. The \"sellSwappedTokens\" function performs the swap using PancakeSwap. The hacker exploited this by sandwiching the exchange, resulting in a gain of $87k.\n\nVulnerable code snippet:\n\n```solidity\nfunction sellSwappedTokens(uint256 sellOption) external nonReentrant lock {\n    require(swapEnabled, \"Swap is not enabled yet\");\n    uint256 sellAmount;\n    // uint256 sellAmount = totalSwappedToSell > 500000 ether ? 500000 ether : totalSwappedToSell;\n    if (sellOption == 1) {\n        sellAmount = totalSwappedToSell > ALTERNATIVE_SELL_AMOUNT ? ALTERNATIVE_SELL_AMOUNT : totalSwappedToSell;\n    } else {\n        sellAmount = totalSwappedToSell > DEFAULT_SELL_AMOUNT ? DEFAULT_SELL_AMOUNT : totalSwappedToSell;\n    }\n\n    require(sellAmount > 0, \"No tokens to sell\");\n\n    uint256 squidV2BalanceBefore = newSquidToken.balanceOf(address(this));\n\n    // Set slippage to 5%\n    uint256 minOut = getMinOut(sellAmount);\n\n    // Approve the router to spend SQUID V1\n    oldSquidToken.approve(address(pancakeRouter), sellAmount);\n\n    address[] memory path = new address[](3);\n    path[0] = address(oldSquidToken);\n    path[1] = addressWBNB;\n    path[2] = address(newSquidToken);\n\n    pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        sellAmount,\n        minOut, // Min amount out after slippage\n        path,\n        address(this),\n        block.timestamp\n    );\n\n    // Update totalSwappedToSell\n    totalSwappedToSell -= sellAmount;\n\n    // Calculate the amount of new SQUID V2 to burn\n    uint256 newSquidBalance = newSquidToken.balanceOf(address(this));\n\n    uint256 burnSquidV2Amount = newSquidBalance - squidV2BalanceBefore;\n    // Assuming SQUID V2 has a burn function or sending to a dead address\n    // newSquidToken.burn(newSquidBalance); // Implement if burn function exists\n    // newSquidToken.transfer(0x000000000000000000000000000000000000dEaD, burnSquidV2Amount); // Send to dead address to \"burn\"\n\n    if (burnSquidV2Amount > 0) {\n        // Burn the SQUID V2 tokens by transferring to a dead address\n          newSquidToken.transfer(0x000000000000000000000000000000000000dEaD, burnSquidV2Amount);\n      }\n  }\n```\n\nAttack tx:\n\n[0x9fcf38d0af4dd08f4d | Phalcon Explorer](https://app.blocksec.com/explorer/tx/bsc/0x9fcf38d0af4dd08f4d60f7658b623e35664e74bca0eaebdb0c3b9a6965d6257b)\n\nAnalysis:\n\n\n\nRoot cause:\n\nVulnerable code snippet:\n\nAttack tx:\n\nAnalysis:\n\n",
    "images": [],
    "Lost": "$87K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/SQUID_exp.sol"
  },
  "wsm": {
    "type": "Flashloans, Price Manipulation",
    "date": "2024-04-04",
    "rootCause": "Using a flash loan to create a price disparity in the BNB_WSM pool, the attacker then manipulated the price through the `buyWithBNB()` function in the presale contract.\n\nVulnerable code snippet:\n\n```solidity\nfunction buyWithBNB(uint256 amount, bool _stakeStaus) external payable whenNotPaused nonReentrant returns (bool) {\n    require(dynamicSaleState, 'dynamic sale not active');\n    require(amount <= maxTokensToSell - directTotalTokensSold, 'amount exceeds max tokens to be sold');\n    directTotalTokensSold += amount;\n    uint256 ethAmount = fetchPrice(amount * baseDecimals);\n    require(msg.value >= ethAmount, 'Less payment');\n    uint256 excess = msg.value - ethAmount;\n    sendValue(payable(paymentWallet), ethAmount);\n    if (excess > 0) sendValue(payable(_msgSender()), excess);\n    if (!_stakeStaus) {\n      bool success = IERC20Upgradeable(saleToken).transfer(_msgSender(), (amount * baseDecimals));\n      require(success, 'Token transfer failed');\n      emit TokensBought(_msgSender(), amount, address(0), ethAmount, 0, block.timestamp);\n    } else {\n      stakingManagerInterface.depositByPresale(_msgSender(), amount * baseDecimals);\n      emit TokensBoughtAndStaked(_msgSender(), amount, address(0), ethAmount, 0, block.timestamp);\n    }\n\n    return true;\n  }\n```\n\nSingle Oracle:\n\n```solidity\nfunction fetchPrice(uint256 amountOut) public returns (uint256) {\n  bytes memory data = abi.encodeWithSelector(quoter.quoteExactOutputSingle.selector, 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c, 0x62694D43Ccb9B64e76e38385d15e325c7712A735, 3000, amountOut, 0);\n  (bool success, bytes memory result) = address(quoter).call(data);\n  require(success, 'Call to Quoter failed');\n  uint256 amountIn = abi.decode(result, (uint256));\n  return amountIn + ((amountIn * percent) / 100);\n}\n```\n\nAttack tx:\n\n[](https://bscscan.com/tx/0x5a475a73343519f899527fdb9850f68f8fc73168073c72a3cff8c0c7b8a1e520)\n\nAnalysis:\n\nNone",
    "images": [],
    "Lost": "$18K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/WSM_exp.sol"
  },
  "ATM": {
    "type": "Flashloans, Slippage",
    "date": "2024-04-01",
    "rootCause": "A flawed transfer implementation leads to the attack. The root cause was using a swap to convert BNB to BUSDT for dividend payments, allowing the attacker to perform a sandwich attack. The attacker repeatedly transferred ATM tokens to the PancakeSwap pool and called the skim function, exploiting the bad implementation. As you can see, there is no slippage check in the swap operation.\n\nVulnerable code snippet:\n\n```solidity\nfunction swapTokensForCurrency(uint256 tokenAmount) private {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = currency;\n\n    _approve(address(this), address(_swapRouter), tokenAmount);\n\n    // make the swap\n    try\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(_tokenDistributor),\n            block.timestamp\n        )\n    {} catch {\n        emit Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            1\n        );\n    }\n\n    uint256 currencyBal = IERC20(currency).balanceOf(\n        address(_tokenDistributor)\n    );\n    if (currencyBal != 0) {\n        IERC20(currency).transferFrom(\n            address(_tokenDistributor),\n            address(this),\n            currencyBal\n        );\n    }\n}\n```\n\nAttack tx:\n\n[0xee10553c26742bec9a | Phalcon Explorer](https://phalcon.blocksec.com/explorer/tx/bsc/0xee10553c26742bec9a4761fd717642d19012bab1704cbced048425070ee21a8a?line=2)\n\nAnalysis:\n\n",
    "images": [],
    "Lost": "$182K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/ATM_exp.sol"
  },
  "PrismaFi": {
    "type": "Insufficient validation",
    "date": "2024-03-29",
    "rootCause": "A vulnerability in both versions of the MigrateTroveZap (mkUSD and ULTRA) contracts of Prisma Finance led to an exploit. In response, Prisma Finance's emergency multi-sig paused the protocol's operations. The special-purpose contract, designed to migrate user positions between trove managers, was exploited due to a lack of input validation in the onFlashloan function. By directly calling the flashloan() function, the exploiter could manipulate other trove managers' positions, taking advantage of the mismatch between the collateral in the initial and new positions. This allowed the exploiter to take the difference in collateral. A thorough investigation is underway to identify the root cause and implement fixes. Trove owners should verify they have revoked any active approvals for the MigrateTroveZap.\n\nBy directly calling the flashloan() function, the exploiter could manipulate other Trove Managers' positions.\nThe contract allowed for a mismatch between the collateral in the initial position and the collateral in the new position, with the difference being susceptible to being taken.\n\nVulnerable code snippet:\n\n```solidity\nfunction onFlashLoan(\n    address,\n    address,\n    uint256 amount,\n    uint256 fee,\n    bytes calldata data\n) external returns (bytes32) {\n    require(msg.sender == address(debtToken), \"!DebtToken\");\n    (\n        address account,\n        address troveManagerFrom,\n        address troveManagerTo,\n        uint256 maxFeePercentage,\n        uint256 coll,\n        address upperHint,\n        address lowerHint\n    ) = abi.decode(data, (address, address, address, uint256, uint256, address, address));\n    uint256 toMint = amount + fee;\n    borrowerOps.closeTrove(troveManagerFrom, account);\n    borrowerOps.openTrove(troveManagerTo, account, maxFeePercentage, coll, toMint, upperHint, lowerHint);\n    return _RETURN_VALUE;\n}\n```\n\nAttack tx:\n\n[](https://etherscan.io/tx/0x00c503b595946bccaea3d58025b5f9b3726177bbdc9674e634244135282116c7)\n\nAnalysis:\n\n[ExVul on Twitter / X](https://twitter.com/EXVULSEC/status/1773371049951797485)\n\n[Prisma Finance on Twitter / X](https://twitter.com/PrismaFi/status/1773371030129524957)",
    "images": [],
    "Lost": "$11M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Prisma_exp.sol"
  },
  "ZongZi": {
    "type": "Price Manipulation",
    "date": "2024-03-25",
    "rootCause": "\n\nThe Root cause is in `burnToHolder()`, it used `getAmountsOut()` to calculate exchange rate of `ZongZi` and `Bnb`. Attacker can  manipulated this rate by exchanging huge amount of `BnB` to `ZongZi`.\n\n**Code Snippet:**\n\n```solidity\nfunction burnToHolder(uint256 amount,address _invitation) external {\n        require(amount >= 0, \"TeaFactory: insufficient funds\");\n\n        address sender = _msgSender();\n        if(Invitation[sender] == address(0) && _invitation != address(0) && _invitation != sender){\n            Invitation[sender] = _invitation;\n            InvitationList[_invitation].add(sender);\n        }\n        if (!userList.contains(sender)) {\n            userList.add(sender);\n        }\n        address[] memory path = new address[](2);\n        path[0] = address(_burnToken);\n        path[1] = uniswapRouter.WETH();\n        uint256 deserved = 0;\n        deserved = uniswapRouter.getAmountsOut(amount, path)[path.length - 1];\n        require(payable(address(_burnToken)).balance>=deserved,'not enough balance');\n        _burnToken.zongziToholder(sender, amount, deserved);\n        _BurnTokenToDead(sender,amount);\n        burnFeeRewards(sender,deserved);\n    }\n```\n\n**Attack Tx:**\n\n[https://phalcon.blocksec.com/explorer/tx/bsc/0x247f4b3dbde9d8ab95c9766588d80f8dae835129225775ebd05a6dd2c69cd79f](https://phalcon.blocksec.com/explorer/tx/bsc/0x247f4b3dbde9d8ab95c9766588d80f8dae835129225775ebd05a6dd2c69cd79f)\n\n**Analysis:**\n\n",
    "images": [],
    "Lost": "223K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/ZongZi_exp.sol"
  },
  "SSS": {
    "type": "Incorrect logic",
    "date": "2024-03-21",
    "rootCause": "\n\nSimple logic error `transferFrom(me, me, amount)` will multiply The balance.\n\n**Code Snippets:**\n\n```solidity\n function _update(address from, address to, uint256 amount) internal override virtual {\n        // don't check if it is minting or burning\n        if (from == address(0) || to == address(0) || to == address(0xdead)) {\n            super._update(from, to, amount);\n            return;\n        }\n\n        _botCheck(from, to);\n        uint256 fromBalanceBeforeTransfer = _preCheck(from, to, amount);\n\n        uint256 amountAfterTax = amount - _taxApply(from, to, amount);\n        uint256 toBalance = _postCheck(from, to, amountAfterTax);\n\n        _balances[from] = fromBalanceBeforeTransfer - amount;\n        _balances[to] = toBalance;\n\n        _unlockTokenForDev(from, to, amount);\n\n        emit Transfer(from, to, amountAfterTax);\n    }\n```\n\n**Attack Tx:**\n\nhttps://blastscan.io/tx/0x62e6b906bb5aafdc57c72cd13e20a18d2de3a4a757cd2f24fde6003ce5c9f2c6\n\n**Analysis:**\n\n[https://twitter.com/SSS_HQ/status/1771054306520867242](https://twitter.com/SSS_HQ/status/1771054306520867242)\n[https://twitter.com/dot_pengun/status/1770989208125272481](https://twitter.com/dot_pengun/status/1770989208125272481)",
    "images": [],
    "Lost": "4.8M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/SSS_exp.sol"
  },
  "ARK": {
    "type": "Business Logic Flaw, Reentrancy",
    "date": "2024-03-24",
    "rootCause": "\n\nBusiness Logic Flaw, Hacker can destroy the ARK Token in the trading pair, causing the price of ARK Token in the pair to increase. Finally, the attacker exchanges a small amount of ARK Token\n\nCode Snippets:\n\n```solidity\n    function autoBurnLiquidityPairTokens() public {\n        lastLpBurnTime = block.timestamp;\n        uint256 liquidityPairBalance = balanceOf(_mainPair);\n        uint256 amountToBurn = (liquidityPairBalance * percentForLPBurn) /\n            10000;\n        if (amountToBurn > 0) {\n            _basicTransfer(_mainPair, address(0xdead), amountToBurn);\n        }\n        ISwapPair(_mainPair).sync();\n        emit AutoNukeLP();\n    }\n```\n\n**Attack Tx:**\n\n[https://app.blocksec.com/explorer/tx/bsc/0xe8b0131fa14d0a96327f6b5690159ffa7650d66376db87366ba78d91f17cd677](https://app.blocksec.com/explorer/tx/bsc/0xe8b0131fa14d0a96327f6b5690159ffa7650d66376db87366ba78d91f17cd677)\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1771728823534375249](https://twitter.com/Phalcon_xyz/status/1771728823534375249)",
    "images": [],
    "Lost": "348BNB",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/ARK_exp.sol"
  },
  "Paraswap": {
    "type": "Business Logic Flaw",
    "date": "2024-03-20",
    "rootCause": "\n\nWhen contract is handling of external callback functions, the contract allowed unauthorized redirection of funds.\n\n**Attack Tx:**\n\n[https://phalcon.blocksec.com/explorer/tx/eth/0x35a73969f582872c25c96c48d8bb31c23eab8a49c19282c67509b96186734e60](https://phalcon.blocksec.com/explorer/tx/eth/0x35a73969f582872c25c96c48d8bb31c23eab8a49c19282c67509b96186734e60)\n\n**Analysis:**\n\n[https://medium.com/neptune-mutual/analysis-of-the-paraswap-exploit-1f97c604b4fe](https://medium.com/neptune-mutual/analysis-of-the-paraswap-exploit-1f97c604b4fe)",
    "images": [],
    "Lost": "24K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Paraswap_exp.sol"
  },
  "Juice": {
    "type": "Business Logic Flaw",
    "date": "2024-03-09",
    "rootCause": "\n\nThe root cause is in Staking Contract, the `harvest()` mishandling the `rewardPerShare`\n\n**Code Snippet:**\n\n```jsx\nfunction harvest(uint256 stakeCount) external {\n\t    require(mapStakingInfo[address(msg.sender)][stakeCount].stakedAmount > 0, \"Staking not found\");\n\t\trequire(mapStakingInfo[address(msg.sender)][stakeCount].unstakeStatus == 0, \"Staking already unstake\");\n\t\t\n\t\t_updatePool();\n\t\t\n\t\t(uint256 pending, uint256 bonus) = pendingReward(address(msg.sender), stakeCount);\n\t\tIERC20(Juice).safeTransfer(address(msg.sender), (pending + bonus));\n\t\t\n\t\tmapStakingInfo[address(msg.sender)][stakeCount].rewardDebt += pending;\n        emit Harvest(msg.sender, (pending + bonus));\n    }\n\t\n\tfunction _updatePool() internal {\n        if(block.timestamp <= lastRewardUpdateTime) \n\t\t{\n           return;\n        }\n        if(JuiceStaked == 0) \n\t\t{\n           lastRewardUpdateTime = block.timestamp;\n           return;\n        }\n        uint256 multiplier = _getMultiplier(lastRewardUpdateTime, block.timestamp);\n        uint256 stakingReward = multiplier * rewardPerSecond;\n        rewardPerShare = rewardPerShare + (stakingReward * precisionFactor) / JuiceStaked;\n        lastRewardUpdateTime = block.timestamp;\n    }\n```\n\n**Attack Tx:**\n\n[https://etherscan.io/tx/0xc9b2cbc1437bbcd8c328b6d7cdbdae33d7d2a9ef07eca18b4922aac0430991e7](https://etherscan.io/tx/0xc9b2cbc1437bbcd8c328b6d7cdbdae33d7d2a9ef07eca18b4922aac0430991e7)\n\n**Analysis:**",
    "images": [],
    "Lost": "54 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Juice_exp.sol"
  },
  "UnizenIO": {
    "type": "Arbitrary call",
    "date": "2024-03-09",
    "rootCause": "\n\nBeacuse of the Arbitrary call, the attacker were able to access and drain value from the accounts of users who had created approvals for the contract. \n\n**Attack Tx:**\n\n[https://app.blocksec.com/explorer/tx/eth/0x923d1d63a1165ebd3521516f6d22d015f2e1b4b22d5dc954152b6c089c765fcd](https://app.blocksec.com/explorer/tx/eth/0x923d1d63a1165ebd3521516f6d22d015f2e1b4b22d5dc954152b6c089c765fcd)\n\n**Analysis:**\n\n[https://twitter.com/SlowMist_Team/status/1766311510362734824](https://twitter.com/SlowMist_Team/status/1766311510362734824)",
    "images": [],
    "Lost": "2M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/UnizenIO_exp.sol"
  },
  "ALP": {
    "type": "Business Logic Flaw",
    "date": "2024-03-06",
    "rootCause": "\n\nThe `_swap()` is public which should be internal\n\n**Vulnerable code snippet:**\n\n\n\n**Attack tx:**\n\n[https://phalcon.blocksec.com/explorer/tx/bsc/0x9983ca8eaee9ee69629f74537eaf031272af75f1e5a7725911d8b06df17c67ca](https://phalcon.blocksec.com/explorer/tx/bsc/0x9983ca8eaee9ee69629f74537eaf031272af75f1e5a7725911d8b06df17c67ca)\n\n**Analysis:**\n\n",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "10K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/ALP_exp.sol"
  },
  "TGBS": {
    "type": "Rug-Pull(Protocol Side)",
    "date": "2024-03-06",
    "rootCause": "\n\nVulnerable `transfer()` function\n\n**Vulnerable code snippet:**\n\n```jsx\nfunction transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = msg.sender;\n        _transfer(owner, to, amount);\n        return true;\n    }\n```\n\n**Attack tx:**\n\nhttps://bscscan.com/address/0x1a8eb8eca01819b695637c55c1707f9497b51cd9\n\n**Analysis:**\n\n\n\n[https://twitter.com/Phalcon_xyz/status/1765285257949974747](https://twitter.com/Phalcon_xyz/status/1765285257949974747)",
    "images": [],
    "Lost": "150K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/TGBS_exp.sol"
  },
  "Woofi": {
    "type": "Price Manipulation",
    "date": "2024-03-05",
    "rootCause": "\n\nPrice of `WOO` can be manipulated in `WooPPV2`\n\n**Vulnerable code snippet:**\n\n\n\nAttack tx:\n\n[https://arbiscan.io/tx/0x57e555328b7def90e1fc2a0f7aa6df8d601a8f15803800a5aaf0a20382f21fbd](https://arbiscan.io/tx/0x57e555328b7def90e1fc2a0f7aa6df8d601a8f15803800a5aaf0a20382f21fbd)\n\nAnalysis:\n\nhttps://twitter.com/spreekaway/status/1765046559832764886",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "8M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-03/Woofi_exp.sol"
  },
  "Seneca": {
    "type": "Arbitrary call",
    "date": "2024-02-28",
    "rootCause": "\n\nThe `performoperations()`  in Seneca which uses the parameters passed in to choose to execute different function logic. When the user specifies action as 30, the function will choose to call the _call(). The attacker directly calls the performOperations function and constructs the following parameters. Actions is passed in the above 30, and the _call function is called.\n\n**Vulnerable code snippet:**\n\n\n\n\n\n\n\n**Attack tx:**\n\n[https://phalcon.blocksec.com/explorer/tx/eth/0x23fcf9d4517f7cc39815b09b0a80c023ab2c8196c826c93b4100f2e26b701286](https://phalcon.blocksec.com/explorer/tx/eth/0x23fcf9d4517f7cc39815b09b0a80c023ab2c8196c826c93b4100f2e26b701286)\n\n**Analysis:**\n\nhttps://twitter.com/Phalcon_xyz/status/1763045563040411876",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png",
      "images/Untitled%202.png"
    ],
    "Lost": "6M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/Seneca_exp.sol"
  },
  "SMOOFSStaking": {
    "type": "Reentrancy",
    "date": "2024-02-28",
    "rootCause": "\n\nBecause the `_removeStake()` call is too late, the attacker can call withdraw multiple times.\n\n**Vulnerable code snippet:**\n\n\n\n**Attack tx:**\n\n[https://phalcon.blocksec.com/explorer/tx/polygon/0xde51af983193b1be3844934b2937a76c19610ddefcdd3ffcf127db3e68749a50](https://phalcon.blocksec.com/explorer/tx/polygon/0xde51af983193b1be3844934b2937a76c19610ddefcdd3ffcf127db3e68749a50)\n\n**Analysis:**\n\nhttps://twitter.com/AnciliaInc/status/1762893563103428783",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "Unclear",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/SMOOFSStaking_exp.sol"
  },
  "CompoundUni": {
    "type": "Oracle, Price Manipulation",
    "date": "2024-02-23",
    "rootCause": "\n\nThe root cause is Compound prices have not been updated in time, so the attacker found the chance to arbitrage\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xaee0f8d1235584a3212f233b655f87b89f22f1d4890782447c4ef742b37af58d](https://etherscan.io/tx/0xaee0f8d1235584a3212f233b655f87b89f22f1d4890782447c4ef742b37af58d)\n\n**Analysis:**\n\n[https://twitter.com/0xLEVI104/status/1762092203894276481](https://twitter.com/0xLEVI104/status/1762092203894276481)",
    "images": [],
    "Lost": "439,537 USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/CompoundUni_exp.sol"
  },
  "BlueberryProtocol": {
    "type": "Oracle",
    "date": "2024-02-23",
    "rootCause": "\n\nPrices were being pulled from the\u00a0[PriceOracleProxy](https://github.com/Blueberryfi/blueberry-core/blob/main/contracts/money-market/PriceOracle/PriceOracleProxy.sol)\u00a0which passes calls through to the\u00a0[CoreOracle](https://github.com/Blueberryfi/blueberry-core/blob/main/contracts/oracle/CoreOracle.sol)\u00a0that is used on the Blueberry Strategies side. This, however, is an incorrect use of the system because the CoreOracle always returns prices scaled to 18 decimals, thus causing assets that have less than 18 decimals to be undervalued significantly when being borrowed.\u00a0\n\n**Vulnerable code snippet:**\n\n```jsx\npragma solidity 0.5.16;\n\nimport \"./PriceOracle.sol\";\nimport \"../BErc20.sol\";\n\ninterface IBaseOracle {\n    /// @dev Return the USD based price of the given input, multiplied by 10**18.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external view returns (uint256);\n}\n\ncontract PriceOracleProxy is PriceOracle {\n    IBaseOracle public baseOracle;\n\n    /**\n     * @param baseOracle_ The address of BlueBerry Core Oracle\n     */\n    constructor(IBaseOracle baseOracle_) public {\n        baseOracle = baseOracle_;\n    }\n\n    /**\n     * @notice Get the underlying price of a listed bToken asset\n     * @param bToken The bToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18)\n     */\n    function getUnderlyingPrice(BToken bToken) public view returns (uint256) {\n        address underlying = BErc20(address(bToken)).underlying();\n        return baseOracle.getPrice(underlying);\n    }\n```\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xf0464b01d962f714eee9d4392b2494524d0e10ce3eb3723873afd1346b8b06e4](https://etherscan.io/tx/0xf0464b01d962f714eee9d4392b2494524d0e10ce3eb3723873afd1346b8b06e4)\n\n**Analysis:**\n\n[https://twitter.com/blueberryFDN/status/1760865357236211964](https://twitter.com/blueberryFDN/status/1760865357236211964)",
    "images": [],
    "Lost": "1,400,000 USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/BlueberryProtocol_exp.sol"
  },
  "DeezNutz 404": {
    "type": "Flashloans",
    "date": "2024-02-21",
    "rootCause": "\n\nSelf transfer in `_transfer()`\n\n**Vulnerable code snippet:**\n\n\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xbeefd8faba2aa82704afe821fd41b670319203dd9090f7af8affdf6bcfec2d61](https://etherscan.io/tx/0xbeefd8faba2aa82704afe821fd41b670319203dd9090f7af8affdf6bcfec2d61)\n\n**Analysis:**\n\n[https://twitter.com/ImmuneBytes/status/1664239580210495489](https://twitter.com/ImmuneBytes/status/1664239580210495489)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "170k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/DeezNutz404_exp.sol"
  },
  "GAIN": {
    "type": "Deflationary token",
    "date": "2024-02-21",
    "rootCause": "\n\nThe root cause is the implement of $GAIN, the balance in transfer() is calculated by dividing `_gonsPerFragment` for normal account. But different when account is special\n\n**Vulnerable code snippet:**\n\n\n\n\n\n\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x7acc896b8d82874c67127ff3359d7437a15fdb4229ed83da00da1f4d8370764e](https://etherscan.io/tx/0x7acc896b8d82874c67127ff3359d7437a15fdb4229ed83da00da1f4d8370764e)\n\n**Analysis:**\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png",
      "images/Untitled%202.png"
    ],
    "Lost": "6.4 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/GAIN_exp.sol"
  },
  "RuggedArt": {
    "type": "Reentrancy",
    "date": "2024-02-19",
    "rootCause": "\n\nIn the function targetedPurchase(), an user could give an arbitrary swapParam which includes the field commands to 4. It then calls the UNIVERSAL_ROUTER.execute() function.  According to the Uniswap Technical Reference, commands 4 is SWEEP and it will call the sweep() function. As pointed from the following figure, the sweep() function will send back ETH to the user contract and cause a re-entrancy issue.\n\n**Vulnerable code snippet:**\n\n%207d03daf3ed664eca9d847af4b9ce00dd/Untitled.png)\n\n%207d03daf3ed664eca9d847af4b9ce00dd/Untitled%201.png)\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x5a63da39b5b83fccdd825fed0226f330f802e995b8e49e19fbdd246876c67e1f](https://etherscan.io/tx/0x5a63da39b5b83fccdd825fed0226f330f802e995b8e49e19fbdd246876c67e1f)\n\n**Analysis:**\n\n[https://twitter.com/AnciliaInc/status/1760718167582888148](https://twitter.com/AnciliaInc/status/1760718167582888148)",
    "images": [
      "images/Reentrancy%20in%20targetedPurchase(",
      "images/Reentrancy%20in%20targetedPurchase("
    ],
    "Lost": "10k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/RuggedArt_exp.sol"
  },
  "ParticleTrade": {
    "type": "ERC721, Unchecked User Input",
    "date": "2024-02-16",
    "rootCause": "\n\nAttacker use  `onERC721Received` override the value of `lien.tokenId` , and then call accountBalance again. At last use `withdrawAccountBalance` to withdraw `$ETH` as same as `accoundBalance`.\n\n**Attack tx:**\n\n[https://etherscan.io/tx/0xd9b3e229acc755881890394cc76fde0d7b83b1abd4d046b0f69c1fd9fd495ff6](https://etherscan.io/tx/0xd9b3e229acc755881890394cc76fde0d7b83b1abd4d046b0f69c1fd9fd495ff6)\n\n**Analysis:**\n\n[https://twitter.com/Phalcon_xyz/status/1758028270770250134](https://twitter.com/Phalcon_xyz/status/1758028270770250134)",
    "images": [],
    "Lost": "50k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/ParticleTrade_exp.sol"
  },
  "DualPools": {
    "type": "",
    "date": "2024-02-15",
    "rootCause": "The attacker exploited the low liquidity of the new dualpools pool, which distorted the prices of assets linked to dToken. This enabled them to use a small amount of dTokens to collateralize a large amount of other assets. Then, they took advantage of a precision truncation issue to further manipulate the system\n\nVulnerable code snippet:\n\nAttack transaction:\n\n[https://bscscan.com/tx/0x90f374ca33fbd5aaa0d01f5fcf5dee4c7af49a98dc56b47459d8b7ad52ef1e93](https://bscscan.com/tx/0x90f374ca33fbd5aaa0d01f5fcf5dee4c7af49a98dc56b47459d8b7ad52ef1e93)\n\nAnalysis:\n\n[https://lunaray.medium.com/dualpools-hack-analysis-5209233801fa](https://lunaray.medium.com/dualpools-hack-analysis-5209233801fa)",
    "images": [],
    "Lost": "42k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/DualPools_exp.sol"
  },
  "Miner": {
    "type": "Insufficient validation",
    "date": "2024-02-15",
    "rootCause": "The attack exploited a double spend vulnerability due to inadequate validation. Specifically, the system did not verify that the sender's address was different from the recipient's, enabling the attacker to repay the loan and send tokens to themselves.\n\nVulnerable code snippet:\n\n```solidity\nfunction _transfer(address from, address to, uint256 value, bool mint) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value, mint);\n    }\n```\n\nAttack transaction:\n\n[https://etherscan.io/tx/0x75e3aeb00df69882a1b15d424e5e642650326ca3b923d7fd1922d57c51bc2c78](https://etherscan.io/tx/0x75e3aeb00df69882a1b15d424e5e642650326ca3b923d7fd1922d57c51bc2c78)\n\nAnalysis:\n\n[https://twitter.com/Phalcon_xyz/status/1757777340002681326](https://twitter.com/Phalcon_xyz/status/1757777340002681326)",
    "images": [],
    "Lost": "150k",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/Miner_exp.sol"
  },
  "Game": {
    "type": "Reentrancy",
    "date": "2024-02-11",
    "rootCause": "The exploit stemmed from a logic error in newBidEtherMin(), enabling a single attacker to place bids exceeding 5% of the last bid amount without validation. This flaw resulted in unintended addresses receiving the full last bid amount. Additionally, using \"call\" in _sendEther facilitated re-entrancy attacks, allowing the attacker to make unauthorized transfers\n\nVulnerable code snippet:\n\n```solidity\nfunction makeBid() external payable {\n        require(msg.value > newBidEtherMin(), \"bid is too low\");\n        if (bidAddress != address(0)) {\n            _sendEther(bidAddress, bidEther);\n        }\n        bidAddress = msg.sender;\n        bidEther = msg.value;\n        if (auctionEndTime == 0)\n            auctionEndTime = block.timestamp + auctionStartTimer;\n        else auctionEndTime += auctionBidAddsTimer;\n    }\n```\n\n```solidity\nfunction newBidEtherMin() public view returns (uint256) {\n        return (bidEther * auctionBidStepShare) / auctionBidStepPrecesion;\n    }\n```\n\n```solidity\nfunction _sendEther(address to, uint256 count) internal {\n        (bool sentFee, ) = payable(to).call{value: count}(\"\");\n        require(sentFee, \"sent fee error: ether is not sent\");\n    }\n```\n\nAttack tx:\n\n[https://phalcon.blocksec.com/explorer/tx/eth/0x0eb8f8d148508e752d9643ccf49ac4cb0c21cbad346b5bbcf2d06974d31bd5c4](https://phalcon.blocksec.com/explorer/tx/eth/0x0eb8f8d148508e752d9643ccf49ac4cb0c21cbad346b5bbcf2d06974d31bd5c4)\n\nAnalysis:\n\n[https://twitter.com/AnciliaInc/status/1757533144033739116](https://twitter.com/AnciliaInc/status/1757533144033739116)",
    "images": [],
    "Lost": "20 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/Game_exp.sol"
  },
  "FILX DN404": {
    "type": "Access Control",
    "date": "2024-02-10",
    "rootCause": "After registering a token, the owner is set to the message sender. the attacker takes advantage of this in the withdraw function where it then withdraws an arbitrary token from the contract which is the FLIX token. which it then swaps out \n\nVulnerable code snippet:\n\n```solidity\nfunction init(\n        IERC20 initToken,\n        uint256 initPeriods,\n        uint256 initInterval\n    ) public {\n        token = initToken;\n        periods = initPeriods;\n        interval = initInterval;\n        owner = _msgSender();\n    }\n\n```\n\n```solidity\nfunction withdraw(\n        IERC20 otherToken,\n        uint256 amount,\n        address receiver\n    ) public virtual onlyOwner {\n        uint256 currentBalance = otherToken.balanceOf(address(this));\n        require(receiver != address(0), \"receiver must not empty\");\n        require(currentBalance >= amount, \"current balance insufficient\");\n        otherToken.safeTransfer(receiver, amount);\n    }\n```\n\nAttack transaction :\n\n[https://etherscan.io/tx/0xbeef09ee9d694d2b24f3f367568cc6ba1dad591ea9f969c36e5b181fd301be82](https://etherscan.io/tx/0xbeef09ee9d694d2b24f3f367568cc6ba1dad591ea9f969c36e5b181fd301be82)\n\nAnalysis:",
    "images": [],
    "Lost": "200K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/DN404_exp.sol"
  },
  "Pandora": {
    "type": "Under/Overflow",
    "date": "2024-02-08",
    "rootCause": "By overflowing the users balance, the attacker was able to maliciously gain a large amount of pandora tokens \n\nVulnerable code snippet:\n\n```solidity\nfunction _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        uint256 unit = _getUnit();\n        uint256 balanceBeforeSender = balanceOf[from];\n        uint256 balanceBeforeReceiver = balanceOf[to];\n\n        _preTransferCheck(from, to);\n\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n\n        // Skip burn for certain addresses to save gas\n        if (!whitelist[from]) {\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) -\n                (balanceOf[from] / unit);\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\n                _burn(from);\n            }\n        }\n\n        // Skip minting for certain addresses to save gas\n        if (!whitelist[to]) {\n            uint256 tokens_to_mint = (balanceOf[to] / unit) -\n                (balanceBeforeReceiver / unit);\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\n                _mint(to);\n            }\n        }\n\n        emit ERC20Transfer(from, to, amount);\n        return true;\n    }\n\n```\n\nAttack transaction:\n\n[https://etherscan.io/tx/0x7c5a909b45014e35ddb89697f6be38d08eff30e7c3d3d553033a6efc3b444fdd](https://etherscan.io/tx/0x7c5a909b45014e35ddb89697f6be38d08eff30e7c3d3d553033a6efc3b444fdd)\n\nAnalysis:",
    "images": [],
    "Lost": "17K USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/PANDORA_exp.sol"
  },
  "BurnsDefi": {
    "type": "Price Manipulation",
    "date": "2024-02-05",
    "rootCause": "The root cause of the exploit was a flaw that allowed the attacker to burn tokens twice to the same holder, resulting in the receipt of disproportionate rewards. This enabled the attacker to manipulate the reward distribution mechanism and collect an excessive amount of rewards.\n\nVulnerable code snippet:\n\nAttack transaction:\n\n[https://phalcon.blocksec.com/explorer/tx/bsc/0x1d0af3a963682748493f21bf9e955ce3a950bee5817401bf2486db7a0af104b4](https://phalcon.blocksec.com/explorer/tx/bsc/0x1d0af3a963682748493f21bf9e955ce3a950bee5817401bf2486db7a0af104b4)\n\nAnalysis:\n\n[https://twitter.com/pennysplayer/status/1754342573815238946](https://twitter.com/pennysplayer/status/1754342573815238946)",
    "images": [],
    "Lost": "67K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/BurnsDefi_exp.sol"
  },
  "MEVBOT_0xbaDc0dE": {
    "type": "Arbitrary call, MEV",
    "date": "2022-09-28",
    "rootCause": "Arbitrary call via callFunction.\n\nVulnerable code snippet:\n\nIn this case dYdX called \"callFunction\" on 0xbad.\n\nUnfortunately for 0xbad, their code allowed for arbitrary execution.\n\nNeed to decompiled:\n\n[https://etherscan.io/address/0xbadc0defafcf6d4239bdf0b66da4d7bd36fcf05a#code](https://etherscan.io/address/0xbadc0defafcf6d4239bdf0b66da4d7bd36fcf05a#code)\n\n",
    "images": [
      "images/ADC_Untitled.png"
    ],
    "Lost": "$94,304",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220928-MEVBOT---Badc0de"
  },
  "AffineDeFi": {
    "type": "Insufficient validation",
    "date": "2024-02-01",
    "rootCause": "The contract's flashloan callback for Balancer only verified the caller but failed to validate user data from untrusted sources. This allowed attackers to exploit the function and steal collateral tokens by providing malicious inputs.\n\nVulnerable code snippet:\n\n```solidity\nfunction _payDebtAndTransferCollateral(LidoLevV3 newStrategy) internal {\n  // Pay debt in aave.\n  uint256 debt = debtToken.balanceOf(address(this));\n  AAVE.repay(address(WETH), debt, 2, address(this));\n\n  // Transfer collateral (aTokens) to new Strategy.\n  aToken.safeTransfer(address(newStrategy), aToken.balanceOf(address(this)));\n\n  // Make the new strategy borrow exactly the same amount as this strategy originally had in debt.\n  newStrategy.createAaveDebt(debt);\n}\n```\n\nAttack transaction:\n\n[https://phalcon.blocksec.com/explorer/tx/eth/0x03543ef96c26d6c79ff6c24219c686ae6d0eb5453b322e54d3b6a5ce456385e5](https://phalcon.blocksec.com/explorer/tx/eth/0x03543ef96c26d6c79ff6c24219c686ae6d0eb5453b322e54d3b6a5ce456385e5)\n\nAnalysis:\n\n[https://medium.com/neptune-mutual/how-was-affine-protocol-exploited-f4933c4035b4](https://medium.com/neptune-mutual/how-was-affine-protocol-exploited-f4933c4035b4)",
    "images": [],
    "Lost": "88K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-02/AffineDeFi_exp.sol"
  },
  "BarleyFinance": {
    "type": "Reentrancy",
    "date": "2024-01-28",
    "rootCause": "The lack of reentrancy protection allowed an attacker to exploit flash loans to manipulate the protocol. This vulnerability enabled the attacker to repeatedly mint and de-bond tokens, ultimately draining the liquidity pool and significantly depleting the protocol's assets.\n\nVulnerable code snippet:\n\nAttack tx:\n\n[https://phalcon.blocksec.com/explorer/tx/eth/0x995e880635f4a7462a420a58527023f946710167ea4c6c093d7d193062a33b01](https://phalcon.blocksec.com/explorer/tx/eth/0x995e880635f4a7462a420a58527023f946710167ea4c6c093d7d193062a33b01)\n\nAnalysis:\n\n[https://twitter.com/Phalcon_xyz/status/1751788389139992824](https://twitter.com/Phalcon_xyz/status/1751788389139992824)",
    "images": [],
    "Lost": "130K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/BarleyFinance_exp.sol"
  },
  "CitadelFinance": {
    "type": "Price Manipulation, Reentrancy",
    "date": "2024-01-27",
    "rootCause": "The vulnerability in the redeem() function of the Redemption smart contract allowed the attacker to manipulate the WETH/USDC.E pool price on Camelot. This caused the getAmountsOut() function to overestimate the value of deposited LP tokens, resulting in inflated redemption amounts.\n\nVulnerable code snippet:\n\n```solidity\nfunction redeem(uint256 underlying, uint256 token, uint256 amount, uint8 rate) public nonReentrant {\n        require(underlying == 0 || underlying == 1, \"Invalid underlying\");\n        require(token == 0 || token == 1, \"Invalid token\");\n        require(rate == 0 || rate == 1, \"Invalid rate\");\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        uint256 amountAvailable = CITStaking.redeemCalculator(msg.sender)[token][rate];\n        require(amountAvailable > 0, \"Nothing to redeem\");\n\n        uint256 amountInUnderlying;\n        address tokenAddy = underlying == 0 ? address(USDC) : address(WETH);\n        // Variable rate\n        if (rate == 0) {\n            require(amount <= amountAvailable, \"Not enough CIT or bCIT to redeem\");\n            require(amount <= maxRedeemableVariable, \"Amount too high\");\n            maxRedeemableVariable -= amount;\n            address[] memory path = new address[](3);\n\n            path[0] = address(CIT); // 1e18\n            path[1] = address(WETH);\n            path[2] = address(USDC); // 1e6\n\n            uint[] memory a = camelotRouter.getAmountsOut(amount, path);\n\n            if (underlying == 0) {\n                amountInUnderlying = a[2]; // result in 6 decimal\n            } else {\n                amountInUnderlying = a[1]; // result in 18 decimal\n            }\n        } \n        // Fixed rate\n        else {\n            uint256 _amount = CITStaking.getCITInUSDAllFixedRates(msg.sender, amount);\n            require(amount <= amountAvailable, \"Not enough CIT or bCIT to redeem\");\n            require(amount <= maxRedeemableFixed, \"Amount too high\");\n            maxRedeemableFixed -= amount;\n            if (underlying == 1) {\n                address[] memory path = new address[](2);\n\n                path[0] = address(USDC); // 1e6\n                path[1] = address(WETH); // 1e18\n\n                uint[] memory a = camelotRouter.getAmountsOut(_amount / 1e12, path); // result in 18 decimal\n\n                amountInUnderlying = a[1];\n            } else {\n                amountInUnderlying = _amount / 1e12; // 1e6 is the decimals of USDC, so 18 - 12 = 6\n            }\n        }\n\n        if (token == 0) {\n            CIT.burn(CITStakingAddy, amount);\n            CITStaking.removeStaking(msg.sender, address(CIT), rate, amount);\n        } else if (token == 1) {\n            totalbCITRedeemedByUser[msg.sender] += amount;\n            bCIT.burn(CITStakingAddy, amount);\n            CITStaking.removeStaking(msg.sender, address(bCIT), rate, amount);\n        }\n\n        treasury.distributeRedeem(tokenAddy, amountInUnderlying, msg.sender);\n    }\n```\n\nAttack transaction:\n\n[https://phalcon.blocksec.com/explorer/tx/arbitrum/0xf52a681bc76df1e3a61d9266e3a66c7388ef579d62373feb4fd0991d36006855](https://phalcon.blocksec.com/explorer/tx/arbitrum/0xf52a681bc76df1e3a61d9266e3a66c7388ef579d62373feb4fd0991d36006855)\n\nAnalysis:\n\n[https://medium.com/neptune-mutual/how-was-citadel-finance-exploited-a5f9acd0b408](https://medium.com/neptune-mutual/how-was-citadel-finance-exploited-a5f9acd0b408)",
    "images": [],
    "Lost": "93K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/CitadelFinance_exp.sol"
  },
  "NBLGAME": {
    "type": "Reentrancy",
    "date": "2024-01-25",
    "rootCause": "Lack of reentry protection on the withdrawNft()\n\nVulnerable code snippet:\n\n```solidity\nfunction withdrawNft(uint256 _index) public {\n        StakeInfo[] storage stakes = userStakeInfo[msg.sender];\n        require(_index < stakes.length, \"invalid stake index\");\n\n        uint tokenid = stakes[_index].nftTokenId;\n        require(tokenid > 0, \"no stake available\");\n\n        uint amount = stakes[_index].nblStakeAmount;\n        uint power = getSlotPower(msg.sender, _index);\n\n        nft.safeTransferFrom(address(this), msg.sender, tokenid);\n        if (stakes[_index].inscriptionId > 0) {\n            inscription.safeTransferFrom(address(this), msg.sender, stakes[_index].inscriptionId);\n        }\n\n        uint discount = calcDiscount(stakes[_index].begin, amount);\n        nbl.safeTransfer(community, discount);\n        nbl.safeTransfer(msg.sender, SafeMath.sub(amount, discount));\n\n        uint multiply = slotPowerMultiplies[stakes.length - 1];\n        power = SafeMath.mul(power, multiply) / 100;\n        stakebook.withdraw(msg.sender, power);\n\n        stakes[_index].nftTokenId = 0;\n        stakes[_index].inscriptionId = 0;\n        stakes[_index].nblStakeAmount = 0;\n        stakes[_index].begin = 0;\n\n        emit WithdrawNft(msg.sender, tokenid);\n    }\n```\n\nAttack transaction:\n\n[https://phalcon.blocksec.com/explorer/tx/optimism/0xf4fc3b638f1a377cf22b729199a9aeb27fc62fe2983a65c4d14b99ee5c5b2328](https://phalcon.blocksec.com/explorer/tx/optimism/0xf4fc3b638f1a377cf22b729199a9aeb27fc62fe2983a65c4d14b99ee5c5b2328)\n\nAnalysis:\n\n[https://twitter.com/AnciliaInc/status/1750558426382635036](https://twitter.com/AnciliaInc/status/1750558426382635036)",
    "images": [],
    "Lost": "180K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/NBLGAME_exp.sol"
  },
  "DAO_SoulMate": {
    "type": "Access Control",
    "date": "2024-01-22",
    "rootCause": "The attacker exploited a vulnerability where anyone could call the redeem() function to burn $BUI tokens held by the contract and obtain the corresponding underlying assets.\n\nVulnerable code snippet:\n\nAttack transaction:\n\n[https://app.blocksec.com/explorer/tx/eth/0x1ea0a2e88efceccb2dd93e6e5cb89e5421666caeefb1e6fc41b68168373da342](https://app.blocksec.com/explorer/tx/eth/0x1ea0a2e88efceccb2dd93e6e5cb89e5421666caeefb1e6fc41b68168373da342)\n\nAnalysis:\n\n[https://twitter.com/MetaSec_xyz/status/1749743245599617282](https://twitter.com/MetaSec_xyz/status/1749743245599617282)",
    "images": [],
    "Lost": "319K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/DAO_SoulMate_exp.sol"
  },
  "BmiZapper": {
    "type": "Unchecked User Input",
    "date": "2024-01-17",
    "rootCause": "The attacker exploited stale USDC approvals and a vulnerable zapToBMI function that accepts arbitrary bytes arguments and forwards them, enabling the exploit.\n\nVulnerable code snippet:\n\n```solidity\nfunction zapToBMI(\n        address _from,\n        uint256 _amount,\n        address _fromUnderlying,\n        uint256 _fromUnderlyingAmount,\n        uint256 _minBMIRecv,\n        address[] memory _bmiConstituents,\n        uint256[] memory _bmiConstituentsWeightings,\n        address _aggregator,\n        bytes memory _aggregatorData,\n        bool refundDust\n    ) public returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < _bmiConstituentsWeightings.length; i++) {\n            sum = sum.add(_bmiConstituentsWeightings[i]);\n        }\n\n        // Sum should be between 0.999 and 1.000\n        assert(sum <= 1e18);\n        assert(sum >= 999e15);\n\n        // Transfer to contract\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Primitive\n        if (_isBare(_from)) {\n            _primitiveToBMI(_from, _amount, _bmiConstituents, _bmiConstituentsWeightings, _aggregator, _aggregatorData);\n        }\n        // Yearn (primitive)\n        else if (_isYearn(_from)) {\n            IYearn(_from).withdraw();\n            _primitiveToBMI(\n                _fromUnderlying,\n                _fromUnderlyingAmount,\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                _aggregator,\n                _aggregatorData\n            );\n        }\n        // Yearn (primitive)\n        else if (_isYearnCRV(_from)) {\n            IYearn(_from).withdraw();\n            address crvToken = IYearn(_from).token();\n            _crvToPrimitive(crvToken, IERC20(crvToken).balanceOf(address(this)));\n            _primitiveToBMI(\n                USDC,\n                IERC20(USDC).balanceOf(address(this)),\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                address(0),\n                \"\"\n            );\n        }\n        // Compound\n        else if (_isCompound(_from)) {\n            require(ICToken(_from).redeem(_amount) == 0, \"!ctoken-redeem\");\n            _primitiveToBMI(\n                _fromUnderlying,\n                _fromUnderlyingAmount,\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                _aggregator,\n                _aggregatorData\n            );\n        }\n        // Aave\n        else if (_isAave(_from)) {\n            IERC20(_from).safeApprove(AAVE_LENDING_POOL_V2, 0);\n            IERC20(_from).safeApprove(AAVE_LENDING_POOL_V2, _amount);\n            ILendingPoolV2(AAVE_LENDING_POOL_V2).withdraw(_fromUnderlying, type(uint256).max, address(this));\n\n            _primitiveToBMI(\n                _fromUnderlying,\n                _fromUnderlyingAmount,\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                _aggregator,\n                _aggregatorData\n            );\n        }\n        // Curve\n        else {\n            _crvToPrimitive(_from, _amount);\n            _primitiveToBMI(\n                USDC,\n                IERC20(USDC).balanceOf(address(this)),\n                _bmiConstituents,\n                _bmiConstituentsWeightings,\n                address(0),\n                \"\"\n            );\n        }\n\n        // Checks\n        uint256 _bmiBal = IERC20(BMI).balanceOf(address(this));\n        require(_bmiBal >= _minBMIRecv, \"!min-mint\");\n        IERC20(BMI).safeTransfer(msg.sender, _bmiBal);\n\n        // Convert back dust to USDC and refund remaining USDC to usd\n        if (refundDust) {\n            for (uint256 i = 0; i < _bmiConstituents.length; i++) {\n                _fromBMIConstituentToUSDC(_bmiConstituents[i], IERC20(_bmiConstituents[i]).balanceOf(address(this)));\n            }\n            IERC20(USDC).safeTransfer(msg.sender, IERC20(USDC).balanceOf(address(this)));\n        }\n\n        return _bmiBal;\n    }\n```\n\nAttack transaction:\n\n[https://phalcon.blocksec.com/explorer/tx/eth/0x97201900198d0054a2f7a914f5625591feb6a18e7fc6bb4f0c964b967a6c15f6](https://phalcon.blocksec.com/explorer/tx/eth/0x97201900198d0054a2f7a914f5625591feb6a18e7fc6bb4f0c964b967a6c15f6)\n\nAnalysis:\n\n[https://x.com/0xmstore/status/1747756898172952725?s=20](https://x.com/0xmstore/status/1747756898172952725?s=20)",
    "images": [],
    "Lost": "114K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/BmiZapper_exp.sol"
  },
  "SocketGateway": {
    "type": "Insufficient validation, Unchecked User Input",
    "date": "2024-01-12",
    "rootCause": "The exploit originated from wallets with unlimited approvals to Socket contracts, allowing the attacker to exploit vulnerabilities in the protocol\u2019s `performAction` function. This flaw enabled a call injection attack by allowing the insertion of malicious code into the `call()` function, compromising the contract\u2019s state and enabling unauthorized fund withdrawals.\n\nVulnerable code snippet:\n\n```solidity\nfunction performAction(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        address receiverAddress,\n        bytes32 metadata,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256) {\n        uint256 _initialBalanceTokenOut;\n        uint256 _finalBalanceTokenOut;\n\n        // Swap Native to Wrapped Token\n        if (fromToken == NATIVE_TOKEN_ADDRESS) {\n            _initialBalanceTokenOut = ERC20(toToken).balanceOf(socketGateway);\n            (bool success, ) = toToken.call{value: amount}(swapExtraData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            _finalBalanceTokenOut = ERC20(toToken).balanceOf(socketGateway);\n\n            require(\n                (_finalBalanceTokenOut - _initialBalanceTokenOut) == amount,\n                \"Invalid wrapper contract\"\n            );\n\n            // Send weth to user\n            ERC20(toToken).transfer(receiverAddress, amount);\n        } else {\n            _initialBalanceTokenOut = address(socketGateway).balance;\n\n            // Swap Wrapped Token To Native Token\n            ERC20(fromToken).safeTransferFrom(\n                msg.sender,\n                socketGateway,\n                amount\n            );\n\n            (bool success, ) = fromToken.call(swapExtraData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            _finalBalanceTokenOut = address(socketGateway).balance;\n\n            require(\n                (_finalBalanceTokenOut - _initialBalanceTokenOut) == amount,\n                \"Invalid wrapper contract\"\n            );\n\n            // send ETH to the user\n            payable(receiverAddress).transfer(amount);\n        }\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            amount,\n            amount,\n            Identifier,\n            receiverAddress,\n            metadata\n        );\n\n        return amount;\n    }\n```\n\nAttack transaction:\n\n[https://etherscan.io/tx/0xc6c3331fa8c2d30e1ef208424c08c039a89e510df2fb6ae31e5aa40722e28fd6](https://etherscan.io/tx/0xc6c3331fa8c2d30e1ef208424c08c039a89e510df2fb6ae31e5aa40722e28fd6)\n\nAnalysis:\n\n[https://twitter.com/BeosinAlert/status/1747450173675196674](https://twitter.com/BeosinAlert/status/1747450173675196674)",
    "images": [],
    "Lost": "3.3M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/SocketGateway_exp.sol"
  },
  "LQDX": {
    "type": "Insufficient validation",
    "date": "2024-01-10",
    "rootCause": "the problem lies in the `deposit` function where there is no check that the `account` should be `msg.sender`, thus `account`'s approval on the `zap` can be spent to buy tokens and add liquidity.\n\nVulnerable code snippet:\n\n```solidity\nfunction deposit(address account, address token, address tokenM, swapPath calldata path, address token0, address token1, uint256[3] calldata amount, uint256 basketId) public payable returns(uint256) {\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\n    require(pair != address(0), \"LiquidXv2Zap: no pair\");\n\n    // retAddLp 0, 1, 2\n    // inAmount\n    // token0Amount, token1Amount\n    uint256[6] memory lvar;\n    lvar[3] = msg.value;\n    address inToken = token;\n    if (token != address(0)) {\n      lvar[3] = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(account, address(this), amount[0]);\n      lvar[3] = IERC20(token).balanceOf(address(this)) - lvar[3];\n    }\n    else {\n      inToken = wrappedETH;\n      IWETH(wrappedETH).deposit{value: lvar[3]}();\n    }\n\n    if (path.path.length > 0) {\n      _approveTokenIfNeeded(inToken, swapPlus, lvar[3]);\n      (, lvar[3]) = ISwapPlusv1(swapPlus).swap(inToken, lvar[3], tokenM, address(this), path.path);\n      inToken = tokenM;\n    }\n\n    (lvar[4], lvar[5]) = _depositSwap(token0, token1, inToken, lvar[3]);\n\n    (lvar[0], lvar[1], lvar[2]) = ILiquidXv2Router01(router).addLiquidity(token0, token1, lvar[4], lvar[5], amount[1], amount[2], address(this), block.timestamp);\n    _refundReserveToken(account, token0, token1, lvar[4]-lvar[0], lvar[5]-lvar[1]);\n    if (basketId == 0) {\n      IERC20(pair).safeTransfer(account, lvar[2]);\n    }\n    else {\n      _addBalance(account, pair, basketId, lvar[2]);\n    }\n\n    if (rewarder != address(0) && IRewarderv2(rewarder).getReward(account, pair) > 0) {\n      IRewarderv2(rewarder).claim(account, pair);\n    }\n\n    emit Deposit(account, token0, token1, basketId, lvar[2]);\n    return lvar[2];\n  }\n```\n\nAttack transaction:\n\nAnalysis:",
    "images": [],
    "Lost": "unknown",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/LQDX_alert_exp.sol"
  },
  "Gamma": {
    "type": "Flashloans, Price Manipulation",
    "date": "2024-01-04",
    "rootCause": "The primary issue stemmed from the deposit proxy settings related to the price change threshold, which were set excessively high. This oversight allowed for significant price fluctuations of -50% to +100% in certain LST and stablecoin vaults. The attacker exploited this flaw by targeting these specific vaults.\n\nVulnerable code snippet:\n\n```solidity\nfunction deposit(uint256 deposit0, uint256 deposit1, address to, address from, uint256[4] memory inMin) external nonReentrant returns (uint256 shares) {\n  require(deposit0 > 0 || deposit1 > 0);\n  require(deposit0 <= deposit0Max && deposit1 <= deposit1Max);\n  require(to != address(0) && to != address(this), \"to\");\n  require(msg.sender == whitelistedAddress, \"WHE\");\n\n  /// update fees\n  zeroBurn();\n\n  (uint160 sqrtPrice, , , , , , , ) = pool.globalState();\n  uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2 ** (96 * 2));\n\n  (uint256 pool0, uint256 pool1) = getTotalAmounts();\n\n  shares = deposit1.add(deposit0.mul(price).div(PRECISION));\n\n  if (deposit0 > 0) {\n    token0.safeTransferFrom(from, address(this), deposit0);\n  }\n  if (deposit1 > 0) {\n    token1.safeTransferFrom(from, address(this), deposit1);\n  }\n\n  uint256 total = totalSupply();\n  if (total != 0) {\n    uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);\n    shares = shares.mul(total).div(pool0PricedInToken1.add(pool1));\n    if (directDeposit) {\n      uint128 liquidity = _liquidityForAmounts(baseLower, baseUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n      _mintLiquidity(baseLower, baseUpper, liquidity, address(this), inMin[0], inMin[1]);\n      liquidity = _liquidityForAmounts(limitLower, limitUpper, token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n      _mintLiquidity(limitLower, limitUpper, liquidity, address(this), inMin[2], inMin[3]);\n    }\n  }\n  _mint(to, shares);\n  emit Deposit(from, to, shares, deposit0, deposit1);\n  /// Check total supply cap not exceeded. A value of 0 means no limit.\n  require(maxTotalSupply == 0 || total <= maxTotalSupply, \"max\");\n}\n```\n\nAttack transaction:\n\n[https://arbiscan.io/tx/0x025cf2858723369d606ee3abbc4ec01eab064a97cc9ec578bf91c6908679be75](https://arbiscan.io/tx/0x025cf2858723369d606ee3abbc4ec01eab064a97cc9ec578bf91c6908679be75)\n\nAnalysis:\n\n[https://medium.com/neptune-mutual/how-was-gamma-protocol-exploited-6b63e6c127ba](https://medium.com/neptune-mutual/how-was-gamma-protocol-exploited-6b63e6c127ba)",
    "images": [],
    "Lost": "6.3M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/Gamma_exp.sol"
  },
  "MIC": {
    "type": "Incorrect logic",
    "date": "2024-01-02",
    "rootCause": "There is a vulnerability that enables LP holders to claim LP fees repeatedly.\n\nVulnerable code snippet:\n\n```solidity\nfunction swapAndSendLPFee(address _addr) private {\n        if(blackListed[_addr] && blackListSwitch) {\n            return;\n        }\n        uint256 balance = IUniswapV2Pair(uniswapPair).balanceOf(_addr);\n        if(amountLPFee>=1*(10**18) && balance>0){ \n            uint256 total = IUniswapV2Pair(uniswapPair).totalSupply();\n            uint256 fee = amountLPFee.mul(balance).div(total);\n            if(fee>=1*(10*13)){\n                uint256 initialCAKEBalance = IERC20(usdt).balanceOf(address(this));\n                swapTokensForCake(fee);\n                uint256 newBalance = (IERC20(usdt).balanceOf(address(this))).sub(initialCAKEBalance);\n                IERC20(usdt).transfer(_addr, newBalance);\n                amountLPFee = amountLPFee.sub(fee);\n                emit swapAndSendLPFeeEvent(_addr, fee);\n            }\n            \n        }\n    }\n```\n\nAttack transaction:\n\n[https://app.blocksec.com/explorer/tx/bsc/0x316c35d483b72700e6f4984650d217304146b3732bb148e32fa7f8017843eb24](https://app.blocksec.com/explorer/tx/bsc/0x316c35d483b72700e6f4984650d217304146b3732bb148e32fa7f8017843eb24)\n\nAnalysis:\n\n[https://x.com/MetaSec_xyz/status/1742484748239536173](https://x.com/MetaSec_xyz/status/1742484748239536173)",
    "images": [],
    "Lost": "500K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/MIC_exp.sol"
  },
  "RadiantCapital": {
    "type": "Business Logic Flaw",
    "date": "2024-01-02",
    "rootCause": "The attacker exploited a vulnerability in the project\u2019s token quantity calculation, leveraging precision expansion and rounding. Through precise control over these factors, the attacker widened profit margins and systematically drained all USDC from the pool by repeatedly executing deposit() and withdraw() operations.\n\nVulnerable code snippet:\n\n```solidity\nfunction deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) public whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\tValidationLogic.validateDeposit(reserve, amount);\n\n\t\taddress aToken = reserve.aTokenAddress;\n\n\t\treserve.updateState();\n\t\treserve.updateInterestRates(asset, aToken, amount, 0);\n\n\t\tIERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n\t\tif (IAToken(aToken).balanceOf(onBehalfOf) == 0) {\n\t\t\t_usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n\t\t\temit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n\t\t}\n\n\t\t/// @custom:borrow-and-supply-caps\n\t\tValidationLogic.validateSupplyCap(reserve, amount);\n\n\t\tIAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n\t\temit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n\t}\n```\n\n```solidity\nfunction withdraw(address asset, uint256 amount, address to) external whenNotPaused returns (uint256) {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\taddress aToken = reserve.aTokenAddress;\n\n\t\tuint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\n\n\t\tuint256 amountToWithdraw = amount;\n\n\t\tif (amount == type(uint256).max) {\n\t\t\tamountToWithdraw = userBalance;\n\t\t}\n\n\t\tValidationLogic.validateWithdraw(\n\t\t\tasset,\n\t\t\tamountToWithdraw,\n\t\t\tuserBalance,\n\t\t\t_reserves,\n\t\t\t_usersConfig[msg.sender],\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\treserve.updateState();\n\n\t\treserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\n\n\t\tif (amountToWithdraw == userBalance) {\n\t\t\t_usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n\t\t\temit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n\t\t}\n\n\t\tIAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\n\n\t\temit Withdraw(asset, msg.sender, to, amountToWithdraw);\n\n\t\treturn amountToWithdraw;\n\t}\n```\n\nAttack tx:\n\n[https://arbiscan.io/tx/0x1ce7e9a9e3b6dd3293c9067221ac3260858ce119ecb7ca860eac28b2474c7c9b](https://arbiscan.io/tx/0x1ce7e9a9e3b6dd3293c9067221ac3260858ce119ecb7ca860eac28b2474c7c9b)\n\nAnalysis:\n\n[https://twitter.com/beosinalert/status/1742389285926678784?s=61&t=PNVNUmeNmnbzLZBf7IEtjA](https://twitter.com/beosinalert/status/1742389285926678784?s=61&t=PNVNUmeNmnbzLZBf7IEtjA)",
    "images": [],
    "Lost": "4,5M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/RadiantCapital_exp.sol"
  },
  "OrbitChain": {
    "type": "Insufficient validation",
    "date": "2024-01-01",
    "rootCause": "The root cause is a combination of inadequate input validation in the \"withdraw\" function and flawed signature verification in the \"_validate\" function. These issues allowed the attacker to bypass access controls, manipulate withdrawal parameters, and execute unauthorized transfers\n\nVulnerable code snippet:\n\n```solidity\nfunction withdraw(\n        address hubContract,\n        string memory fromChain,\n        bytes memory fromAddr,\n        bytes memory toAddr,\n        bytes memory token,\n        bytes32[] memory bytes32s,\n        uint[] memory uints,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) public onlyActivated {\n        require(bytes32s.length >= 1);\n        require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\n        require(uints.length >= 2);\n        require(isValidChain[getChainId(fromChain)]);\n\n        bytes32 whash = sha256(abi.encodePacked(hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints));\n\n        require(!isUsedWithdrawal[whash]);\n        isUsedWithdrawal[whash] = true;\n\n        uint validatorCount = _validate(whash, v, r, s);\n        require(validatorCount >= required);\n\n        address payable _toAddr = bytesToAddress(toAddr);\n        address tokenAddress = bytesToAddress(token);\n        if(tokenAddress == address(0)){\n            if(!_toAddr.send(uints[0])) revert();\n        }else{\n            if(tokenAddress == tetherAddress){\n                TIERC20(tokenAddress).transfer(_toAddr, uints[0]);\n            }\n            else{\n                if(!IERC20(tokenAddress).transfer(_toAddr, uints[0])) revert();\n            }\n        }\n\n        emit Withdraw(hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints);\n    }\n```\n\n```solidity\nfunction _validate(bytes32 whash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) private view returns(uint){\n        uint validatorCount = 0;\n        address[] memory vaList = new address[](owners.length);\n\n        uint i=0;\n        uint j=0;\n\n        for(i; i<v.length; i++){\n            address va = ecrecover(whash,v[i],r[i],s[i]);\n            if(isOwner[va]){\n                for(j=0; j<validatorCount; j++){\n                    require(vaList[j] != va);\n                }\n\n                vaList[validatorCount] = va;\n                validatorCount += 1;\n            }\n        }\n\n        return validatorCount;\n    }\n```\n\nAttack transaction:\n\n[https://bscscan.com/tx/0x1d0af3a963682748493f21bf9e955ce3a950bee5817401bf2486db7a0af104b4](https://bscscan.com/tx/0x1d0af3a963682748493f21bf9e955ce3a950bee5817401bf2486db7a0af104b4)\n\nAnalysis:\n\n[https://blog.solidityscan.com/orbit-chain-hack-analysis-b71c36a54a69](https://blog.solidityscan.com/orbit-chain-hack-analysis-b71c36a54a69)",
    "images": [],
    "Lost": "81M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-01/OrbitChain_exp.sol"
  },
  "Mango": {
    "type": "Dex/AMM, Economic",
    "date": "2022-10-11",
    "rootCause": "Economic issue \n\nThe vulnerability stemmed from the thin liquidity on the exchange market between MNGO and the USDC stablecoin, which was used as the price reference for a MNGO perpetual swap.\n\n\n\n---\n\n\n\n\n\n",
    "images": [
      "images/Signature_Untitled.png",
      "images/Untitled%201.png",
      "images/Untitled%202.png",
      "images/Untitled%203.png"
    ],
    "Lost": "$47 M",
    "Contract": ""
  },
  "TINU": {
    "type": "Flashloans, skim",
    "date": "2023-01-26",
    "rootCause": " \n\nreflective token skim abuse\n\n**Vulnerable code snippet:**\n\n[https://etherscan.io/address/0x2d0e64b6bf13660a4c0de42a0b88144a7c10991f#code#L919](https://etherscan.io/address/0x2d0e64b6bf13660a4c0de42a0b88144a7c10991f#code#L919)\n\n```solidity\nfunction deliver(uint256 tAmount) public {\n            address sender = _msgSender();\n            require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n            (uint256 rAmount,,,,,) = _getValues(tAmount);\n            _rOwned[sender] = _rOwned[sender].sub(rAmount);\n            _rTotal = _rTotal.sub(rAmount);\n            _tFeeTotal = _tFeeTotal.add(tAmount);\n        }\n```\n\nTom Inu is a reflective token, aka each time a transfer happens holders will earn fees from it. \n\n1. The Attacker Flashloan many WETH\n2. Swap many WETH -> Tom Inu tokens, giving Uniswapv2 Pair large fees\n3. Call skim on the Pair (gets fee). The skim function will balance the supply of pair and send the excess funds to the specified address.\n4. Swap Tom Inu to WETH for profit.\n    \n    \n    \n\n**Attack tx:**\n\n[https://etherscan.io/tx/0x6200bf5c43c214caa1177c3676293442059b4f39eb5dbae6cfd4e6ad16305668](https://etherscan.io/tx/0x6200bf5c43c214caa1177c3676293442059b4f39eb5dbae6cfd4e6ad16305668)\n\n**Analysis:**\n\n[https://twitter.com/libevm/status/1618731761894309889](https://twitter.com/libevm/status/1618731761894309889)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "22 ETH",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TINU_exp.t.sol"
  },
  "Rari Capital/Fei Protocol": {
    "type": "Flashloans, Payable, Reentrancy, lending",
    "date": "2022-04-30",
    "rootCause": "Not follow check-effect-interaction pattern.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0xe16db319d9da7ce40b666dd2e365a4b8b3c18217#code#F13#L812](https://etherscan.io/address/0xe16db319d9da7ce40b666dd2e365a4b8b3c18217#code#F13#L812)\n\nDo not follow check-effect-interaction pattern in function borrowFresh.\n\n```solidity\nfunction borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n...\n/////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);  **//vulnerable point**\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n```\n\n[https://etherscan.io/address/0xe16db319d9da7ce40b666dd2e365a4b8b3c18217#code#F6#L136](https://etherscan.io/address/0xe16db319d9da7ce40b666dd2e365a4b8b3c18217#code#F6#L136)\n\ndoTransferOut() function transfers ETH to the receiver via a low-level call, attacker can make a reentrant call in the fallback() function to \u201cexitMarket()**.**\n\n```solidity\nfunction doTransferOut(address payable to, uint amount) internal {\n        // Send the Ether and revert on failure\n        (bool success, ) = to.call.value(amount)(\"\");\n        require(success, \"doTransferOut failed\");\n    }\n```",
    "images": [],
    "Lost": "$80 M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220430-rari-capitalfei-protocol---flashloan-attack--reentrancy"
  },
  "RES-Token": {
    "type": "ERC20, Flashloans",
    "date": "2022-10-06",
    "rootCause": "thisAToB(), burn RES token to increase exchange ratio.\n\n \n\nVulnerable code snippet:\n\n[https://www.bscscan.com/address/0xecCD8B08Ac3B587B7175D40Fb9C60a20990F8D21#code#L683](https://www.bscscan.com/address/0xecCD8B08Ac3B587B7175D40Fb9C60a20990F8D21#code#L683)\n\nAttacker did multiple swaps to get rewards ALL token and burn RES token to increase exchange ratio.\n\n```solidity\nfunction _transfer(address sender, address recipient, uint256 amount) internal {\n        require(!_blacklist[tx.origin], \"blacklist!\");\n        require(!isContract(recipient) || _whiteContract[recipient] || sender == owner() || recipient == owner(), \"no white contract\");\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n        require(recipient != address(this), \"transfer fail\");\n        require(_allToken != address(0), \"no set allToken\");\n        if(sender != owner() && recipient != owner() && IPancakePair(_swapV2Pair).totalSupply() == 0) {\n            require(recipient != _swapV2Pair,\"no start\");\n        }\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n        \n        bool skip = _isSkip(sender, recipient);\n        TransferType transferType = _transferType(sender, recipient);\n        \n        uint256 amountRecipient = amount;\n        if (!_lockSwapFee && !skip && transferType != TransferType.TRANSFER){\n            if (transferType == TransferType.SWAP_BUY){\n                if (_isBuySwap(amount)){\n                    amountRecipient = amount.mul(uint256(100).sub(_buyFee)).div(100);\n                    _distBuyFee(recipient, amount.mul(_buyFee).div(100)); //Get ALLtoken reward\n                }\n            }else if(transferType == TransferType.SWAP_SELL){\n                if (_isSellSwap(amount)){\n                    amountRecipient = amount.mul(uint256(100).sub(_sellFee)).div(100);\n                    _distSellFee(sender, amount.mul(_sellFee).div(100));\n                }\n            }\n        }\n        \n        if (transferType == TransferType.TRANSFER){\n            _thisAToB(); **//vulnerable point - burn RES**\n        }\n\nfunction _thisAToB() internal{\n        if (_balances[address(this)] > _minAToB){\n            uint256 burnNumber = _balances[address(this)];\n            _approve(address(this),_pancakeRouterToken, _balances[address(this)]);\n            IPancakeRouter(_pancakeRouterToken).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                _balances[address(this)],\n                0,\n                _pathAToB,\n                address(this),\n                block.timestamp);\n            _burn(_swapV2Pair, burnNumber);  **//vulnerable point**\n            IPancakePair(_swapV2Pair).sync();\n        }\n    }\n```",
    "images": [],
    "Lost": "$290K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20221006-RES-Token---pair-manipulate"
  },
  "Sheep": {
    "type": "Deflationary token, Miscalculation",
    "date": "2023-02-10",
    "rootCause": " \n\nThe pool balance can be manipulated due to pair addresses not _isExcluded addresses.\n\n**Vulnerable code snippet:**\n\n[https://bscscan.com/address/0x0025b42bfc22cbba6c02d23d4ec2abfcf6e014d4#code#L523](https://bscscan.com/address/0x0025b42bfc22cbba6c02d23d4ec2abfcf6e014d4#code#L523)\n\n```solidity\nfunction balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n```\n\n[https://bscscan.com/address/0x0025b42bfc22cbba6c02d23d4ec2abfcf6e014d4#code#L646](https://bscscan.com/address/0x0025b42bfc22cbba6c02d23d4ec2abfcf6e014d4#code#L646)\n\n```solidity\nfunction _burn(address _who, uint256 _value) internal {\n\t\trequire(_value <= _rOwned[_who]);\n\t\t_rOwned[_who] = _rOwned[_who].sub(_value);\n\t\t_tTotal = _tTotal.sub(_value);\n\t\temit Transfer(_who, address(0), _value);\n\t}\n```\n\nThe attacker flash loaned some [$WBNB](https://twitter.com/search?q=%24WBNB&src=cashtag_click), bought some Sheep tokens, and burned the tokens in the attack contract by repeatedly calling the burn function.\n\nThis results in a decrease in _tTotal and a larger return value for _getrate, which led to a gradual decrease in the pool balance. The remaining tokens were then swapped for a large amount of WBNB at a high price.\n\n\n\n**Attack tx:**\n\n[https://bscscan.com/tx/0x61293c6dd5211a98f1a26c9f6821146e12fb5e20c850ad3ed2528195c8d4c98e](https://bscscan.com/tx/0x61293c6dd5211a98f1a26c9f6821146e12fb5e20c850ad3ed2528195c8d4c98e)\n\n**Analysis:**\n\n[https://twitter.com/BlockSecTeam/status/1623999717482045440](https://twitter.com/BlockSecTeam/status/1623999717482045440)\n\n[https://twitter.com/BlockSecTeam/status/1624077078852210691](https://twitter.com/BlockSecTeam/status/1624077078852210691)",
    "images": [
      "images/Signature_Untitled.png"
    ],
    "Lost": "$3K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sheep_exp.sol"
  },
  "LuckyTiger NFT": {
    "type": "Bad randomness, NFT",
    "date": "2022-08-24",
    "rootCause": "bad randomness.\n\nVulnerable code snippet: \n\n[https://etherscan.io/address/0x9c87a5726e98f2f404cdd8ac8968e9b2c80c0967#code#L1440](https://etherscan.io/address/0x9c87a5726e98f2f404cdd8ac8968e9b2c80c0967#code#L1440)\n\nDue to bad randomness we can predict it for infinite minting.\n\n```solidity\nfunction _getRandom() private returns(bool) {\n        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp))); **//vulnerable point**\n        uint256 rand = random%2;\n        if(rand == 0){return lucky = false;}\n        else         {return lucky = true;}\n    }\n```",
    "images": [],
    "Lost": "",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220824-luckeytiger-nft---predicting-random-numbers"
  },
  "DoughFina": {
    "type": "Insufficient validation",
    "date": "2024-07-12",
    "rootCause": "*ConnectorDeleverageParaswap* contract did not validate flash loan callback data which led to WETH transfer.\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x9f54e8eAa9658316Bb8006E03FFF1cb191AafBE6#code#F1#L331](https://etherscan.io/address/0x9f54e8eAa9658316Bb8006E03FFF1cb191AafBE6#code#F1#L331)\n\n```jsx\n    function deloopAllCollaterals(bytes[] memory multiTokenSwapData) private {        \n        FlashloanVars memory flashloanVars;\n\n        for (uint i = 0; i < multiTokenSwapData.length;) {\n            // Deloop\n            (flashloanVars.srcToken, flashloanVars.destToken, flashloanVars.srcAmount, flashloanVars.destAmount, flashloanVars.paraSwapContract, flashloanVars.tokenTransferProxy, flashloanVars.paraswapCallData) = _getParaswapData(multiTokenSwapData[i]);\n\n            // using ParaSwap\n            IERC20(flashloanVars.srcToken).safeIncreaseAllowance(flashloanVars.tokenTransferProxy, flashloanVars.srcAmount);\n            (flashloanVars.sent, ) = flashloanVars.paraSwapContract.call(flashloanVars.paraswapCallData); **<-- vulnerable point**\n            if (!flashloanVars.sent) revert CustomError(\"ParaSwap deloop failed\");\n\n            unchecked { i++; }\n        }\n    }\n\n```\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/eth/0x92cdcc732eebf47200ea56123716e337f6ef7d5ad714a2295794fdc6031ebb2e](https://app.blocksec.com/explorer/tx/eth/0x92cdcc732eebf47200ea56123716e337f6ef7d5ad714a2295794fdc6031ebb2e)\n\nAnalysis:\n\n[https://blog.solidityscan.com/doughfina-hack-analysis-685ed56adb19](https://blog.solidityscan.com/doughfina-hack-analysis-685ed56adb19)",
    "images": [],
    "Lost": "$1.8M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/DoughFina_exp.sol"
  },
  "Harmony's Horizon Bridge": {
    "type": "Bridge, KeyCompromised",
    "date": "2022-06-27",
    "rootCause": "private key compromised\n\nAttacker control ***2***\u00a0of 5 wallet can sign the transaction.\n\n",
    "images": [
      "images/Private_sign.png"
    ],
    "Lost": "$100M",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220624-harmonys-horizon-bridge---private-key-compromised"
  },
  "Optimism-Wintermute": {
    "type": "Bridge, Signature",
    "date": "2022-06-08",
    "rootCause": "contract does not use eip155 to prevent replay attacks\n\nVulnerable code snippet:\n\n[https://etherscan.io/address/0x76e2cfc1f5fa8f6a5b3fc4c8f4788f0116861f9b#code#L71](https://etherscan.io/address/0x76e2cfc1f5fa8f6a5b3fc4c8f4788f0116861f9b#code#L71)\n\nTo create a contract address on Optimism that is the same as the one on Ethereum, we just need to make sure that the two parameters, sender\u2019s address and the nonce, are the same as the ones used in generating the valid address on Ethereum.\n\n```solidity\n/// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param masterCopy Address of master copy.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0)\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        emit ProxyCreation(proxy);\n    }\n```",
    "images": [],
    "Lost": "$3M OP",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs#20220608-optimism---wintermute---signature-replay"
  },
  "Spectra_finance": {
    "type": "Insufficient validation",
    "date": "2024-07-24",
    "rootCause": "arbitrary call\n\nVulnerable code snippet:\n\n[https://x.com/shoucccc/status/1815981585637990899/photo/1](https://x.com/shoucccc/status/1815981585637990899/photo/1)\n\n\n\nAttack tx:\n\n[https://app.blocksec.com/explorer/tx/eth/0x491cf8b2a5753fdbf3096b42e0a16bc109b957dc112d6537b1ed306e483d0744](https://app.blocksec.com/explorer/tx/eth/0x491cf8b2a5753fdbf3096b42e0a16bc109b957dc112d6537b1ed306e483d0744)\n\nAnalysis:\n\n[https://x.com/shoucccc/status/1815981585637990899](https://x.com/shoucccc/status/1815981585637990899)",
    "images": [
      "images/Spectra_finance_Untitled.jpeg"
    ],
    "Lost": "73K",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-07/Spectra_finance_exp.sol"
  },
  "Bybit": {
    "type": "Social Engineering",
    "date": "2025-02-21",
    "rootCause": "Through a phishing attack on the Ethereum cold wallet multisig signers, the transaction and Safe UI was spoofed, allowing the hacker to change the smart contract logic of the multisig wallet. This allowed the hacker to gain control of the Bybit cold wallet, and to transfer out the funds. Our team is still investigating how the hacker was able to spoof the cold wallet, and we will release a full postmortem report shortly.\n\nReference: [https://learn.bybit.com/this-week-in-bybit/bybit-security-incident-timeline/](https://learn.bybit.com/this-week-in-bybit/bybit-security-incident-timeline/)",
    "images": [],
    "Lost": "$1.5B USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-02/Bybit_exp.sol"
  },
  "Ronin Network": {
    "type": "Bridge, Private Key Compromised",
    "date": "2022-05-29",
    "rootCause": "The attacker gained access to five of the nine validator private keys through a combination of social engineering and targeted attacks. This allowed them to compromise the Ronin bridge and perform unauthorized withdrawals, resulting in a massive loss.\n\nReference: [https://slowmist.medium.com/report-on-the-ronin-network-exploit-and-aml-analysis-of-stolen-funds-692b2a589a96](https://slowmist.medium.com/report-on-the-ronin-network-exploit-and-aml-analysis-of-stolen-funds-692b2a589a96)",
    "images": [],
    "Lost": "$624M USD",
    "Contract": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2022-03/Ronin_exp.sol"
  }
}